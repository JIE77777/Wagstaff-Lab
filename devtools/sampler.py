#!/usr/bin/env python3
"""Wagstaff-Lab Sample Pack Generator

Purpose
- 为“解析其他数据类型（STRINGS/Widgets/Brains/Stategraphs/LootTables/Components…）”准备可复用样本。
- 输出一个 *可直接喂给大模型* 的 Markdown（带 head + line-numbered snippets），并落盘 manifest.json 便于追溯。

Outputs
- data/samples/samples_<timestamp>.md
- data/samples/samples_<timestamp>.manifest.json

Notes
- 读取数据源来自 DST 的 scripts.zip / scripts/ 目录（通过 core/engine.py）。
- 样本选择优先参考 data/reports/asset_registry.md（如果存在）。
"""

from __future__ import annotations

import argparse
import hashlib
import json
import os
import random
import re
import sys
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Sequence, Tuple

# Mount core/
PROJECT_ROOT = Path(__file__).resolve().parent.parent
sys.path.insert(0, str(PROJECT_ROOT))

from core.engine import WagstaffEngine  # type: ignore

OUT_DIR = PROJECT_ROOT / "data" / "samples"
REPORT_DIR = PROJECT_ROOT / "data" / "reports"

DEFAULT_CATEGORIES = ["STRINGS", "Widgets", "Brains", "Stategraphs", "LootTables", "Components"]

# Fallback picks (used when no report-based guidance is available)
DEFAULT_FILES: Dict[str, List[str]] = {
    "STRINGS": ["scripts/strings.lua", "scripts/skin_strings.lua"],
    "Widgets": ["scripts/widgets/controls.lua", "scripts/screens/playerhud.lua"],
    "Brains": ["scripts/prefabs/pigman.lua", "scripts/prefabs/merm.lua"],
    "Stategraphs": ["scripts/stategraphs/SGwilson.lua", "scripts/stategraphs/SGwilson_client.lua"],
    "LootTables": ["scripts/prefabs/deciduoustrees.lua", "scripts/prefabs/evergreens.lua"],
    "Components": ["scripts/components/scenariorunner.lua", "scripts/components/debuffable.lua"],
}

CATEGORY_PREFIX_HINTS: Dict[str, List[str]] = {
    "Components": ["scripts/components/"],
    "Stategraphs": ["scripts/stategraphs/"],
    "Widgets": ["scripts/widgets/", "scripts/screens/"],
    "Brains": ["scripts/brains/", "scripts/behaviours/"]
}

# Snippet patterns are intentionally lightweight (line-based) for speed.
CATEGORY_PATTERNS: Dict[str, List[re.Pattern]] = {
    "STRINGS": [
        re.compile(r"\bSTRINGS\.[A-Z0-9_]+\b"),
        re.compile(r"\bSTRINGS\s*=\s*\{"),
    ],
    "Widgets": [
        re.compile(r"\brequire\s*\(?[\"']widgets/"),
        re.compile(r"\bClass\s*\("),
        re.compile(r"\bWidget\b"),
    ],
    "Brains": [
        re.compile(r"\brequire\s*\(?[\"']brains/"),
        re.compile(r"\brequire\s*\(?[\"']behaviours/"),
        re.compile(r"\bBrain\b"),
    ],
    "Stategraphs": [
        re.compile(r"\bStateGraph\s*\("),
        re.compile(r"\bstates\s*=\s*\{"),
        re.compile(r"\bevents\s*=\s*\{"),
    ],
    "LootTables": [
        re.compile(r"\bSetLoot\s*\("),
        re.compile(r"\bSetChanceLoot\s*\("),
        re.compile(r"\bloot\b"),
    ],
    "Components": [
        re.compile(r"\bClass\s*\("),
        re.compile(r"\binst:AddComponent\b"),
        re.compile(r"\bself\.[a-zA-Z0-9_]+\s*=\s*"),
    ],
}


def _now_iso() -> str:
    # Keep timezone offset (astimezone) for reproducibility across machines.
    return datetime.now().astimezone().isoformat(timespec="seconds")


def _now_ts() -> str:
    return datetime.now().strftime("%Y%m%d_%H%M%S")


def _sha256_12_text(text: str) -> str:
    h = hashlib.sha256(text.encode("utf-8", errors="replace"))
    return h.hexdigest()[:12]


def _safe_read_asset_registry(path: Path) -> Dict[str, List[str]]:
    """Parse data/reports/asset_registry.md into {Category: [file1, file2, ...]}.

    This report is generated by wagstaff report build --scan. It includes sections like:
    ### Widgets
    - `scripts/widgets/controls.lua`: 35
    """
    if not path.exists():
        return {}

    text = path.read_text(encoding="utf-8", errors="replace")
    lines = text.splitlines()

    current: Optional[str] = None
    out: Dict[str, List[str]] = {}

    header_re = re.compile(r"^###\s+(.+?)\s*$")
    item_re = re.compile(r"^\-\s+`([^`]+)`:\s*\d+\s*$")

    for line in lines:
        m = header_re.match(line)
        if m:
            current = m.group(1).strip()
            out.setdefault(current, [])
            continue
        m = item_re.match(line)
        if m and current:
            out.setdefault(current, []).append(m.group(1).strip())

    return out


def _file_size(engine: WagstaffEngine, path: str) -> int:
    try:
        if engine.mode == "zip":
            return engine.source.getinfo(path).file_size  # type: ignore[attr-defined]
        # folder
        real = os.path.join(engine.source, path.replace("scripts/", ""))  # type: ignore[arg-type]
        return os.path.getsize(real)
    except Exception:
        return -1


def _choose_files(
    engine: WagstaffEngine,
    category: str,
    n: int,
    registry_map: Dict[str, List[str]],
    rng: random.Random,
) -> List[str]:
    # 1) Prefer asset_registry.md hints
    picked: List[str] = []
    if category in registry_map:
        for p in registry_map[category]:
            if p in engine.file_list:
                picked.append(p)
            if len(picked) >= n:
                return picked

    # 2) Fallback defaults
    for p in DEFAULT_FILES.get(category, []):
        if p in engine.file_list and p not in picked:
            picked.append(p)
        if len(picked) >= n:
            return picked

    # 3) Prefix-based discovery
    prefixes = CATEGORY_PREFIX_HINTS.get(category, [])
    if prefixes:
        candidates: List[str] = []
        for f in engine.file_list:
            if not f.endswith(".lua"):
                continue
            if any(f.startswith(pref) for pref in prefixes):
                candidates.append(f)

        # Prefer larger files (tend to contain more structure)
        candidates.sort(key=lambda p: _file_size(engine, p), reverse=True)
        for p in candidates:
            if p not in picked:
                picked.append(p)
            if len(picked) >= n:
                return picked

    # 4) Last resort: random lua files
    lua_files = [f for f in engine.file_list if f.endswith(".lua")]
    rng.shuffle(lua_files)
    for p in lua_files:
        if p not in picked:
            picked.append(p)
        if len(picked) >= n:
            return picked

    return picked


def _pick_snippet_lines(
    lines: List[str],
    patterns: Sequence[re.Pattern],
    snippet_blocks: int,
    context_lines: int,
    rng: random.Random,
) -> List[Tuple[int, int]]:
    """Return a list of (start_idx, end_idx_exclusive) ranges."""
    match_idxs: List[int] = []
    for i, line in enumerate(lines):
        for pat in patterns:
            if pat.search(line):
                match_idxs.append(i)
                break

    # Dedup while preserving order
    seen = set()
    match_idxs = [i for i in match_idxs if not (i in seen or seen.add(i))]

    # If too many matches, sample evenly across the file for coverage
    chosen_idxs: List[int] = []
    if len(match_idxs) == 0:
        # fallback: choose some random anchors
        if lines:
            anchors = list(range(0, len(lines), max(1, len(lines) // max(1, snippet_blocks))))
            rng.shuffle(anchors)
            chosen_idxs = sorted(anchors[:snippet_blocks])
    elif len(match_idxs) <= snippet_blocks:
        chosen_idxs = match_idxs
    else:
        if snippet_blocks == 1:
            chosen_idxs = [match_idxs[len(match_idxs) // 2]]
        else:
            for k in range(snippet_blocks):
                pos = int(k * (len(match_idxs) - 1) / (snippet_blocks - 1))
                chosen_idxs.append(match_idxs[pos])

    ranges: List[Tuple[int, int]] = []
    covered: List[Tuple[int, int]] = []

    for idx in chosen_idxs:
        s = max(0, idx - context_lines)
        e = min(len(lines), idx + context_lines + 1)

        # Skip heavy overlap
        overlapped = False
        for cs, ce in covered:
            if not (e <= cs or s >= ce):
                overlapped = True
                break
        if overlapped:
            continue

        covered.append((s, e))
        ranges.append((s, e))

    return ranges


def _render_snippet(lines: List[str], start: int, end: int) -> str:
    out: List[str] = []
    for i in range(start, end):
        ln = i + 1
        out.append(f"{ln:5d}: {lines[i]}")
    return "\n".join(out)


def _cap_text(text: str, max_chars: int) -> Tuple[str, bool]:
    if len(text) <= max_chars:
        return text, False
    return text[: max_chars - 200] + "\n\n[TRUNCATED: per-file cap]\n", True


@dataclass
class FileSample:
    path: str
    sha256_12: str
    lines: int
    head_lines: int
    snippet_blocks: int
    rendered: str


def build_sample_pack(
    categories: List[str],
    n_files_per_category: int,
    head_lines: int,
    snippet_blocks: int,
    context_lines: int,
    max_chars_per_file: int,
    max_total_chars: int,
    seed: int,
) -> Tuple[str, Dict[str, object]]:
    engine = WagstaffEngine(load_db=False, silent=True)

    asset_registry_path = REPORT_DIR / "asset_registry.md"
    recipe_distribution_path = REPORT_DIR / "recipe_distribution.md"

    registry_map = _safe_read_asset_registry(asset_registry_path)

    rng = random.Random(seed)

    # Collect samples
    chosen: Dict[str, List[str]] = {}
    files_meta: Dict[str, List[Dict[str, object]]] = {}

    md: List[str] = []
    md.append("# Wagstaff-Lab Lua Sample Pack")
    md.append("")
    md.append("## Meta")
    md.append("```yaml")
    md.append(f"generated: {_now_iso()}")
    md.append(f"engine_mode: {engine.mode}")
    md.append(f"categories: {categories}")
    md.append(f"n_files_per_category: {n_files_per_category}")
    md.append(f"head_lines: {head_lines}")
    md.append(f"snippet_blocks: {snippet_blocks}")
    md.append(f"context_lines: {context_lines}")
    md.append("```")

    total_chars = sum(len(x) + 1 for x in md)

    for cat in categories:
        md.append("")
        md.append(f"## Category: {cat}")
        md.append("")

        selected = _choose_files(engine, cat, n_files_per_category, registry_map, rng)
        chosen[cat] = selected
        files_meta[cat] = []

        patterns = CATEGORY_PATTERNS.get(cat, [])

        for p in selected:
            content = engine.read_file(p) or ""
            if not content:
                continue

            lines = content.splitlines()

            head = "\n".join(lines[:head_lines])
            ranges = _pick_snippet_lines(lines, patterns, snippet_blocks, context_lines, rng)

            snips: List[str] = []
            for i, (s, e) in enumerate(ranges, start=1):
                snips.append(f"**Snippet {i}**\n```lua\n{_render_snippet(lines, s, e)}\n```")

            rendered = []
            rendered.append(f"### File: {p}")
            sha = _sha256_12_text(content)
            rendered.append(f"> sha256_12={sha}, lines={len(lines)}")
            rendered.append("")
            rendered.append("#### Head")
            rendered.append("```lua")
            rendered.append(head)
            rendered.append("```")
            rendered.append("")
            rendered.append("#### Snippets (line-numbered)")
            rendered.append("")
            rendered.append("\n\n".join(snips) if snips else "(no snippets found)")

            block = "\n".join(rendered) + "\n"
            block, truncated = _cap_text(block, max_chars_per_file)

            # Total budget check
            if total_chars + len(block) > max_total_chars:
                md.append("\n[STOP: max_total_chars reached]\n")
                break

            md.append(block)
            total_chars += len(block)

            files_meta[cat].append(
                {
                    "path": p,
                    "sha256_12": sha,
                    "lines": len(lines),
                    "head_lines": min(head_lines, len(lines)),
                    "snippet_blocks": len(ranges),
                    "truncated": truncated,
                }
            )

    manifest: Dict[str, object] = {
        "generated": _now_iso(),
        "engine_mode": engine.mode,
        "categories": categories,
        "chosen": chosen,
        "files": files_meta,
        "source_reports": {
            "asset_registry": str(asset_registry_path) if asset_registry_path.exists() else None,
            "recipe_distribution": str(recipe_distribution_path) if recipe_distribution_path.exists() else None,
        },
        "params": {
            "n_files_per_category": n_files_per_category,
            "head_lines": head_lines,
            "snippet_blocks": snippet_blocks,
            "context_lines": context_lines,
            "seed": seed,
        },
        "limits": {
            "max_chars_per_file": max_chars_per_file,
            "max_total_chars": max_total_chars,
        },
    }

    return "\n".join(md) + "\n", manifest


def main() -> None:
    parser = argparse.ArgumentParser(description="Generate DST Lua sample pack for parser development.")
    parser.add_argument("--categories", nargs="*", default=DEFAULT_CATEGORIES, help="Categories to include")
    parser.add_argument("--n", type=int, default=2, help="Files per category")
    parser.add_argument("--head-lines", type=int, default=120)
    parser.add_argument("--snippet-blocks", type=int, default=10)
    parser.add_argument("--context-lines", type=int, default=4)
    parser.add_argument("--max-chars-per-file", type=int, default=18000)
    parser.add_argument("--max-total-chars", type=int, default=260000)
    parser.add_argument("--seed", type=int, default=0)
    parser.add_argument("--out-dir", default=str(OUT_DIR))
    args = parser.parse_args()

    out_dir = Path(args.out_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    md, manifest = build_sample_pack(
        categories=list(args.categories),
        n_files_per_category=args.n,
        head_lines=args.head_lines,
        snippet_blocks=args.snippet_blocks,
        context_lines=args.context_lines,
        max_chars_per_file=args.max_chars_per_file,
        max_total_chars=args.max_total_chars,
        seed=args.seed,
    )

    ts = _now_ts()
    md_path = out_dir / f"samples_{ts}.md"
    manifest_path = out_dir / f"samples_{ts}.manifest.json"

    md_path.write_text(md, encoding="utf-8")
    manifest_path.write_text(json.dumps(manifest, ensure_ascii=False, indent=2), encoding="utf-8")

    print(f"✅ Sample pack written: {md_path}")
    print(f"✅ Manifest written: {manifest_path}")


if __name__ == "__main__":
    main()
