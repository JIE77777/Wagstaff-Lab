# Wagstaff-Lab Project Snapshot

## 1. Environment Diagnostics
```yaml
Time: 2026-01-12 16:42:38
User: steam
Host: VM-8-2-ubuntu (Linux 6.8.0-49-generic)
Python: 3.13.11 (/home/steam/miniconda3/bin/python3)
Rich Ver: Installed (ver unknown)
--------------------
Branch: main [DIRTY]
Commit: 9b711b1
Message: Feat: Add Deep Analyzer to Explorer and fix Wiki regex
```

## 2. Project Structure
```text
â”œâ”€â”€ .gitignore
â”œâ”€â”€ PROJECT_STATUS.json
â”œâ”€â”€ README.md
â”œâ”€â”€ bin
â”‚   â”œâ”€â”€ .dst_tool.sh.swp
â”‚   â”œâ”€â”€ Wagstaff-Lab
â”‚   â”œâ”€â”€ boot.sh
â”‚   â”œâ”€â”€ dst_tool.sh
â”‚   â”œâ”€â”€ pm
â”‚   â””â”€â”€ wagstaff
â”œâ”€â”€ conf
â”‚   â””â”€â”€ settings.ini
â”œâ”€â”€ data
â”‚   â””â”€â”€ reports
â”‚       â”œâ”€â”€ asset_registry.md
â”‚       â””â”€â”€ recipe_distribution.md
â”œâ”€â”€ devtools
â”‚   â”œâ”€â”€ installer.py
â”‚   â”œâ”€â”€ pm.py
â”‚   â”œâ”€â”€ reporter.py
â”‚   â””â”€â”€ snapshot.py
â”œâ”€â”€ setup.sh
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ analyzer.py
â”‚   â”œâ”€â”€ engine.py
â”‚   â”œâ”€â”€ explorer.py
â”‚   â”œâ”€â”€ guide.py
â”‚   â”œâ”€â”€ registry.py
â”‚   â”œâ”€â”€ utils.py
â”‚   â””â”€â”€ wiki.py
â””â”€â”€ tests
    â””â”€â”€ test_recipes.py

```

## 3. Source Code

### File: bin/boot.sh
```sh
#!/bin/bashif reci$CLUSTER_NAME

# =========================================================
# Wagstaff-Lab Bootloader (å¯åŠ¨å¼•å¯¼ç¨‹åº)
# èŒè´£: è®¾ç½®ç¯å¢ƒåº“(LD_LIBRARY_PATH)å¹¶å¯åŠ¨ DST äºŒè¿›åˆ¶æ–‡ä»¶
# =========================================================

# --- 1. å®šä½é…ç½® ---
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
CONFIG_FILE="$PROJECT_ROOT/conf/settings.ini"

# --- 2. ç®€æ˜“é…ç½®è¯»å–å™¨ ---
read_config() {
    local section=$1
    local key=$2
    local val=$(awk -F ' = ' -v section="[$section]" -v key="$key" '
        $0 == section { in_section=1; next }
        /^\[/ { in_section=0 }
        in_section && $1 == key { print $2; exit }
    ' "$CONFIG_FILE")
    echo "${val/\~/$HOME}"
}

# --- 3. åŠ è½½æ ¸å¿ƒå˜é‡ ---
INSTALL_DIR=$(read_config "PATHS" "DST_ROOT")
CLUSTER_NAME=$(read_config "SERVER" "CLUSTER_NAME")

# --- 4. ç¯å¢ƒæ£€æŸ¥ ---
if [ -z "$INSTALL_DIR" ] || [ -z "$CLUSTER_NAME" ]; then
    echo "âŒ [Boot] é”™è¯¯: æ— æ³•è¯»å–é…ç½®ï¼Œè¯·æ£€æŸ¥ conf/settings.ini"
    exit 1
fi

BIN_DIR="$INSTALL_DIR/bin"

# --- 5. è®¾ç½®ä¾èµ–åº“ (å…³é”®æ­¥éª¤) ---
# è¿™æ˜¯è®© Linux èƒ½è¿è¡Œ DST çš„æ ¸å¿ƒé­”æ³•
export LD_LIBRARY_PATH="$BIN_DIR/lib32:$BIN_DIR:$LD_LIBRARY_PATH"

# --- 6. è¿›å…¥æ‰§è¡Œç›®å½• ---
# å¿…é¡»è¿›å…¥ bin ç›®å½•ï¼Œå¦åˆ™æ¸¸æˆæ‰¾ä¸åˆ° data
cd "$BIN_DIR" || { echo "âŒ [Boot] æ‰¾ä¸åˆ°ç›®å½•: $BIN_DIR"; exit 1; }

echo "âš¡ [Boot] æ­£åœ¨åˆå§‹åŒ– Wagstaff å¼•æ“..."
echo "   - æ¸¸æˆæ ¹ç›®å½•: $INSTALL_DIR"
echo "   - å­˜æ¡£ç°‡åç§°: $CLUSTER_NAME"

# --- 7. å¯åŠ¨è¿›ç¨‹ (Master) ---
# ä½¿ç”¨ -dmS è®©å®ƒåœ¨åå° Screen è¿è¡Œ
screen -dmS "DST_Master" ./dontstarve_dedicated_server_nullrenderer -console -cluster "$CLUSTER_NAME" -shard Master
echo "âœ… [Boot] åœ°é¢æœåŠ¡å™¨ (Master) å·²å¯åŠ¨"

# --- 8. å¯åŠ¨è¿›ç¨‹ (Caves) ---
# åªæœ‰å½“å­˜æ¡£ä¸­å­˜åœ¨ Caves æ–‡ä»¶å¤¹æ—¶æ‰å¯åŠ¨ï¼Œæˆ–è€…ä½ å¯ä»¥é€‰æ‹©å¼ºåˆ¶å¯åŠ¨
# è¿™é‡Œä¸ºäº†ç¨³å¦¥ï¼Œæˆ‘ä»¬ç›´æ¥å¯åŠ¨ï¼Œå¦‚æœæ²¡æ´ç©´é…ç½®æ¸¸æˆä¼šè‡ªåŠ¨åœæ­¢ Caves è¿›ç¨‹ï¼Œæ— ä¼¤å¤§é›…
screen -dmS "DST_Caves" ./dontstarve_dedicated_server_nullrenderer -console -cluster "$CLUSTER_NAME" -shard Caves
echo "âœ… [Boot] æ´ç©´æœåŠ¡å™¨ (Caves) å·²å¯åŠ¨"

echo "âœ¨ å¯åŠ¨åºåˆ—å®Œæˆã€‚"

```

### File: bin/dst_tool.sh
```sh
#!/bin/bash

# =========================================================
# Wagstaff-Lab Control Center v6.1
# æ¨¡å—åŒ– DST æœåŠ¡å™¨ç®¡ç†è„šæœ¬
# =========================================================

# --- 1. ç¯å¢ƒåˆå§‹åŒ– ---

# è·å–è„šæœ¬æ‰€åœ¨ç›®å½•çš„ç»å¯¹è·¯å¾„ (bin/)
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
# å®šä½é¡¹ç›®æ ¹ç›®å½• (Wagstaff-Lab/)
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
# é…ç½®æ–‡ä»¶è·¯å¾„
CONFIG_FILE="$PROJECT_ROOT/conf/settings.ini"

# --- 2. é…ç½®è¯»å–å‡½æ•° (INI Parser) ---
# ç”¨é€”ï¼šä» settings.ini è¯»å–å˜é‡ï¼Œå¹¶è‡ªåŠ¨å°† ~ æ›¿æ¢ä¸º $HOME
read_config() {
    local section=$1
    local key=$2
    local val=$(awk -F ' = ' -v section="[$section]" -v key="$key" '
        $0 == section { in_section=1; next }
        /^\[/ { in_section=0 }
        in_section && $1 == key { print $2; exit }
    ' "$CONFIG_FILE")
    
    # æ›¿æ¢ ~ ä¸ºå½“å‰ç”¨æˆ· Home ç›®å½•
    echo "${val/\~/$HOME}"
}

# --- 3. åŠ è½½å˜é‡ ---
if [ ! -f "$CONFIG_FILE" ]; then
    echo "âŒ é”™è¯¯: æ‰¾ä¸åˆ°é…ç½®æ–‡ä»¶ $CONFIG_FILE"
    exit 1
fi

DST_DIR=$(read_config "PATHS" "DST_ROOT")
STEAMCMD_DIR=$(read_config "PATHS" "STEAMCMD_DIR")
BACKUP_REPO=$(read_config "PATHS" "BACKUP_DIR")
CLUSTER_NAME=$(read_config "SERVER" "CLUSTER_NAME")
KLEI_HOME=$(read_config "SERVER" "KLEI_HOME")

# [å…³é”®ä¿®æ”¹] å¯åŠ¨è„šæœ¬æŒ‡å‘åŒç›®å½•ä¸‹çš„ boot.sh
START_SCRIPT="$SCRIPT_DIR/boot.sh"

# æ—¥å¿—è·¯å¾„
LOG_MASTER="$KLEI_HOME/$CLUSTER_NAME/Master/server_log.txt"
LOG_CAVES="$KLEI_HOME/$CLUSTER_NAME/Caves/server_log.txt"

# å¯»æ‰¾ Conda Python ç¯å¢ƒ (ä¼˜å…ˆæ‰¾ dst_lab)
PYTHON_EXEC="$HOME/miniconda3/envs/dst_lab/bin/python"
if [ ! -f "$PYTHON_EXEC" ]; then
    # å¤‡ç”¨ï¼šå°è¯•ç³»ç»Ÿ python3
    PYTHON_EXEC=$(which python3)
fi

# ç¡®ä¿å¤‡ä»½ç›®å½•å­˜åœ¨
mkdir -p "$BACKUP_REPO"

# --- é¢œè‰²å®šä¹‰ ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
NC='\033[0m' # No Color

trap 'echo -e "\n${YELLOW}>> è¿”å›ä¸»èœå•...${NC}"; sleep 0.5' SIGINT

# ================= è¾…åŠ©å‡½æ•° =================

print_line() { echo -e "${CYAN}----------------------------------------${NC}"; }
pause() { echo -e "\n${WHITE}æŒ‰å›è½¦é”®ç»§ç»­...${NC}"; read -r; }

check_status() {
    local master_status="${RED}ğŸ”´ æœªè¿è¡Œ${NC}"
    local caves_status="${RED}ğŸ”´ æœªè¿è¡Œ${NC}"
    if screen -ls | grep -q "DST_Master"; then master_status="${GREEN}ğŸŸ¢ è¿è¡Œä¸­${NC}"; fi
    if screen -ls | grep -q "DST_Caves"; then caves_status="${GREEN}ğŸŸ¢ è¿è¡Œä¸­${NC}"; fi
    echo -e "   åœ°é¢: $master_status    æ´ç©´: $caves_status"
}

# æŸ¥çœ‹æ—¥å¿—å‡½æ•°
view_log() {
    local logfile="$1"; local name="$2"
    if [ -f "$logfile" ]; then
        echo -e "${CYAN}ğŸ“º ç›‘è§† $name æ—¥å¿— (Ctrl+C é€€å‡º)${NC}"
        tail -f "$logfile"
    else
        echo -e "${RED}âŒ æ— æ—¥å¿—æ–‡ä»¶: $logfile${NC}"; pause
    fi
}

# å‘é€æŒ‡ä»¤çš„æ ¸å¿ƒå‡½æ•°
send_cmd_to_master() {
    local cmd="$1"
    local desc="$2"
    if ! screen -ls | grep -q "DST_Master"; then
        echo -e "${RED}âŒ åœ°é¢æœæœªè¿è¡Œ${NC}"; pause; return
    fi
    echo -e "${BLUE}ğŸ“¡ $desc${NC}"
    screen -S "DST_Master" -p 0 -X eval "stuff \"$cmd\015\""
    echo -e "${YELLOW}â³ æŒ‡ä»¤å·²å‘é€${NC}"; sleep 1
}

# ================= æ ¸å¿ƒåŠŸèƒ½æ¨¡å— =================

start_server() {
    print_line
    if screen -ls | grep -q "DST_Master"; then
        echo -e "${YELLOW}âš ï¸  æœåŠ¡å™¨å·²åœ¨è¿è¡Œï¼${NC}"; pause; return
    fi
    echo -e "${GREEN}ğŸš€ è°ƒç”¨å¯åŠ¨å¼•å¯¼ç¨‹åº (Bootloader)...${NC}"
    
    # æ£€æŸ¥å¯åŠ¨è„šæœ¬æ˜¯å¦å­˜åœ¨
    if [ -f "$START_SCRIPT" ]; then
        # æ‰§è¡Œ boot.sh
        "$START_SCRIPT"
    else
        echo -e "${RED}âŒ æ‰¾ä¸åˆ°å¯åŠ¨å™¨: $START_SCRIPT${NC}"
        echo "è¯·æ£€æŸ¥ bin/boot.sh æ˜¯å¦å­˜åœ¨ã€‚"
    fi
    pause
}

graceful_stop() {
    print_line
    echo -e "${YELLOW}ğŸ›‘ å‘é€åœæœä¿¡å·...${NC}"
    if ! screen -ls | grep -qE "DST_Master|DST_Caves"; then
        echo -e "${RED}âš ï¸  æœåŠ¡å™¨æœªè¿è¡Œ${NC}"; pause; return
    fi

    # å‘é€å…³é—­æŒ‡ä»¤
    for target in "DST_Master" "DST_Caves"; do
        if screen -list | grep -q "$target"; then
            screen -S "$target" -p 0 -X eval 'stuff "c_shutdown(true)\015"'
        fi
    done

    echo -e "${BLUE}â³ ç­‰å¾…å­˜æ¡£ä¿å­˜ (æœ€å¤š40ç§’)...${NC}"
    for ((i=1; i<=40; i++)); do
        if ! screen -list | grep -qE "DST_Master|DST_Caves"; then
            echo -e "\n${GREEN}âœ… æœåŠ¡å™¨å·²å…³é—­${NC}"; pause; return
        fi
        if tail -n 10 "$LOG_MASTER" 2>/dev/null | grep -q "Shutting down"; then
            echo -e "\n${GREEN}âœ… ç›‘æµ‹åˆ°å…³æœºä¿¡å·${NC}"; break
        fi
        echo -n "."; sleep 0.5
    done
    
    # æ¸…ç†æ®‹ä½™è¿›ç¨‹
    screen -list | grep -E "DST_Master|DST_Caves" | cut -d. -f1 | xargs -r -I{} screen -S {} -X quit
    echo -e "\n${GREEN}âœ… è¿›ç¨‹å·²ç»ˆæ­¢${NC}"; pause
}

restart_server() {
    print_line
    if screen -ls | grep -qE "DST_Master|DST_Caves"; then
        eval "original_pause_def=$(declare -f pause)"; pause() { :; } 
        graceful_stop
        eval "$original_pause_def"
    fi
    read -p "æ˜¯å¦é¡ºä¾¿æ›´æ–°æ¸¸æˆ? (y/n): " up_c
    if [[ "$up_c" == "y" ]]; then update_game; fi
    start_server
}

update_game() {
    print_line
    echo -e "${BLUE}â¬‡ï¸  è°ƒç”¨ SteamCMD æ›´æ–°...${NC}"
    "$STEAMCMD_DIR/steamcmd.sh" +force_install_dir "$DST_DIR" +login anonymous +app_update 343050 validate +quit
    echo -e "${GREEN}âœ… æ›´æ–°å®Œæˆ${NC}"; pause
}

# --- å¤‡ä»½/æ¢å¤ç³»ç»Ÿ ---
create_backup() {
    print_line
    local ts=$(date +"%Y%m%d_%H%M%S")
    if [ ! -d "$KLEI_HOME/$CLUSTER_NAME" ]; then echo -e "${RED}âŒ å­˜æ¡£ä¸å­˜åœ¨: $KLEI_HOME/$CLUSTER_NAME${NC}"; pause; return; fi
    
    echo -e "${CYAN}ğŸ’¾ æ‰“åŒ…å­˜æ¡£: $CLUSTER_NAME ...${NC}"
    tar -zcf "$BACKUP_REPO/backup_${ts}.tar.gz" -C "$KLEI_HOME" "$CLUSTER_NAME"
    echo -e "${GREEN}âœ… å¤‡ä»½å·²åˆ›å»º: backup_${ts}.tar.gz${NC}"; pause
}

restore_backup() {
    print_line
    files=($(ls -1t "$BACKUP_REPO"/*.tar.gz 2>/dev/null))
    if [ ${#files[@]} -eq 0 ]; then echo -e "${RED}âŒ å¤‡ä»½åº“ä¸ºç©º${NC}"; pause; return; fi

    echo -e "${CYAN}ğŸ“‚ æœ€è¿‘å¤‡ä»½:${NC}"
    i=0
    for file in "${files[@]}"; do
        echo -e " [$i] $(basename "$file")"
        ((i++)); if [ $i -ge 10 ]; then break; fi
    done
    
    read -p "é€‰æ‹©åºå· (qé€€å‡º): " c
    if [[ "$c" == "q" ]]; then return; fi
    if ! [[ "$c" =~ ^[0-9]+$ ]] || [ "$c" -ge "$i" ]; then echo "âŒ æ— æ•ˆ"; pause; return; fi

    read -p "âš ï¸  é«˜å±æ“ä½œ: ç¡®è®¤è¦†ç›–å½“å‰å­˜æ¡£? (YES/n): " confirm
    if [[ "$confirm" != "YES" ]]; then return; fi

    # è‡ªåŠ¨åœæœ
    if screen -ls | grep -qE "DST_Master|DST_Caves"; then
        eval "original_pause_def=$(declare -f pause)"; pause() { :; } 
        graceful_stop
        eval "$original_pause_def"
    fi

    echo -e "${YELLOW}ğŸ§¹ æ¸…ç†æ—§å­˜æ¡£...${NC}"
    rm -rf "$KLEI_HOME/$CLUSTER_NAME"
    echo -e "${BLUE}ğŸ“¦ è§£å‹å¤‡ä»½...${NC}"
    tar -zxf "${files[$c]}" -C "$KLEI_HOME"
    echo -e "${GREEN}âœ… å›æ¡£æˆåŠŸ${NC}"
    read -p "ç«‹å³å¯åŠ¨? (y/n): " sn
    if [[ "$sn" == "y" ]]; then start_server; else pause; fi
}

# --- Wagstaff å·¥å…·ç®±é›†æˆ ---
run_explorer() {
    local script_path="$PROJECT_ROOT/src/explorer.py"
    if [ -f "$script_path" ]; then
        "$PYTHON_EXEC" "$script_path"
    else
        echo -e "${RED}âŒ æ‰¾ä¸åˆ°å·¥å…·è„šæœ¬: $script_path${NC}"
        pause
    fi
}

run_wiki() {
    local script_path="$PROJECT_ROOT/src/wiki.py"
    if [ ! -f "$script_path" ]; then
        echo -e "${RED}âŒ æ‰¾ä¸åˆ° Wiki è„šæœ¬: $script_path${NC}"; pause; return
    fi

    echo -e "${CYAN}ğŸ“š è¯·è¾“å…¥ç‰©å“ä»£ç è¿›è¡ŒæŸ¥è¯¢ (ä¾‹å¦‚ spear, log, meat)${NC}"
    read -p "ç‰©å“ä»£ç : " item_code
    if [ -n "$item_code" ]; then
        "$PYTHON_EXEC" "$script_path" "$item_code"
    fi
    pause
}
console_menu() {
    while true; do
        clear
        echo -e "   ğŸ® ${CYAN}æ§åˆ¶å°æŒ‡ä»¤ä¸­å¿ƒ${NC} ğŸ®"
        check_status
        echo "--------------------------------"
        echo "1. ğŸ’¾ ç«‹å³ä¿å­˜ (c_save)"
        echo "2. âª å›æ»š1å¤© (c_rollback)"
        echo "3. ğŸ“¢ å‘é€å…¬å‘Š (c_announce)"
        echo "4. â˜ ï¸  é‡ç½®ä¸–ç•Œ (c_regenerateworld)"
        echo "5. ğŸ‘¥ åˆ—å‡ºç©å®¶"
        echo "0. ğŸ”™ è¿”å›"
        echo "--------------------------------"
        read -p "æŒ‡ä»¤: " cc
        case $cc in
            1) send_cmd_to_master "c_save()" "ç«‹å³ä¿å­˜" ;;
            2) send_cmd_to_master "c_rollback(1)" "å›æ»š1å¤©" ;;
            3) read -p "å†…å®¹: " m; send_cmd_to_master "c_announce(\"$m\")" "å…¬å‘Š" ;;
            4) read -p "è¾“å…¥ YES ç¡®è®¤é‡ç½®: " r; [[ "$r" == "YES" ]] && send_cmd_to_master "c_regenerateworld()" "é‡ç½®ä¸–ç•Œ" ;;
            5) send_cmd_to_master "c_listallplayers()" "ç©å®¶åˆ—è¡¨" ;;
            0) return ;;
        esac
    done
}

# ================= ä¸»å¾ªç¯ =================
while true; do
    clear
    echo "==========================================="
    echo -e " ğŸ¦… ${CYAN}Wagstaff-Lab æ§åˆ¶å° v6.1${NC} ğŸ¦…"
    echo "==========================================="
    check_status
    echo -e "${CYAN}--- è¿ç»´ç®¡ç† ---${NC}"
    echo "1. ğŸš€ å¯åŠ¨æœåŠ¡å™¨      2. ğŸ›‘ åœæ­¢æœåŠ¡å™¨"
    echo "3. ğŸ”„ é‡å¯æœåŠ¡å™¨      4. â¬‡ï¸  æ›´æ–°ç‰ˆæœ¬"
    echo -e "${CYAN}--- æ•°æ®ä¸å·¥å…· ---${NC}"
    echo "5. ğŸ’¾ åˆ›å»ºå¤‡ä»½        6. âª æ¢å¤å­˜æ¡£"
    echo "7. ğŸ“œ æŸ¥çœ‹æ—¥å¿—        8. ğŸ® å‘é€æŒ‡ä»¤"
    echo -e "9. ğŸ”¬ ${YELLOW}æºç é€è§†é•œ (Explorer)${NC}"
    echo -e "10.ğŸ“š ${GREEN}Wagstaff ç™¾ç§‘ (Wiki)${NC}"
    echo "0. ğŸšª é€€å‡º"
    echo "==========================================="
    
    read -p "é€‰é¡¹: " choice

    case $choice in
        1) start_server ;;
        2) graceful_stop ;;
        3) restart_server ;;
        4) update_game ;;
        5) create_backup ;;
        6) restore_backup ;;
        7) view_log "$LOG_MASTER" "Master" ;; 
        8) console_menu ;;
        9) run_explorer ;; 
	10) run_wiki ;;
        0) echo -e "${GREEN}å†è§ï¼Œç ”ç©¶å‘˜ã€‚${NC}"; exit 0 ;;
        *) echo "æ— æ•ˆ"; sleep 0.5 ;;
    esac
done

```

### File: src/analyzer.py
```py
#!/usr/bin/env python3
import re

# ==========================================
# 1. å…¨å±€æ•°å€¼è§£æå™¨ (TuningResolver)
# ==========================================
class TuningResolver:
    def __init__(self, content):
        self.raw_map = {}
        if content:
            self._parse_tuning(content)

    def _parse_tuning(self, content):
        clean_content = re.sub(r'\blocal\s+', '', content)
        pattern = re.compile(r'([a-zA-Z0-9_]+)\s*=\s*([^,\r\n]+)')
        for name, raw_val in pattern.findall(clean_content):
            clean_val = raw_val.split('--')[0].strip()
            try:
                self.raw_map[name] = float(clean_val)
            except ValueError:
                self.raw_map[name] = clean_val

    def _trace_value(self, start_key):
        path = []
        current_key = start_key
        visited = set()
        for _ in range(5):
            if current_key in visited: break
            visited.add(current_key)
            val = self.raw_map.get(current_key)
            if val is None: break
            if isinstance(val, float):
                path.append(f"[bold cyan]{val}[/bold cyan]")
                break
            if isinstance(val, str):
                if val in self.raw_map:
                    path.append(f"[yellow]{val}[/yellow]")
                    current_key = val
                else:
                    path.append(f"[white]{val}[/white]")
                    break
        if not path: return None
        return " âœ ".join(path)

    def enrich(self, text):
        if not text or "TUNING." not in text: return text
        def replace_match(match):
            full_key = match.group(1)
            short_key = full_key.replace("TUNING.", "")
            trace_str = self._trace_value(short_key)
            if trace_str:
                return f"{full_key} [dim]({trace_str})[/dim]"
            return full_key
        return re.sub(r'(TUNING\.[A-Z0-9_]+)', replace_match, text)

# ==========================================
# 2. Lua æ–‡ä»¶åˆ†æå™¨ (LuaAnalyzer)
# ==========================================
class LuaAnalyzer:
    def __init__(self, content):
        self.content = content
        self.structure = {
            "assets": [], "components": [], "helpers": [],
            "stategraph": None, "brain": None, "events": [], "tags": []
        }
        self.parse()

    def parse(self):
        self._extract_tables()
        self._extract_components_robust()
        self._extract_standard_helpers()
        self._extract_logic()

    def _clean_value(self, raw_val):
        val = re.sub(r'--.*', '', raw_val)
        return " ".join(val.split())

    def _extract_tables(self):
        asset_pattern = re.compile(r'Asset\s*\(\s*["\'](.*?)["\']\s*,\s*["\'](.*?)["\']\s*\)')
        for match in asset_pattern.findall(self.content):
            self.structure["assets"].append({"type": match[0], "path": match[1]})

    def _extract_standard_helpers(self):
        helper_pattern = re.compile(r'^\s*(Make[a-zA-Z0-9_]+)\s*\(', re.MULTILINE)
        found = set()
        for match in helper_pattern.findall(self.content):
            if match not in found:
                self.structure["helpers"].append(match)
                found.add(match)

    def _extract_components_robust(self):
        added_comps = set()
        add_pattern = re.compile(r'inst:AddComponent\s*\(\s*["\'](.*?)["\']\s*\)')
        for match in add_pattern.findall(self.content):
            added_comps.add(match)
        for comp_name in added_comps:
            comp_data = {"name": comp_name, "methods": [], "properties": []}
            method_pattern = re.compile(r'components\.' + re.escape(comp_name) + r'[:\.]([a-zA-Z0-9_]+)\s*\((.*?)\)', re.DOTALL)
            for m in method_pattern.findall(self.content):
                func_name = m[0]
                clean_args = self._clean_value(m[1])
                if len(clean_args) > 50: clean_args = clean_args[:47] + "..."
                comp_data["methods"].append(f"{func_name}({clean_args})")
            prop_pattern = re.compile(r'components\.' + re.escape(comp_name) + r'\.([a-zA-Z0-9_]+)\s*=\s*(.+)')
            for p in prop_pattern.findall(self.content):
                prop_name = p[0]
                raw_val = p[1].strip()
                if raw_val.startswith("function"):
                    comp_data["properties"].append(f"{prop_name} = [Function]")
                    continue
                clean_val = self._clean_value(raw_val)
                comp_data["properties"].append(f"{prop_name} = {clean_val}")
            self.structure["components"].append(comp_data)

    def _extract_logic(self):
        brain = re.search(r'inst:SetBrain\s*\(\s*require\s*\(\s*["\'](.*?)["\']\s*\)\s*\)', self.content)
        if brain: self.structure["brain"] = brain.group(1)
        sg = re.search(r'inst:SetStateGraph\s*\(\s*["\'](.*?)["\']\s*\)', self.content)
        if sg: self.structure["stategraph"] = sg.group(1)
        tags = re.findall(r'[^--]inst:AddTag\s*\(\s*["\'](.*?)["\']\s*\)', self.content)
        self.structure["tags"] = list(set(tags))
        events = re.findall(r'inst:ListenForEvent\s*\(\s*["\'](.*?)["\']', self.content)
        self.structure["events"] = list(set(events))

    def get_report(self):
        return self.structure

# ==========================================
# 3. é…æ–¹è§£æå™¨ (RecipeAnalyzer) - [FINAL]
# ==========================================
class RecipeAnalyzer:
    def __init__(self, content):
        self.raw_content = content
        self.recipes = {}
        self.aliases = {}
        if content:
            self._parse()

    def _clean_comments(self):
        return re.sub(r'--.*$', '', self.raw_content, flags=re.MULTILINE)

    def _extract_table_block(self, content, start_index):
        # å †æ ˆå¼æå– {...}
        start_brace = content.find('{', start_index)
        if start_brace == -1: return None, start_index

        balance = 1
        for i in range(start_brace + 1, len(content)):
            char = content[i]
            if char == '{':
                balance += 1
            elif char == '}':
                balance -= 1
            if balance == 0:
                return content[start_brace+1 : i], i + 1
        return None, start_index

    def _parse(self):
        clean_content = self._clean_comments()
        
        # [æ ¸å¿ƒä¿®å¤]
        # 1. \bRecipe: ç¡®ä¿åŒ¹é…å•è¯å¼€å¤´ï¼Œæ’é™¤ DeconstructRecipe
        # 2. 2?: å…¼å®¹ Recipe å’Œ Recipe2
        # 3. \(: ç¡®ä¿æ˜¯å‡½æ•°è°ƒç”¨
        iter_pattern = re.compile(r'\bRecipe2?\s*\(\s*["\'](.*?)["\']', re.DOTALL)
        
        for match in iter_pattern.finditer(clean_content):
            name = match.group(1)
            cursor = match.end()
            
            # æå–æˆåˆ†è¡¨
            ing_block, new_cursor = self._extract_table_block(clean_content, cursor)
            
            if ing_block:
                ingredients = []
                # è§£æ Ingredient
                ing_pattern = re.compile(r'Ingredient\s*\(\s*["\'](.*?)["\']\s*,\s*([^,\)]+)')
                for item, amount in ing_pattern.findall(ing_block):
                    ingredients.append({"item": item, "amount": amount.strip()})
                
                # å°è¯•æå–åç»­å‚æ•° (Tab, Tech)
                remainder = clean_content[new_cursor:].split(')')[0]
                parts = [p.strip() for p in remainder.split(',') if p.strip()]
                
                # Recipe å’Œ Recipe2 çš„å‚æ•°ä½ç½®ç•¥æœ‰ä¸åŒï¼Œä½†é€šå¸¸ Tab å’Œ Tech éƒ½åœ¨å‰é¢
                # è¿™é‡Œåšä¸ªç®€å•çš„é˜²å¾¡å¼æå–
                tab = "UNKNOWN"
                tech = "UNKNOWN"
                
                for p in parts:
                    if "TECH." in p: tech = p
                    if "RECIPETABS." in p: tab = p

                self.recipes[name] = {
                    "ingredients": ingredients,
                    "tab": tab,
                    "tech": tech
                }
                
                # å»ºç«‹ç´¢å¼•
                self.aliases[name.lower()] = name
                self.aliases[name.replace("_", "").lower()] = name

    def get(self, query_name):
        q = query_name.lower()
        real_name = self.aliases.get(q)
        if not real_name:
            real_name = self.aliases.get(q.replace("_", ""))
        
        if real_name:
            return real_name, self.recipes[real_name]
        return None, None
```

### File: src/engine.py
```py
#!/usr/bin/env python3
import os
import zipfile
from rich.console import Console
from utils import wagstaff_config
from analyzer import TuningResolver, RecipeAnalyzer, LuaAnalyzer

console = Console()

class WagstaffEngine:
    """
    Wagstaff Lab æ ¸å¿ƒå¼•æ“ (v1.0)
    èŒè´£: ç»Ÿä¸€ç®¡ç†æ•°æ®æº (Zip/Folder) å’Œ æ ¸å¿ƒçŸ¥è¯†åº“ (Tuning/Recipes)
    """
    def __init__(self, load_db=True, silent=False):
        self.base_dir = wagstaff_config.get('PATHS', 'DST_ROOT')
        self.zip_path = os.path.join(self.base_dir, "data", "databundles", "scripts.zip")
        self.fallback_dir = os.path.join(self.base_dir, "data", "scripts")
        
        self.mode = None
        self.source = None
        self.file_list = []
        
        self.tuning = None
        self.recipes = None
        
        self._init_source(silent)
        if load_db:
            self._init_databases(silent)

    def _init_source(self, silent):
        if os.path.exists(self.zip_path):
            self.mode = 'zip'
            self.source = zipfile.ZipFile(self.zip_path, 'r')
            self.file_list = self.source.namelist()
            if not silent: console.print(f"[dim]ğŸ“¦ å¼•æ“æŒ‚è½½ Zip æº: {self.zip_path}[/dim]")
        elif os.path.exists(self.fallback_dir):
            self.mode = 'folder'
            self.source = self.fallback_dir
            for root, _, files in os.walk(self.fallback_dir):
                for name in files:
                    rel = os.path.relpath(os.path.join(root, name), self.fallback_dir).replace("\\", "/")
                    self.file_list.append(rel)
            if not silent: console.print(f"[dim]ğŸ“‚ å¼•æ“æŒ‚è½½æ–‡ä»¶å¤¹æº: {self.fallback_dir}[/dim]")
        else:
            raise FileNotFoundError("æ— æ³•æ‰¾åˆ° scripts.zip æˆ– scripts/ ç›®å½•")

    def _init_databases(self, silent):
        if not silent: console.print("[dim]ğŸ”„ åŠ è½½ç¥ç»ä¸­æ¢ (Tuning & Recipes)...[/dim]")
        t_content = self.read_file("scripts/tuning.lua") or self.read_file("tuning.lua")
        self.tuning = TuningResolver(t_content if t_content else "")
        r_content = self.read_file("scripts/recipes.lua") or self.read_file("recipes.lua")
        self.recipes = RecipeAnalyzer(r_content if r_content else "")

    def read_file(self, path):
        """æ™ºèƒ½è¯»å–æ–‡ä»¶ï¼ˆè‡ªåŠ¨å¤„ç† scripts/ å‰ç¼€ï¼‰"""
        candidates = [path]
        if not path.startswith("scripts/"): candidates.append(f"scripts/{path}")
        else: candidates.append(path.replace("scripts/", ""))
        
        try:
            if self.mode == 'zip':
                for p in candidates:
                    if p in self.file_list:
                        return self.source.read(p).decode('utf-8', errors='replace')
            else:
                for p in candidates:
                    real_path = os.path.join(self.source, p.replace("scripts/", ""))
                    if os.path.exists(real_path):
                        with open(real_path, 'r', encoding='utf-8', errors='replace') as f: return f.read()
        except Exception:
            return None
        return None

    def find_file(self, name, fuzzy=True):
        """æ¨¡ç³ŠæŸ¥æ‰¾æ–‡ä»¶ (å¦‚ armorwood -> scripts/prefabs/armor_wood.lua)"""
        candidates = [f"scripts/prefabs/{name}.lua", f"prefabs/{name}.lua", f"scripts/{name}", name]
        for c in candidates:
            if c in self.file_list: return c
            
        if not fuzzy: return None

        target = name.replace("_", "").lower()
        for fname in self.file_list:
            if not fname.endswith(".lua"): continue
            base = os.path.basename(fname).replace(".lua", "")
            if base.replace("_", "").lower() == target:
                return fname
        return None

    def analyze_prefab(self, item_name):
        """ä¸€é”®åˆ†æ Prefab (æ•´åˆäº† wiki.py çš„é€»è¾‘)"""
        path = self.find_file(item_name)
        if not path: return None
        
        content = self.read_file(path)
        if not content: return None
        
        analyzer = LuaAnalyzer(content)
        data = analyzer.get_report()
        
        if self.tuning:
            for comp in data.get('components', []):
                comp['properties'] = [self.tuning.enrich(p) for p in comp['properties']]
                comp['methods'] = [self.tuning.enrich(m) for m in comp['methods']]
        
        return data

```

### File: src/explorer.py
```py
#!/usr/bin/env python3
import os
import sys
from rich.console import Console
from rich.table import Table
from rich.tree import Tree
from rich.panel import Panel
from rich.prompt import Prompt, IntPrompt
from rich.syntax import Syntax
from rich import box
from engine import WagstaffEngine

console = Console()

class DSTExplorer:
    def __init__(self):
        # ç›´æ¥ä½¿ç”¨å¼•æ“ï¼Œä¸å†è‡ªå·±å¤„ç† Zip å’Œ Tuning
        try:
            self.engine = WagstaffEngine(load_db=True)
        except Exception as e:
            console.print(f"[red]å¼•æ“å¯åŠ¨å¤±è´¥: {e}[/red]")
            sys.exit(1)
        
        console.print(Panel(f"[bold cyan]Wagstaff æºç é€è§†é•œ v3.0[/bold cyan]\næ ¸å¿ƒ: {self.engine.mode.upper()} æ¨¡å¼", border_style="blue"))
        if self.engine.tuning:
            console.print(f"[dim]âš¡ Tuning è§£æå™¨å°±ç»ª (åŒ…å« {len(self.engine.tuning.raw_map)} æ¡å¸¸æ•°)[/dim]")

    def get_structure_tree(self):
        tree = Tree(f"ğŸ“ [bold yellow]æºç ç»“æ„[/bold yellow]")
        dir_counts = {}
        for f in self.engine.file_list:
            clean_path = f.replace("scripts/", "", 1) if f.startswith("scripts/") else f
            top_dir = clean_path.split('/')[0] if '/' in clean_path else "[Root Files]"
            dir_counts[top_dir] = dir_counts.get(top_dir, 0) + 1

        for d, count in sorted(dir_counts.items(), key=lambda x: x[1], reverse=True):
            if d == "[Root Files]":
                tree.add(f"ğŸ“„ {d} ({count})")
            else:
                style = "bold cyan" if d in ["prefabs", "components", "tuning.lua"] else "white"
                tree.add(f"ğŸ“‚ [{style}]{d}[/{style}] ([dim]{count}[/dim])")
        return tree

    def search_files(self):
        keyword = Prompt.ask("[bold green]ğŸ” æœç´¢å…³é”®è¯[/bold green]")
        if not keyword: return
        matches = [f for f in self.engine.file_list if keyword.lower() in f.lower()]
        
        if not matches:
            console.print("[yellow]æ— ç»“æœ[/yellow]")
            return

        table = Table(title=f"Results: '{keyword}'", box=box.SIMPLE)
        table.add_column("è·¯å¾„", style="dim")
        table.add_column("æ–‡ä»¶", style="bold green")
        for m in matches[:15]:
            d, f = os.path.split(m)
            table.add_row(d, f)
        console.print(table)
        if len(matches) > 15: console.print(f"[dim]...å‰©ä½™ {len(matches)-15} é¡¹éšè—[/dim]")

    def analyze_content(self, filename, content):
        # ä½¿ç”¨å¼•æ“æä¾›çš„åˆ†ææ–¹æ³• (å·²åŒ…å«æ•°å€¼å¢å¼º)
        # æ³¨æ„ï¼šengine.analyze_prefab æ˜¯é’ˆå¯¹ prefab çš„ï¼Œè¿™é‡Œæˆ‘ä»¬å¯èƒ½éœ€è¦é€šç”¨çš„ analyzer
        # ä¸ºäº†å¤ç”¨ engine çš„èƒ½åŠ›ï¼Œæˆ‘ä»¬æ‰‹åŠ¨è°ƒç”¨ analyzer ä½†ä½¿ç”¨ engine çš„ tuning
        from analyzer import LuaAnalyzer
        
        try:
            analyzer = LuaAnalyzer(content)
            data = analyzer.get_report()
        except Exception as e:
            console.print(f"[red]è§£æå¤±è´¥: {e}[/red]")
            return
        
        tree = Tree(f"ğŸ§¬ [bold green]æ·±åº¦è§£æ: {filename}[/bold green]")
        
        # 1. èµ„æº
        if data.get('assets'):
            asset_branch = tree.add(f"ğŸ“¦ èµ„æºå¼•ç”¨ ({len(data['assets'])})")
            for a in data['assets']:
                style = "magenta" if "Anim" in a['type'] else "blue"
                asset_branch.add(f"[{style}]{a['type']}[/{style}]: {a['path']}")

        # 2. é€»è¾‘ (Brain/StateGraph/Tags)
        logic_branch = tree.add("ğŸ§  æ ¸å¿ƒé€»è¾‘")
        has_logic = False
        if data.get('brain'): 
            logic_branch.add(f"AI: [magenta]{data['brain']}[/magenta]")
            has_logic = True
        if data.get('stategraph'): 
            logic_branch.add(f"SG: [magenta]{data['stategraph']}[/magenta]")
            has_logic = True
        if data.get('tags'): 
            tags = data['tags']
            tag_str = ", ".join([f"[dim]{t}[/dim]" for t in tags[:8]])
            if len(tags) > 8: tag_str += "..."
            logic_branch.add(f"Tags: {tag_str}")
            has_logic = True
        if not has_logic: logic_branch.label = "[dim]ğŸ§  æ ¸å¿ƒé€»è¾‘ (æ— )[/dim]"

        # 3. ç»„ä»¶ (ä½¿ç”¨ Engine çš„ Tuning è¿›è¡Œå¢å¼º)
        if data.get('components'):
            comp_branch = tree.add(f"âš™ï¸ åŠŸèƒ½ç»„ä»¶ ({len(data['components'])})")
            for comp in data['components']:
                node = comp_branch.add(f"[bold yellow]{comp['name']}[/bold yellow]")
                
                # å±æ€§
                if comp['properties']:
                    target = node if len(comp['properties']) <=3 else node.add("[dim]å±æ€§é…ç½®[/dim]")
                    for p in comp['properties']:
                        p = self.engine.tuning.enrich(p) if self.engine.tuning else p
                        if "=" in p:
                            k, v = p.split("=", 1)
                            target.add(f"[cyan]{k.strip()}[/cyan] = [white]{v.strip()}[/white]")
                        else:
                            target.add(f"[cyan]{p}[/cyan]")
                
                # æ–¹æ³•
                if comp['methods']:
                    target = node if len(comp['methods']) <=3 else node.add("[dim]å‡½æ•°è°ƒç”¨[/dim]")
                    for m in comp['methods']:
                        m = self.engine.tuning.enrich(m) if self.engine.tuning else m
                        target.add(f"[green]Æ’[/green] {m}")
        else:
            tree.add("[dim]âš™ï¸ åŠŸèƒ½ç»„ä»¶ (æ— )[/dim]")

        console.print(Panel(tree, border_style="green"))
        input("æŒ‰å›è½¦è¿”å›...")

    def preview_file(self):
        target = Prompt.ask("[bold green]ğŸ‘€ æ–‡ä»¶å[/bold green]")
        path = self.engine.find_file(target, fuzzy=True)
        if not path:
            console.print("[red]æœªæ‰¾åˆ°[/red]")
            return
        
        console.print(f"[yellow]æ‰“å¼€: {path}[/yellow]")
        content = self.engine.read_file(path)
        
        if content:
            syntax = Syntax("\n".join(content.splitlines()[:50]), "lua", theme="monokai", line_numbers=True)
            console.print(Panel(syntax, title=f"{path} (Top 50 lines)", border_style="blue"))
            
            action = Prompt.ask("[bold cyan]ä¸‹ä¸€æ­¥[/bold cyan]", choices=["q", "a"], default="q")
            if action == "a":
                self.analyze_content(path, content)

    def show_tuning(self):
        if not self.engine.tuning: 
            return console.print("[red]Tuning æœªåŠ è½½[/red]")
        
        console.print("[bold magenta]ğŸ”¢ Tuning æ•°å€¼é‡‡æ ·[/bold magenta]")
        # ç®€å•å±•ç¤ºå‰ 10 ä¸ª
        count = 0
        for k, v in list(self.engine.tuning.raw_map.items())[:10]:
             console.print(f"  [cyan]{k}[/cyan] = {v}")
             count += 1

def main():
    explorer = DSTExplorer()
    while True:
        console.print("\n[bold white on blue] ğŸ¦ Wagstaff æ¢ç´¢é¢æ¿ v3.0 [/bold white on blue]")
        console.print("1. [bold]ğŸ“ ç»“æ„[/]  2. [bold]ğŸ” æœç´¢[/]  3. [bold]ğŸ‘€ é¢„è§ˆ&åˆ†æ[/]  4. [bold]ğŸ”¢ æ•°å€¼[/]  0. [bold red]é€€å‡º[/]")
        choice = IntPrompt.ask("é€‰æ‹©", choices=["0","1","2","3","4"], default=1)
        if choice == 0: break
        elif choice == 1: console.print(explorer.get_structure_tree())
        elif choice == 2: explorer.search_files()
        elif choice == 3: explorer.preview_file()
        elif choice == 4: explorer.show_tuning()

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        console.print(f"[red]Error: {e}[/red]")

```

### File: src/guide.py
```py
#!/usr/bin/env python3
import os
import sys
import json
from rich.console import Console
from rich.panel import Panel
from rich.table import Table
from pathlib import Path

# å¼•å…¥é…ç½®å’Œæ³¨å†Œè¡¨
sys.path.append(os.path.dirname(os.path.abspath(__file__)))
from registry import get_tools

console = Console()
PROJECT_ROOT = Path(__file__).resolve().parent.parent

def load_status():
    status_path = PROJECT_ROOT / "PROJECT_STATUS.json"
    if status_path.exists():
        with open(status_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    return {}

def main():
    data = load_status()
    
    console.print(Panel("[bold white on blue] ğŸ§ª Wagstaff-Lab (v2.2) æ§åˆ¶å° [/bold white on blue]", border_style="blue"))
    
    if "objective" in data:
        console.print(f"[bold green]ğŸ¯ å½“å‰ç›®æ ‡:[/bold green] {data['objective']}")
    
    # å¢åŠ  Usage åˆ—çš„å±•ç¤º
    console.print("\n[bold yellow]ğŸ› ï¸  å·¥å…·ç®±ä½¿ç”¨æŒ‡å—[/bold yellow]")
    table = Table(box=None, show_header=True, header_style="bold cyan")
    table.add_column("å·¥å…·", style="bold")
    table.add_column("æè¿°")
    table.add_column("æ ‡å‡†ç”¨æ³• (Usage)", style="green")
    
    for tool in get_tools():
        table.add_row(
            tool['file'], 
            tool['desc'], 
            tool.get('usage', 'N/A')
        )

    console.print(table)
    console.print("\n[dim]ğŸ’¡ è¾“å…¥ [bold]pm ui[/bold] ç®¡ç†ä»»åŠ¡ï¼Œè¾“å…¥ [bold]wagstaff snap[/bold] æ›´æ–°å¿«ç…§ã€‚[/dim]")

if __name__ == "__main__":
    main()

```

### File: src/registry.py
```py
#!/usr/bin/env python3
"""
Wagstaff-Lab å·¥å…·æ³¨å†Œä¸­å¿ƒ (v2.2)
æ‰€æœ‰å·¥å…·çš„å…ƒæ•°æ®ã€å‘½ä»¤åˆ«ååŠç”¨æ³•è¯´æ˜å‡åœ¨æ­¤ç»Ÿä¸€ç»´æŠ¤ã€‚
"""

TOOLS = [
    # --- æ ¸å¿ƒ/ä¸šåŠ¡å·¥å…· (src/) ---
    {
        "file": "guide.py",
        "alias": None,
        "desc": "Wagstaff-Lab æ§åˆ¶å°ä¸»é¢æ¿",
        "usage": "Wagstaff-Lab",
        "type": "Core"
    },
    {
        "file": "wiki.py",
        "alias": "wiki",
        "desc": "ç‰©å“/é…æ–¹/æ•°å€¼æŸ¥è¯¢ç™¾ç§‘",
        "usage": "wagstaff wiki <item_code>",
        "type": "Src"
    },
    {
        "file": "explorer.py",
        "alias": "exp",
        "desc": "æºç ç»“æ„æµè§ˆä¸æ·±åº¦åˆ†æ",
        "usage": "wagstaff exp",
        "type": "Src"
    },

    # --- å¼€å‘å·¥å…· (devtools/) ---
    {
        "file": "pm.py",
        "alias": "pm",
        "desc": "é¡¹ç›®è¿›åº¦ä¸ä»»åŠ¡ç®¡ç†",
        "usage": "pm [ui|obj|add|done|log]",
        "type": "Dev",
        "folder": "devtools"
    },
    {
        "file": "reporter.py",
        "alias": "report",
        "desc": "ç”Ÿæˆå…¨æœèµ„äº§/é…æ–¹åˆ†å¸ƒæŠ¥å‘Š",
        "usage": "wagstaff report [assets|recipes|all]",
        "type": "Dev",
        "folder": "devtools"
    },
    {
        "file": "snapshot.py",
        "alias": "snap",
        "desc": "ç”Ÿæˆé¡¹ç›®å…¨æ¯ä»£ç å¿«ç…§",
        "usage": "wagstaff snap",
        "type": "Dev",
        "folder": "devtools"
    },
    {
        "file": "installer.py",
        "alias": "install",
        "desc": "ç¯å¢ƒæ³¨å†Œä¸å®‰è£…å‘å¯¼",
        "usage": "python3 devtools/installer.py",
        "type": "Dev",
        "folder": "devtools"
    },
]

def get_tools():
    return TOOLS

```

### File: src/utils.py
```py
import configparser
import os
from pathlib import Path

class ConfigLoader:
    def __init__(self):
        # è‡ªåŠ¨å®šä½é¡¹ç›®æ ¹ç›®å½• (å‡è®¾ utils.py åœ¨ src/ ä¸‹)
        self.project_root = Path(__file__).resolve().parent.parent
        self.config_path = self.project_root / "conf" / "settings.ini"
        
        self.config = configparser.ConfigParser()
        if not self.config_path.exists():
            raise FileNotFoundError(f"âŒ é…ç½®æ–‡ä»¶ä¸¢å¤±: {self.config_path}")
        
        self.config.read(self.config_path)

    def get(self, section, key):
        """è·å–é…ç½®å€¼å¹¶è‡ªåŠ¨å±•å¼€ç”¨æˆ·è·¯å¾„ (~)"""
        val = self.config.get(section, key, fallback=None)
        if val and "~" in val:
            return os.path.expanduser(val)
        return val

# å•ä¾‹æ¨¡å¼ï¼šç›´æ¥å¯¼å‡ºçš„å®ä¾‹
wagstaff_config = ConfigLoader()

# === æµ‹è¯•ä»£ç  ===
if __name__ == "__main__":
    print(f"Project Root: {wagstaff_config.project_root}")
    print(f"DST Path: {wagstaff_config.get('PATHS', 'DST_ROOT')}")

```

### File: src/wiki.py
```py
#!/usr/bin/env python3
import sys
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.text import Text
from rich import box
from engine import WagstaffEngine # ç›´æ¥è°ƒç”¨å¼•æ“

console = Console()

def main():
    if len(sys.argv) < 2:
        console.print("[yellow]ç”¨æ³•: python src/wiki.py <ç‰©å“ä»£ç >[/yellow]")
        return
    
    target = sys.argv[1].lower()
    
    # 1. å¯åŠ¨å¼•æ“
    try:
        engine = WagstaffEngine()
    except Exception as e:
        console.print(f"[red]å¼•æ“å¯åŠ¨å¤±è´¥: {e}[/red]")
        return

    # 2. æŸ¥é…æ–¹
    real_name, recipe_data = engine.recipes.get(target)
    if not real_name: real_name = target
    
    # 3. æŸ¥æ•°æ® (ä½¿ç”¨å¼•æ“å°è£…å¥½çš„æ–¹æ³•)
    prefab_data = engine.analyze_prefab(real_name)

    if not recipe_data and not prefab_data:
        console.print(f"[red]âŒ æœªæ‰¾åˆ° '{target}'[/red]")
        return

    # === æ¸²æŸ“å±‚ (ä¿æŒåŸæœ‰ç¾è§‚é€»è¾‘) ===
    console.print(Panel(f"[bold white on blue] ğŸ“š Wagstaff æ¡£æ¡ˆ: {real_name.upper()} [/bold white on blue]"))
    
    grid = Table.grid(expand=True, padding=(0, 2))
    grid.add_column(ratio=1)
    grid.add_column(ratio=2)

    # å·¦ï¼šé…æ–¹
    left_rows = []
    if recipe_data:
        t_name = recipe_data['tab'].replace("RECIPETABS.", "")
        rt = Table(title=f"ğŸ“œ åˆæˆ ({t_name})", border_style="green", box=box.SIMPLE)
        rt.add_column("ææ–™", style="cyan"); rt.add_column("æ•°é‡", style="magenta")
        for ing in recipe_data['ingredients']:
            rt.add_row(ing['item'], engine.tuning.enrich(ing['amount']))
        left_rows.append(rt)
        if recipe_data.get('tech'): 
            left_rows.append(f"\n[dim]ğŸ”¬ {recipe_data['tech'].replace('TECH.', '')}[/dim]")
    else:
        left_rows.append(Panel("[dim]ä¸å¯åˆæˆ[/dim]", border_style="dim"))

    # å³ï¼šç»„ä»¶
    right_rows = []
    if prefab_data:
        # Helpers
        if prefab_data.get('helpers'):
            tags = [f"[reverse cyan]{h.replace('Make','').replace('Inventory','')}[/reverse cyan]" for h in prefab_data['helpers']]
            right_rows.append(Text.from_markup(" ".join(tags) + "\n"))
        
        # Stats
        INTERESTING = ["weapon", "armor", "finiteuses", "edible", "tool", "fuel", "instrument"]
        st = Table(box=box.MINIMAL, show_header=False)
        st.add_column("C", style="dim"); st.add_column("V", style="white")
        
        has_stat = False
        for comp in prefab_data.get('components', []):
            if comp['name'] in INTERESTING:
                # æå–æ–¹æ³•è°ƒç”¨ä½œä¸ºå…³é”®æ•°æ®
                for m in comp['methods']:
                    if any(k in m for k in ["SetDamage", "SetAbsorption", "SetMaxUses", "GetHealth"]):
                        icon = "âš”ï¸" if comp['name']=="weapon" else "âš™ï¸"
                        st.add_row(f"{icon} {comp['name']}", m.split('(', 1)[1][:-1]) # ç®€ç•¥æ˜¾ç¤ºå‚æ•°
                        has_stat = True
                # æå–å±æ€§
                for p in comp['properties']:
                    if "fuelvalue" in p or "armor" in p:
                         st.add_row(f"âš™ï¸ {comp['name']}", p)
                         has_stat = True
        
        if has_stat: right_rows.append(st)
        else: right_rows.append("[dim]æ— æ ¸å¿ƒæˆ˜æ–—/ç”Ÿå­˜æ•°æ®[/dim]")
    else:
        right_rows.append("[red]âš ï¸ æ— æ³•è¯»å–æ–‡ä»¶[/red]")

    from rich.console import Group
    grid.add_row(Group(*left_rows), Group(*right_rows))
    console.print(grid)

if __name__ == "__main__":
    main()
```

### File: conf/settings.ini
```toml
[PATHS]
# æ¸¸æˆå®‰è£…ç›®å½•
DST_ROOT = ~/dontstarvetogether_dedicated_server
# SteamCMD ç›®å½•
STEAMCMD_DIR = ~/steamcmd
# å¤‡ä»½å­˜æ”¾ç›®å½•
BACKUP_DIR = ~/dst_backups

[SERVER]
# ä½ çš„å­˜æ¡£æ–‡ä»¶å¤¹å (Cluster Name)
CLUSTER_NAME = MyDediServer
# Klei å­˜æ¡£æ ¹ç›®å½• (é€šå¸¸æ˜¯ ~/.klei/DoNotStarveTogether)
KLEI_HOME = ~/.klei/DoNotStarveTogether

```

### File: devtools/installer.py
```py
#!/usr/bin/env python3
import os
import sys
from pathlib import Path
from rich.console import Console

# å¼•å…¥æ³¨å†Œè¡¨
sys.path.append(os.path.join(os.path.dirname(__file__), "../src"))
from registry import get_tools

console = Console()

CURRENT_FILE = Path(__file__).resolve()
PROJECT_ROOT = CURRENT_FILE.parent.parent
BIN_DIR = PROJECT_ROOT / "bin"
SRC_DIR = PROJECT_ROOT / "src"
DEV_DIR = PROJECT_ROOT / "devtools"

def get_shell_config():
    home = Path.home()
    shell = os.environ.get("SHELL", "")
    if "zsh" in shell: return home / ".zshrc"
    elif "bash" in shell: return home / ".bashrc"
    else: return home / ".profile"

def create_wrappers():
    # 1. åˆ›å»º 'Wagstaff-Lab' ä¸»å…¥å£
    main_wrapper = BIN_DIR / "Wagstaff-Lab"
    with open(main_wrapper, 'w') as f:
        f.write('#!/bin/bash\n')
        f.write(f'python3 "{SRC_DIR}/guide.py" "$@"\n')
    os.chmod(main_wrapper, 0o755)
    
    # 2. åˆ›å»º 'pm' å¿«æ·æŒ‡ä»¤
    pm_wrapper = BIN_DIR / "pm"
    with open(pm_wrapper, 'w') as f:
        f.write('#!/bin/bash\n')
        f.write(f'python3 "{DEV_DIR}/pm.py" "$@"\n')
    os.chmod(pm_wrapper, 0o755)

    # 3. åŠ¨æ€åˆ›å»º 'wagstaff' å·¥å…·ç®± (åŸºäº Registry)
    ws_wrapper = BIN_DIR / "wagstaff"
    with open(ws_wrapper, 'w') as f:
        f.write('#!/bin/bash\n')
        f.write('TOOL=$1\nshift\n')
        f.write('case "$TOOL" in\n')
        
        # --- åŠ¨æ€ç”Ÿæˆ Case åˆ†æ”¯ ---
        tools = get_tools()
        registered_aliases = []
        
        for tool in tools:
            alias = tool.get('alias')
            if not alias: continue # è·³è¿‡æ²¡æœ‰åˆ«åçš„å·¥å…·
            
            folder = tool.get('folder', 'src')
            # è½¬æ¢ folder ä¸ºç»å¯¹è·¯å¾„å˜é‡
            if folder == 'src': abs_path = SRC_DIR
            elif folder == 'devtools': abs_path = DEV_DIR
            else: abs_path = PROJECT_ROOT / folder
            
            f.write(f'  {alias}) python3 "{abs_path}/{tool["file"]}" "$@" ;;\n')
            registered_aliases.append(f"{alias} ({tool['desc']})")
        # ------------------------

        f.write(f'  *) "{main_wrapper}" "$@" ;;\n') 
        f.write('esac\n')
    os.chmod(ws_wrapper, 0o755)
    
    console.print(f"[green]âœ… æŒ‡ä»¤æ³¨å†ŒæˆåŠŸ (Registry Driven)[/green]")
    console.print(f"   å·²è‡ªåŠ¨æ³¨å†Œ {len(registered_aliases)} ä¸ªå­å‘½ä»¤åˆ° 'wagstaff'")

def register_to_path():
    rc_file = get_shell_config()
    bin_path_str = str(BIN_DIR)
    
    if not rc_file.exists(): return

    content = rc_file.read_text()
    if f'export PATH="{bin_path_str}:$PATH"' in content:
        console.print("[dim]âš¡ ç¯å¢ƒå˜é‡å·²å°±ç»ª[/dim]")
    else:
        try:
            with open(rc_file, 'a') as f:
                f.write(f'\n# Wagstaff-Lab Environment\nexport PATH="{bin_path_str}:$PATH"\n')
            console.print(f"[green]âœ… PATH å·²æ›´æ–°[/green]")
        except Exception:
            pass

def main():
    console.print("[bold blue]ğŸ”§ Wagstaff-Lab è‡ªåŠ¨åŒ–æ³¨å†Œä¸­å¿ƒ[/bold blue]")
    create_wrappers()
    register_to_path()

if __name__ == "__main__":
    main()

```

### File: devtools/pm.py
```py
#!/usr/bin/env python3
import os
import json
import sys
from datetime import datetime
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.prompt import Prompt, IntPrompt

console = Console()
STATUS_FILE = "PROJECT_STATUS.json"

class ProjectManager:
    def __init__(self):
        self.data = self._load()

    def _load(self):
        if os.path.exists(STATUS_FILE):
            with open(STATUS_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        return {"objective": "Unset", "tasks": [], "logs": [], "guidelines": []}

    def _save(self):
        with open(STATUS_FILE, 'w', encoding='utf-8') as f:
            json.dump(self.data, f, indent=2, ensure_ascii=False)

    def set_objective(self, obj):
        self.data["objective"] = obj
        self._save()
        console.print(f"[green]âœ… ç›®æ ‡æ›´æ–°:[/green] {obj}")

    def add_task(self, task):
        self.data["tasks"].append({"desc": task, "status": "todo", "time": str(datetime.now())})
        self._save()
        console.print(f"[green]âœ… ä»»åŠ¡+1:[/green] {task}")
    
    def add_rule(self, rule):
        if "guidelines" not in self.data: self.data["guidelines"] = []
        self.data["guidelines"].append(rule)
        self._save()
        console.print(f"[bold magenta]ğŸ“œ å®—æ—¨å½•å…¥:[/bold magenta] {rule}")

    def complete_task(self, index):
        if 0 <= index < len(self.data["tasks"]):
            self.data["tasks"][index]["status"] = "done"
            self._save()
            console.print(f"[green]ğŸ‰ å®Œæˆ:[/green] {self.data['tasks'][index]['desc']}")
        else:
            console.print("[red]âŒ ç´¢å¼•æ— æ•ˆ[/red]")

    def log_entry(self, msg):
        self.data["logs"].append(f"[{datetime.now().strftime('%Y-%m-%d %H:%M')}] {msg}")
        if len(self.data["logs"]) > 10: self.data["logs"].pop(0)
        self._save()
        console.print("[green]ğŸ“ æ—¥å¿—å·²è®°å½•[/green]")

    def show_status(self):
        console.clear()
        console.print(Panel(f"[bold blue]ğŸ¯ ç›®æ ‡: {self.data.get('objective', 'Unset')}[/bold blue]"))
        
        t_table = Table(title="ä»»åŠ¡æ¸…å•", box=None)
        t_table.add_column("ID", style="dim"); t_table.add_column("çŠ¶æ€"); t_table.add_column("å†…å®¹")
        for i, t in enumerate(self.data["tasks"]):
            status = "âœ…" if t["status"] == "done" else "â¬œ"
            style = "dim strike" if t["status"] == "done" else "bold"
            t_table.add_row(str(i), status, f"[{style}]{t['desc']}[/{style}]")
        console.print(t_table)
        
        if self.data.get("logs"):
            console.print("\n[dim]ğŸ“œ æœ€è¿‘æ—¥å¿—:[/dim]")
            for l in self.data["logs"][-3:]:
                console.print(f"  {l}")

    def interactive_mode(self):
        while True:
            self.show_status()
            console.print("\n[bold cyan]æ“ä½œèœå•:[/bold cyan]")
            console.print("1. [green]âœ… å®Œæˆä»»åŠ¡[/]  2. [blue]â• æ–°å¢ä»»åŠ¡[/]  3. [magenta]ğŸ“ å†™æ—¥å¿—[/]  4. [yellow]ğŸ¯ æ”¹ç›®æ ‡[/]  0. [red]é€€å‡º[/]")
            
            choice = Prompt.ask("é€‰æ‹©æ“ä½œ", choices=["0", "1", "2", "3", "4"], default="0")
            
            if choice == "0": break
            elif choice == "1":
                idx = IntPrompt.ask("è¾“å…¥ä»»åŠ¡ID")
                self.complete_task(idx)
            elif choice == "2":
                desc = Prompt.ask("è¾“å…¥ä»»åŠ¡æè¿°")
                self.add_task(desc)
            elif choice == "3":
                log = Prompt.ask("è¾“å…¥æ—¥å¿—å†…å®¹")
                self.log_entry(log)
            elif choice == "4":
                obj = Prompt.ask("è¾“å…¥æ–°ç›®æ ‡")
                self.set_objective(obj)
            
            if choice != "0":
                input("\næŒ‰å›è½¦ç»§ç»­...")

def main():
    pm = ProjectManager()
    if len(sys.argv) > 1:
        cmd = sys.argv[1]
        content = " ".join(sys.argv[2:])
        if cmd == "obj": pm.set_objective(content)
        elif cmd == "add": pm.add_task(content)
        elif cmd == "rule": pm.add_rule(content)
        elif cmd == "done": pm.complete_task(int(sys.argv[2]))
        elif cmd == "log": pm.log_entry(content)
        elif cmd == "ui": pm.interactive_mode() # æ–°å¢å…¥å£
        else: pm.show_status()
    else:
        # é»˜è®¤ç›´æ¥è¿›å…¥äº¤äº’æ¨¡å¼ï¼Œæ›´çœäº‹
        pm.interactive_mode()

if __name__ == "__main__":
    main()

```

### File: devtools/reporter.py
```py
#!/usr/bin/env python3
import os
import sys
import re
from collections import Counter, defaultdict
from rich.console import Console
from rich.progress import track

# æŒ‚è½½ src å¹¶å¼•å…¥å¼•æ“
sys.path.append(os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "src"))
from engine import WagstaffEngine

console = Console()

# === [ä¿®å¤] åŠ¨æ€å®šä½é¡¹ç›®è·¯å¾„ ===
CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.dirname(CURRENT_DIR)
REPORT_DIR = os.path.join(PROJECT_ROOT, "data", "reports")

class WagstaffReporter:
    def __init__(self):
        # å¯åŠ¨å¼•æ“ï¼Œä¸éœ€è¦åŠ è½½æ•°æ®åº“(æˆ‘ä»¬åªåšæ­£åˆ™æ‰«æ)
        self.engine = WagstaffEngine(load_db=False, silent=True)
        self._ensure_report_dir()

    def _ensure_report_dir(self):
        if not os.path.exists(REPORT_DIR):
            os.makedirs(REPORT_DIR)
            console.print(f"[green]ğŸ“ åˆ›å»ºæŠ¥å‘Šç›®å½•: {REPORT_DIR}[/green]")

    def generate_asset_report(self):
        """æ‰«æå…¨æœèµ„äº§åˆ†å¸ƒ"""
        console.print("[bold blue]ğŸ“¡ æ­£åœ¨ç”Ÿæˆèµ„äº§åˆ†å¸ƒæŠ¥å‘Š...[/bold blue]")
        
        TARGETS = {
            "STRINGS": re.compile(r'STRINGS\.[A-Z0-9_]+\s*='),
            "Prefabs": re.compile(r'\bPrefab\s*\('),
            "LootTables": re.compile(r'\bSetLoot\s*\(|\bSetChanceLoot\s*\('),
            "Brains": re.compile(r'require\s*[\("\']brains/'),
            "Widgets": re.compile(r'require\s*[\("\']widgets/'),
        }
        
        stats = defaultdict(Counter)
        lua_files = [f for f in self.engine.file_list if f.endswith(".lua")]
        
        for fname in track(lua_files, description="Scanning Assets..."):
            content = self.engine.read_file(fname)
            if not content: continue
            clean = re.sub(r'--.*$', '', content, flags=re.MULTILINE)
            
            for cat, pattern in TARGETS.items():
                matches = pattern.findall(clean)
                if matches:
                    stats[cat][fname] += len(matches)

        out_path = os.path.join(REPORT_DIR, "asset_registry.md")
        with open(out_path, 'w', encoding='utf-8') as f:
            f.write("# Wagstaff Asset Registry\n\n")
            f.write("| Category | Total Definitions | Top File |\n")
            f.write("|----------|-------------------|----------|\n")
            for cat, file_counts in stats.items():
                total = sum(file_counts.values())
                top_file = file_counts.most_common(1)[0][0]
                f.write(f"| {cat} | {total} | `{top_file}` |\n")
            
            f.write("\n## Detailed Breakdown\n")
            for cat, file_counts in stats.items():
                f.write(f"\n### {cat}\n")
                for fname, count in file_counts.most_common(10):
                    f.write(f"- `{fname}`: {count}\n")
        console.print(f"[green]âœ… æŠ¥å‘Šå·²ä¿å­˜: {out_path}[/green]")

    def generate_recipe_report(self):
        """æ‰«æé…æ–¹åˆ†å¸ƒ"""
        console.print("[bold blue]ğŸ³ æ­£åœ¨ç”Ÿæˆé…æ–¹åˆ†å¸ƒæŠ¥å‘Š...[/bold blue]")
        
        pattern = re.compile(r'^\s*([a-zA-Z0-9_]*Recipe[a-zA-Z0-9_]*)\s*\(', re.MULTILINE)
        stats = Counter()
        file_stats = defaultdict(int)
        
        lua_files = [f for f in self.engine.file_list if f.endswith(".lua")]
        
        for fname in track(lua_files, description="Scanning Recipes..."):
            content = self.engine.read_file(fname)
            if not content: continue
            clean = re.sub(r'--.*$', '', content, flags=re.MULTILINE)
            
            matches = pattern.findall(clean)
            for m in matches:
                if "Get" in m or "Find" in m: continue
                stats[m] += 1
                file_stats[fname] += 1

        out_path = os.path.join(REPORT_DIR, "recipe_distribution.md")
        with open(out_path, 'w', encoding='utf-8') as f:
            f.write("# Wagstaff Recipe Distribution\n\n")
            f.write("## Function Usage\n")
            for func, count in stats.most_common():
                f.write(f"- **{func}**: {count}\n")
            f.write("\n## File Hotspots (Top 20)\n")
            for fname, count in sorted(file_stats.items(), key=lambda x:x[1], reverse=True)[:20]:
                f.write(f"- `{fname}`: {count} recipes\n")

        console.print(f"[green]âœ… æŠ¥å‘Šå·²ä¿å­˜: {out_path}[/green]")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python reporter.py [assets|recipes|all]")
        sys.exit(1)
    reporter = WagstaffReporter()
    cmd = sys.argv[1]
    if cmd == "assets" or cmd == "all": reporter.generate_asset_report()
    if cmd == "recipes" or cmd == "all": reporter.generate_recipe_report()

```

### File: devtools/snapshot.py
```py
#!/usr/bin/env python3
import os
import platform
import subprocess
import shutil
import sys
import json
from pathlib import Path
from datetime import datetime

PROJECT_ROOT = Path(__file__).resolve().parent.parent
OUTPUT_FILE = PROJECT_ROOT / "project_context.txt"

SCAN_RULES = [
    {"dir": "bin", "ext": ".sh"},
    {"dir": "src", "ext": ".py"},
    {"dir": "conf", "ext": ".ini"},
    {"dir": "devtools", "ext": ".py"},
    {"dir": ".", "ext": ".md"},
    {"dir": ".", "ext": ".txt"},
]

IGNORE_DIRS = {".git", "__pycache__", "logs", "env", "venv", ".idea", ".vscode"}
IGNORE_FILES = {"project_context.txt", ".DS_Store", "id_rsa", "known_hosts"}

def run_cmd(cmd):
    try:
        return subprocess.check_output(cmd, shell=True, text=True, cwd=PROJECT_ROOT, stderr=subprocess.DEVNULL).strip()
    except Exception:
        return "Unknown"

def get_system_fingerprint():
    info = []
    info.append(f"Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    info.append(f"User: {os.getenv('USER', 'Unknown')}")
    info.append(f"Host: {platform.node()} ({platform.system()} {platform.release()})")
    info.append(f"Python: {platform.python_version()} ({sys.executable})")
    try:
        import rich
        ver = getattr(rich, '__version__', 'Installed (ver unknown)')
        info.append(f"Rich Ver: {ver}")
    except:
        info.append("Rich Ver: Not Installed")
    return "\n".join(info)

def get_git_status():
    if not (PROJECT_ROOT / ".git").exists(): return "Git: Not a repository"
    branch = run_cmd("git rev-parse --abbrev-ref HEAD")
    commit = run_cmd("git rev-parse --short HEAD")
    last_msg = run_cmd("git log -1 --pretty=%B")
    is_dirty = run_cmd("git status --porcelain") != ""
    dirty_mark = " [DIRTY]" if is_dirty else " [CLEAN]"
    return f"Branch: {branch}{dirty_mark}\nCommit: {commit}\nMessage: {last_msg}"

def generate_tree(dir_path, prefix=""):
    tree_str = ""
    try:
        contents = sorted([p for p in dir_path.iterdir() if p.name not in IGNORE_DIRS])
    except PermissionError:
        return f"{prefix}â””â”€â”€ [Permission Denied]\n"
    pointers = [("â”œâ”€â”€ " if i < len(contents) - 1 else "â””â”€â”€ ") for i in range(len(contents))]
    for pointer, path in zip(pointers, contents):
        if path.name in IGNORE_FILES: continue
        tree_str += f"{prefix}{pointer}{path.name}\n"
        if path.is_dir():
            extension = "â”‚   " if pointer == "â”œâ”€â”€ " else "    "
            tree_str += generate_tree(path, prefix=prefix + extension)
    return tree_str

def main():
    print(f"ğŸ“¸ æ­£åœ¨ç”Ÿæˆ Wagstaff-Lab å…¨æ¯å¿«ç…§...")
    report = []
    report.append("# Wagstaff-Lab Project Snapshot")
    
    report.append("\n## 1. Environment Diagnostics")
    report.append("```yaml")
    report.append(get_system_fingerprint())
    report.append("-" * 20)
    report.append(get_git_status())
    report.append("```")

    report.append("\n## 2. Project Structure")
    report.append("```text")
    report.append(generate_tree(PROJECT_ROOT))
    report.append("```")

    report.append("\n## 3. Source Code")
    file_count = 0
    for rule in SCAN_RULES:
        search_dir = PROJECT_ROOT / rule["dir"]
        if rule["dir"] == ".": search_dir = PROJECT_ROOT
        if not search_dir.exists(): continue
        for file_path in sorted(search_dir.glob(f"*{rule['ext']}")):
            if file_path.name in IGNORE_FILES: continue
            rel_path = file_path.relative_to(PROJECT_ROOT)
            report.append(f"\n### File: {rel_path}")
            lang = rule['ext'].replace('.', '')
            if lang == 'ini': lang = 'toml'
            report.append(f"```{lang}")
            try:
                report.append(file_path.read_text(encoding='utf-8'))
                file_count += 1
            except:
                report.append("Error reading file")
            report.append("```")
    
    # Section 4: Project Context (Auto-Generated)
    report.append("\n## 4. Project Context (Auto-Generated)")
    report.append("```text")
    if os.path.exists("PROJECT_STATUS.json"):
        try:
            with open("PROJECT_STATUS.json", 'r') as f:
                data = json.load(f)
                if data.get("guidelines"):
                    report.append("DEV MANIFESTO:")
                    for rule in data["guidelines"]:
                        report.append(f"* {rule}")
                    report.append("-" * 20)
                report.append(f"OBJECTIVE: {data.get('objective')}")
                report.append("\nTASKS:")
                for i, t in enumerate(data.get('tasks', [])):
                    mark = "[x]" if t['status'] == 'done' else "[ ]"
                    report.append(f"{i}. {mark} {t['desc']}")
        except:
            report.append("Error reading project status.")
    else:
        report.append("No project status file found.")
    report.append("```")

    with open(OUTPUT_FILE, "w", encoding="utf-8") as f:
        f.write("\n".join(report))
    
    print(f"âœ… å¿«ç…§ç”Ÿæˆå®Œæ¯•: {OUTPUT_FILE}")

if __name__ == "__main__":
    main()

```

### File: README.md
```md
ğŸ§ª Wagstaff-Lab (v2.2)Wagstaff-Lab æ˜¯ä¸€ä¸ªä¸“ä¸ºã€Šé¥¥è’è”æœºç‰ˆã€‹(Don't Starve Together) è®¾è®¡çš„æœåŠ¡å™¨è¿ç»´ã€æºç åˆ†æä¸é¡¹ç›®ç®¡ç†å·¥å…·é›† ã€‚å®ƒé‡‡ç”¨â€œæ³¨å†Œè¡¨é©±åŠ¨â€æ¶æ„ï¼Œå®ç°äº†ä»åº•å±‚æ•°æ®è§£æåˆ°é«˜å±‚ UI å±•ç¤ºçš„å…¨è‡ªåŠ¨åŒ–ç®¡ç† ã€‚ğŸŒŸ æ ¸å¿ƒç†å¿µ (Manifesto)æœ¬é¡¹ç›®çš„å¼€å‘ä¸¥æ ¼éµå¾ªä»¥ä¸‹å®—æ—¨ ï¼šæ¶æ„åˆ†å±‚ï¼šEngine è´Ÿè´£åº•å±‚ I/O ä¸æ•°æ®è§£æï¼ŒTool è´Ÿè´£ä¸šåŠ¡é€»è¾‘ä¸äº¤äº’ï¼Œä¸¥ç¦ UI ä»£ç æ··å…¥åº•å±‚ ã€‚å•æ–‡ä»¶å¯ç”¨ï¼šæ¯ä¸ªè„šæœ¬å¿…é¡»ä¿æŒåŸå­åŒ–ï¼Œèƒ½å¤Ÿç‹¬ç«‹è¿è¡Œ ã€‚è·¯å¾„è‡ªé€‚åº”ï¼šç¦æ­¢ç¡¬ç¼–ç ç»å¯¹è·¯å¾„ï¼Œæ‰€æœ‰è·¯å¾„å‡é€šè¿‡ __file__ åŠ¨æ€æ¨ç®— ã€‚æ•°æ®æŒä¹…åŒ–ï¼šæ‰€æœ‰æ‰«æç»“æœä¸æ—¥å¿—å¿…é¡»è½ç›˜ä¿å­˜ ã€‚ç¨³å¥é™çº§ï¼šä¼˜å…ˆè¯»å– scripts.zipï¼Œå¤±è´¥æ—¶è‡ªåŠ¨é™çº§ä¸ºæ–‡ä»¶å¤¹è¯»å–æ¨¡å¼ ã€‚ğŸš€ å¿«é€Ÿå¼€å§‹1. ç¯å¢ƒå‡†å¤‡ç¡®ä¿ä½ çš„ç³»ç»Ÿå·²å®‰è£… Condaï¼Œå¹¶åˆ›å»ºäº†åä¸º dst_lab çš„ Python 3.10+ ç¯å¢ƒ ã€‚2. åˆå§‹åŒ–é¡¹ç›®åœ¨æ‹‰å–ä»£ç åï¼Œè¿è¡Œä¸€é”®åˆå§‹åŒ–è„šæœ¬ ï¼šBash./setup.sh
è¯¥è„šæœ¬ä¼šè‡ªåŠ¨ï¼šä¿®å¤è„šæœ¬æ‰§è¡Œæƒé™ ã€‚è‡ªåŠ¨æ¿€æ´» dst_lab ç¯å¢ƒã€‚å°†é¡¹ç›®å·¥å…·è·¯å¾„æ³¨å†Œåˆ°ä½ çš„ç³»ç»Ÿç¯å¢ƒå˜é‡ï¼ˆ.bashrc æˆ– .profileï¼‰ ã€‚3. ç”Ÿæ•ˆé…ç½®Bashsource ~/.bashrc
ğŸ› ï¸ å·¥å…·ç®±è¯´æ˜ä¹¦ä½ å¯ä»¥é€šè¿‡è¾“å…¥ Wagstaff-Lab å‘¼å‡ºä¸»æ§åˆ¶é¢æ¿æŸ¥çœ‹å®æ—¶å·¥å…·åˆ—è¡¨ ã€‚å‘½ä»¤åˆ«ååŠŸèƒ½æè¿°Wagstaff-Lab-ä¸»å…¥å£ï¼šæŸ¥çœ‹é¡¹ç›®æ¦‚å†µä¸å·¥å…·æ¸…å•pm-é¡¹ç›®ç®¡ç†ï¼šäº¤äº’å¼ç®¡ç†ä»»åŠ¡è¿›åº¦ä¸å¼€å‘æ—¥å¿— wagstaff wikiwikiç™¾ç§‘æŸ¥è¯¢ï¼šå¿«é€ŸæŸ¥é˜…ç‰©å“é…æ–¹ã€ç»„ä»¶ä¸æ•°å€¼ wagstaff expexpæºç é€è§†ï¼šæ·±åº¦åˆ†æ Prefab ç»“æ„ä¸é€»è¾‘ wagstaff reportreportæƒ…æŠ¥ç”Ÿæˆï¼šç”Ÿæˆèµ„äº§åˆ†å¸ƒä¸é…æ–¹ç»Ÿè®¡æŠ¥å‘Š wagstaff snapsnapå…¨æ¯å¿«ç…§ï¼šç”Ÿæˆç”¨äº AI åä½œçš„é¡¹ç›®å…¨æ¯å¿«ç…§ ğŸ—ï¸ æ–°å·¥å…·å¼€å‘ SOP (v2.2 æ ‡å‡†)è‹¥è¦åœ¨å®éªŒå®¤ä¸­çº³å…¥æ–°å·¥å…·ï¼Œè¯·éµå¾ªä»¥ä¸‹æµç¨‹ï¼šå¼€å‘ (Develop)ï¼šåœ¨ src/ æˆ– devtools/ ç›®å½•ä¸‹ç¼–å†™ä½ çš„ Python è„šæœ¬ ã€‚æ³¨å†Œ (Register)ï¼šåœ¨ src/registry.py çš„ TOOLS åˆ—è¡¨ä¸­æ·»åŠ è¯¥å·¥å…·çš„å…ƒæ•°æ®ï¼ˆåŒ…å« file, alias, desc, usage ç­‰å­—æ®µï¼‰ã€‚åŒæ­¥ (Apply)ï¼šè¿è¡Œ wagstaff install (æˆ– python3 devtools/installer.py) è‡ªåŠ¨ç”Ÿæˆå‘½ä»¤è¡ŒåŒ…è£…å™¨ã€‚è®°å½• (Log)ï¼šä½¿ç”¨ pm ui è®°å½•ä½ çš„å¼€å‘æ—¥å¿— ã€‚ğŸ“ ç›®å½•ç»“æ„Plaintextâ”œâ”€â”€ bin/                # è‡ªåŠ¨åŒ–ç”Ÿæˆçš„å‘½ä»¤è¡ŒåŒ…è£…å™¨ 
â”œâ”€â”€ src/                # ä¸šåŠ¡æ ¸å¿ƒä»£ç  (Engine, Wiki, Explorer) 
â”œâ”€â”€ devtools/           # å¼€å‘è¿ç»´å·¥å…· (PM, Snap, Reporter) 
â”œâ”€â”€ conf/               # é…ç½®æ–‡ä»¶ (settings.ini)
â”œâ”€â”€ data/               # æŒä¹…åŒ–æ•°æ®ä¸æŠ¥å‘Š 
â””â”€â”€ PROJECT_STATUS.json # é¡¹ç›®è¿›åº¦ä¸å®—æ—¨æ•°æ®åº“
```

## 4. Project Context (Auto-Generated)
```text
DEV MANIFESTO:
* æ¶æ„åˆ†å±‚ï¼šEngineè´Ÿè´£åº•å±‚I/Oï¼ŒToolè´Ÿè´£äº¤äº’ï¼Œç¦æ­¢UIæ··å…¥åº•å±‚
* å•æ–‡ä»¶å¯ç”¨ï¼šè„šæœ¬å¿…é¡»åŸå­åŒ–ï¼Œèƒ½ç‹¬ç«‹è¿è¡Œï¼Œæ‹’ç»å¼ºè€¦åˆ
* è·¯å¾„è‡ªé€‚åº”ï¼šç¦æ­¢ç¡¬ç¼–ç ç»å¯¹è·¯å¾„ï¼Œå¿…é¡»é€šè¿‡ __file__ åŠ¨æ€å®šä½
* æ•°æ®æŒä¹…åŒ–ï¼šæ‰«æç»“æœå’Œæ—¥å¿—å¿…é¡»å†™å…¥æ–‡ä»¶ï¼Œä¸ä»…é™äºæ§åˆ¶å°è¾“å‡º
* ç¨³å¥é™çº§ï¼šä¼˜å…ˆZipè¯»å–ï¼Œå¤±è´¥åˆ™é™çº§Folder
--------------------
OBJECTIVE: Wagstaff Lab v2.0 æ¶æ„å‡çº§ä¸æƒ…æŠ¥æŒä¹…åŒ–

TASKS:
0. [x] é‡æ„ Wiki å’Œ Explorer ä½¿ç”¨ Engine
1. [x] å®ç°æƒ…æŠ¥æ‰«æç»“æœä¿å­˜åˆ° data/reports/
2. [x] åˆ›å»º src/guide.py é¡¹ç›®æ¦‚å†µé¢æ¿
3. [x] åˆ›å»º devtools/installer.py å¹¶å°è£… bin/wagstaff å‘½ä»¤
4. [ ] æ–‡æ¡£åŒ–ï¼šåœ¨ README.md ä¸­è®°å½•æ–°å·¥å…·æ¥å…¥ SOP
5. [ ] é‡æ„å·¥å…·æ³¨å†Œé€»è¾‘ï¼šå¼•å…¥ src/registry.py å®ç°å•ä¸€æ•°æ®æº
```