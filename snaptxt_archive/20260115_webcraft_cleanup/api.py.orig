# -*- coding: utf-8 -*-
from __future__ import annotations

from typing import Any, Dict, List, Optional

from fastapi import APIRouter, Request, Depends, HTTPException, Query
from fastapi.responses import FileResponse
from pydantic import BaseModel, Field

from .catalog_store import CatalogStore, CraftRecipe, CookingRecipe
from .planner import craftable_recipes, missing_for, normalize_inventory
from .cooking_planner import find_cookable, simulate_cookpot, normalize_counts


def get_store(request: Request) -> CatalogStore:
    """Resolve the catalog store from app state (with optional auto-reload)."""

    store: CatalogStore = request.app.state.store  # type: ignore[attr-defined]
    auto = bool(getattr(request.app.state, "auto_reload_catalog", False))
    if auto:
        try:
            store.load(force=False)
        except Exception:
            # do not break requests on reload errors
            pass
    return store


router = APIRouter(prefix="/api/v1")


# ----------------- optional tuning traces (requires analyzer engine) -----------------


def _get_engine(request: Request):
    return getattr(request.app.state, "engine", None)


def _ensure_tuning(engine) -> Any:
    """Best-effort: ensure engine.tuning is available.

    The WebCraft server may start analyzer engine without loading DBs.
    For UI purposes (e.g., cooking stats), we lazily load tuning.lua when needed.
    """
    if engine is None:
        return None

    tuning = getattr(engine, "tuning", None)
    if tuning is not None:
        return tuning

    try:
        # local import to keep webcraft lightweight when analyzer isn't used
        from analyzer import TuningResolver  # type: ignore

        content = engine.read_file("scripts/tuning.lua") or engine.read_file("tuning.lua") or ""
        if not content:
            return None
        tuning = TuningResolver(content)
        try:
            engine.tuning = tuning
        except Exception:
            pass
        return tuning
    except Exception:
        return None


def _enrich_cooking_recipe(raw: Dict[str, Any], *, name: Optional[str] = None, tuning: Any = None) -> Dict[str, Any]:
    """Return a safe copy of cooking recipe dict with optional tuning traces.

    Adds:
      - name (if missing)
      - _tuning: { field -> tuning.trace_expr(raw_string) } for any string that contains "TUNING"
    """
    out: Dict[str, Any] = dict(raw or {})
    if name and not out.get("name"):
        out["name"] = name

    if tuning is None:
        return out

    traces: Dict[str, Any] = {}
    for k, v in list(out.items()):
        if isinstance(v, str) and ("TUNING" in v):
            try:
                traces[str(k)] = tuning.trace_expr(v)
            except Exception:
                continue

    if traces:
        out["_tuning"] = traces
    return out



class PlanRequest(BaseModel):
    inventory: Dict[str, float] = Field(default_factory=dict)
    builder_tag: Optional[str] = None
    strict: bool = False
    limit: int = 200


class MissingRequest(BaseModel):
    name: str
    inventory: Dict[str, float] = Field(default_factory=dict)


class CookingFindRequest(BaseModel):
    inventory: Dict[str, float] = Field(default_factory=dict)
    limit: int = 200


class CookingSimulateRequest(BaseModel):
    slots: Dict[str, float] = Field(default_factory=dict)
    return_top: int = 25


@router.get("/meta")
def meta(request: Request, store: CatalogStore = Depends(get_store)):
    m = store.meta()
    m.update({"schema_version": store.schema_version()})

    # icon config (public)
    svc = getattr(request.app.state, "icon_service", None)
    if svc is not None:
        try:
            m.update({"icon": svc.cfg.to_public_dict()})
        except Exception:
            pass


    # i18n config (public)
    isvc = getattr(request.app.state, "i18n_service", None)
    if isvc is not None:
        try:
            eng = getattr(request.app.state, "engine", None)
            m.update({"i18n": isvc.public_meta(engine=eng)})
        except Exception:
            pass


    # runtime analyzer availability (optional)
    eng = _get_engine(request)
    m.update({"analyzer_enabled": bool(eng)})

    # tuning traces for UI (optional; requires scripts mounted)
    tuning = _ensure_tuning(eng)
    if tuning is not None:
        try:
            m.update({"tuning_enabled": True, "tuning_count": len(getattr(tuning, "raw_map", {}) or {})})
        except Exception:
            m.update({"tuning_enabled": True})
    else:
        m.update({"tuning_enabled": False})

    # i18n (optional)
    isvc = getattr(request.app.state, "i18n_service", None)
    if isvc is not None:
        try:
            m.update({"i18n": isvc.public_meta(engine=eng)})
        except Exception:
            pass

    return m


@router.get("/assets")
def assets(request: Request, store: CatalogStore = Depends(get_store)):
    mp = store.assets()

    svc = getattr(request.app.state, "icon_service", None)
    icon_cfg = None
    if svc is not None:
        try:
            icon_cfg = svc.cfg.to_public_dict()
        except Exception:
            icon_cfg = None

    return {"assets": mp, "count": len(mp), "icon": icon_cfg or {"mode": "off", "static_base": "/static/icons", "api_base": "/api/v1/icon"}}

@router.get("/i18n")
def i18n_meta(request: Request):
    """Return i18n capability + available languages."""
    svc = getattr(request.app.state, "i18n_service", None)
    if svc is None:
        return {"enabled": False, "langs": [], "modes": ["en", "zh", "id"], "default_mode": "en"}
    try:
        return svc.public_meta(engine=_get_engine(request))
    except Exception:
        return {"enabled": False, "langs": [], "modes": ["en", "zh", "id"], "default_mode": "en"}


@router.get("/i18n/names/{lang}")
def i18n_names(lang: str, request: Request, store: CatalogStore = Depends(get_store)):
    """Return id->localized name mapping for items in the current catalog."""
    svc = getattr(request.app.state, "i18n_service", None)
    if svc is None:
        return {"lang": str(lang), "names": {}, "count": 0}
    try:
        mp = svc.item_name_map(lang=str(lang), assets=store.assets(), engine=_get_engine(request))
    except Exception:
        mp = {}
    return {"lang": str(lang), "names": mp, "count": len(mp or {})}



# ----------------- i18n -----------------


@router.get("/i18n")
def i18n_meta(request: Request):
    svc = getattr(request.app.state, "i18n_service", None)
    eng = getattr(request.app.state, "engine", None)
    if svc is None:
        return {"enabled": False, "langs": [], "modes": ["en", "zh", "id"], "default_mode": "en"}
    try:
        return svc.public_meta(engine=eng)
    except Exception:
        return {"enabled": False, "langs": [], "modes": ["en", "zh", "id"], "default_mode": "en"}


@router.get("/i18n/names/{lang}")
def i18n_names(lang: str, request: Request, store: CatalogStore = Depends(get_store)):
    svc = getattr(request.app.state, "i18n_service", None)
    eng = getattr(request.app.state, "engine", None)
    if svc is None:
        return {"lang": str(lang), "names": {}, "count": 0}
    try:
        names = svc.item_name_map(lang=str(lang), assets=store.assets(), engine=eng)
    except Exception:
        names = {}
    return {"lang": str(lang), "names": names, "count": len(names or {})}


@router.get("/items/{item_id}")
def item_detail(item_id: str, request: Request, store: CatalogStore = Depends(get_store)):
    """Return best-effort item-centric view.

    This endpoint is used by the /catalog UI.
    """
    q = (item_id or "").strip()
    if not q:
        raise HTTPException(status_code=400, detail="empty item_id")

    # presentation asset (if any)
    assets = store.assets()
    asset = assets.get(q) or assets.get(q.lower())

    # craft references
    craft_used_in = store.list_by_ingredient(q) or store.list_by_ingredient(q.lower())
    craft_produced_by = store.list_by_product(q) or store.list_by_product(q.lower())

    # cooking references
    cook_used_in = store.list_cooking_by_ingredient(q) or store.list_cooking_by_ingredient(q.lower())
    cook_rec = store.get_cooking_recipe(q) or store.get_cooking_recipe(q.lower())

    return {
        "item_id": q,
        "asset": asset,
        "craft": {"used_in": craft_used_in, "produced_by": craft_produced_by},
        "cooking": {
            "as_recipe": (
                _enrich_cooking_recipe(cook_rec.raw, name=cook_rec.name, tuning=_ensure_tuning(_get_engine(request)))
                if cook_rec else None
            ),
            "used_in": cook_used_in,
        },
    }



@router.get("/icon/{item_id}.png")
def icon_png(item_id: str, request: Request, store: CatalogStore = Depends(get_store)):
    """Return an item icon as PNG.

    This endpoint supports dynamic generation (atlas+xml + tex) when enabled.
    In all modes, it caches to the static icons directory as <id>.png.
    """

    svc = getattr(request.app.state, "icon_service", None)
    if svc is None:
        raise HTTPException(status_code=503, detail="Icon service not configured")

    asset = store.get_asset(item_id)
    p = svc.ensure_icon(item_id, asset)
    if not p:
        raise HTTPException(status_code=404, detail=f"Icon not found: {item_id}")

    return FileResponse(path=str(p), media_type="image/png")


# ----------------- craft browse -----------------


@router.get("/craft/filters")
def craft_filters(store: CatalogStore = Depends(get_store)):
    order, defs = store.list_filters()
    return {"order": order, "defs": defs}


@router.get("/craft/tabs")
def craft_tabs(store: CatalogStore = Depends(get_store)):
    return {"tabs": store.list_tabs()}


@router.get("/craft/tags")
def craft_tags(store: CatalogStore = Depends(get_store)):
    return {"tags": store.list_tags()}


@router.get("/craft/filters/{filter_name}/recipes")
def craft_filter_recipes(filter_name: str, store: CatalogStore = Depends(get_store)):
    names = store.list_by_filter(filter_name)
    return {"filter": filter_name, "recipes": names}


@router.get("/craft/tabs/{tab}/recipes")
def craft_tab_recipes(tab: str, store: CatalogStore = Depends(get_store)):
    names = store.list_by_tab(tab)
    return {"tab": tab, "recipes": names}


@router.get("/craft/tags/{tag}/recipes")
def craft_tag_recipes(tag: str, store: CatalogStore = Depends(get_store)):
    names = store.list_by_tag(tag)
    return {"tag": tag, "recipes": names}


@router.get("/craft/ingredients/{item}/recipes")
def craft_ingredient_recipes(item: str, store: CatalogStore = Depends(get_store)):
    names = store.list_by_ingredient(item)
    return {"ingredient": item, "recipes": names}


# ----------------- craft recipe -----------------

@router.get("/craft/products/{item}/recipes")
def craft_product_recipes(item: str, store: CatalogStore = Depends(get_store)):
    names = store.list_by_product(item)
    return {"product": item, "recipes": names}



@router.get("/craft/recipes/search")
def craft_search(
    q: str = Query(..., min_length=1),
    limit: int = Query(50, ge=1, le=500),
    store: CatalogStore = Depends(get_store),
):
    return {"q": q, "results": store.search(q, limit=limit)}


@router.get("/craft/recipes/{name}")
def craft_recipe(name: str, store: CatalogStore = Depends(get_store)):
    rec = store.get_recipe(name)
    if not rec:
        raise HTTPException(status_code=404, detail=f"Recipe not found: {name}")
    return {"recipe": rec.raw}


# ----------------- craft planning -----------------


@router.post("/craft/plan")
def craft_plan(req: PlanRequest, store: CatalogStore = Depends(get_store)):
    inv = normalize_inventory(req.inventory)
    limit = int(req.limit or 200)
    limit = max(1, min(limit, 2000))

    recipes: List[CraftRecipe] = store.iter_recipes()
    recipes.sort(key=lambda x: x.name)

    ok, blocked = craftable_recipes(recipes, inv, builder_tag=req.builder_tag, strict=bool(req.strict))
    ok_names = [r.name for r in ok[:limit]]
    return {"craftable": ok_names, "blocked": blocked[:limit], "count": len(ok_names)}


@router.post("/craft/missing")
def craft_missing(req: MissingRequest, store: CatalogStore = Depends(get_store)):
    rec = store.get_recipe(req.name)
    if not rec:
        raise HTTPException(status_code=404, detail=f"Recipe not found: {req.name}")
    inv = normalize_inventory(req.inventory)
    miss = missing_for(rec, inv)
    return {"name": rec.name, "missing": [m.__dict__ for m in miss]}


# ----------------- cooking browse -----------------


@router.get("/cooking/recipes")
def cooking_all(store: CatalogStore = Depends(get_store)):
    recipes: List[CookingRecipe] = store.iter_cooking_recipes()
    names = sorted([r.name for r in recipes])
    return {"recipes": names, "count": len(names)}


@router.get("/cooking/foodtypes")
def cooking_foodtypes(store: CatalogStore = Depends(get_store)):
    return {"foodtypes": store.list_cooking_foodtypes()}


@router.get("/cooking/tags")
def cooking_tags(store: CatalogStore = Depends(get_store)):
    return {"tags": store.list_cooking_tags()}


@router.get("/cooking/foodtypes/{foodtype}/recipes")
def cooking_foodtype_recipes(foodtype: str, store: CatalogStore = Depends(get_store)):
    return {"foodtype": foodtype, "recipes": store.list_cooking_by_foodtype(foodtype)}


@router.get("/cooking/tags/{tag}/recipes")
def cooking_tag_recipes(tag: str, store: CatalogStore = Depends(get_store)):
    return {"tag": tag, "recipes": store.list_cooking_by_tag(tag)}


@router.get("/cooking/ingredients/{item}/recipes")
def cooking_ingredient_recipes(item: str, store: CatalogStore = Depends(get_store)):
    return {"ingredient": item, "recipes": store.list_cooking_by_ingredient(item)}


# ----------------- cooking recipe -----------------


@router.get("/cooking/recipes/search")
def cooking_search(
    q: str = Query(..., min_length=1),
    limit: int = Query(50, ge=1, le=500),
    store: CatalogStore = Depends(get_store),
):
    return {"q": q, "results": store.search_cooking(q, limit=limit)}


@router.get("/cooking/recipes/{name}")
def cooking_recipe(name: str, request: Request, store: CatalogStore = Depends(get_store)):
    rec = store.get_cooking_recipe(name)
    if not rec:
        raise HTTPException(status_code=404, detail=f"Cooking recipe not found: {name}")
    eng = _get_engine(request)
    tuning = _ensure_tuning(eng)
    return {"recipe": _enrich_cooking_recipe(rec.raw, name=rec.name, tuning=tuning)}


# ----------------- cooking helpers -----------------


@router.post("/cooking/find")
def cooking_find(req: CookingFindRequest, store: CatalogStore = Depends(get_store)):
    inv = normalize_counts(req.inventory)
    limit = max(1, min(int(req.limit or 200), 2000))

    recipes = store.iter_cooking_recipes()
    cookable = find_cookable(recipes, inv, limit=limit)
    names = [r.name for r in cookable]

    return {
        "cookable": names,
        "count": len(names),
        "note": "catalog v1: only recipes with card_ingredients are searchable/simulatable",
    }


@router.post("/cooking/simulate")
def cooking_simulate(req: CookingSimulateRequest, request: Request, store: CatalogStore = Depends(get_store)):
    recipes = store.iter_cooking_recipes()
    out = simulate_cookpot(recipes, req.slots, return_top=int(req.return_top or 25))

    # Attach result recipe details if available.
    if out.get("ok") and out.get("result"):
        rec = store.get_cooking_recipe(str(out.get("result")))
        if rec:
            eng = _get_engine(request)
            tuning = _ensure_tuning(eng)
            out["recipe"] = _enrich_cooking_recipe(rec.raw, name=rec.name, tuning=tuning)

    return out


@router.get("/analyze/prefab/{name}")
def analyze_prefab(name: str, request: Request):
    """Parse a prefab lua file and return a structured report.

    Requires the server to be started with analyzer enabled (scripts mounted).
    """
    eng = getattr(request.app.state, "engine", None)
    if eng is None:
        raise HTTPException(status_code=400, detail="analyzer disabled (no scripts source mounted)")

    q = (name or "").strip()
    if not q:
        raise HTTPException(status_code=400, detail="empty name")

    try:
        path = eng.find_file(q, fuzzy=True)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    if not path:
        raise HTTPException(status_code=404, detail=f"file not found for: {q}")

    content = eng.read_file(path)
    if content is None:
        raise HTTPException(status_code=404, detail=f"cannot read: {path}")

    from analyzer import LuaAnalyzer
    rep = LuaAnalyzer(content, path=path).get_report()
    return {"query": q, "path": path, "report": rep}