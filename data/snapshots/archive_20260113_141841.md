# Wagstaff-Lab Project Snapshot

- Generated: 2026-01-13T14:18:41
- Mode: archive
- Template: archive

## 1. Environment Diagnostics
```yaml
Time: 2026-01-13 14:18:41
User: steam
Host: VM-8-2-ubuntu (Linux 6.8.0-49-generic)
Python: 3.10.19 (/home/steam/miniconda3/envs/dst_lab/bin/python3)
Rich Ver: Installed (ver unknown)
--------------------
Branch: main [DIRTY]
Commit: 336ed22
Message: Release v2.2: Registry-driven architecture, new SOPs, and documentation
```

## 2. Project Overview
### 2.1 Toolbox (src/registry.py)
```text
alias   | file         | type | desc                    | usage                                           
--------+--------------+------+-------------------------+-------------------------------------------------
        | guide.py     | Core | Wagstaff-Lab æ§åˆ¶å°ä¸»é¢æ¿     | Wagstaff-Lab                                    
doctor  | doctor.py    | Src  | ç¯å¢ƒé…ç½®ä¸ä¾èµ–å¥åº·æ£€æŸ¥             | wagstaff doctor                                 
wiki    | wiki.py      | Src  | ç‰©å“/é…æ–¹/æ•°å€¼æŸ¥è¯¢ç™¾ç§‘            | wagstaff wiki <item_code>                       
exp     | explorer.py  | Src  | æºç ç»“æ„æµè§ˆä¸æ·±åº¦åˆ†æ             | wagstaff exp                                    
pm      | pm.py        | Dev  | é¡¹ç›®è¿›åº¦ä¸ä»»åŠ¡ç®¡ç†               | pm [ui|obj|add|done|log]                        
report  | reporter.py  | Dev  | ç”Ÿæˆå…¨æœèµ„äº§/é…æ–¹åˆ†å¸ƒæŠ¥å‘Š           | wagstaff report [assets|recipes|all]            
snap    | snapshot.py  | Dev  | ç”Ÿæˆé¡¹ç›®å…¨æ¯ä»£ç å¿«ç…§              | wagstaff snap [--mode core|full|custom] [--co...
install | installer.py | Dev  | ç¯å¢ƒæ³¨å†Œä¸å®‰è£…å‘å¯¼               | python3 devtools/installer.py                   
samples | sampler.py   | Dev  | ç”Ÿæˆ DST Lua æ ·æœ¬åŒ…ï¼ˆç”¨äºæ‰©å±•è§£æå™¨ï¼‰ | wagstaff samples [--categories ...] [--n N] [...
map     | codemap.py   | Dev  | ç”Ÿæˆ DST scripts å®è§‚ç»“æ„åœ°å›¾æŠ¥å‘Š | wagstaff map                                    
```

### 2.2 Project Context (PROJECT_STATUS.json)
```text
OBJECTIVE: None
```

## 3. Project Structure
```text
â”œâ”€â”€ .gitignore
â”œâ”€â”€ bin
â”‚   â”œâ”€â”€ boot.sh
â”‚   â”œâ”€â”€ dst_tool.sh
â”‚   â”œâ”€â”€ pm
â”‚   â”œâ”€â”€ wagstaff
â”‚   â””â”€â”€ Wagstaff-Lab
â”œâ”€â”€ conf
â”‚   â”œâ”€â”€ analyzer_focus.json
â”‚   â”œâ”€â”€ samples
â”‚   â”‚   â””â”€â”€ parse_other_data.json
â”‚   â”œâ”€â”€ settings.ini
â”‚   â””â”€â”€ snapshot_profile.json
â”œâ”€â”€ data
â”‚   â”œâ”€â”€ reports
â”‚   â”‚   â”œâ”€â”€ asset_registry.md
â”‚   â”‚   â”œâ”€â”€ dst_codemap.json
â”‚   â”‚   â”œâ”€â”€ dst_codemap.md
â”‚   â”‚   â””â”€â”€ recipe_distribution.md
â”‚   â””â”€â”€ samples
â”‚       â”œâ”€â”€ samples_20260113_105500.manifest.json
â”‚       â”œâ”€â”€ samples_20260113_105500.md
â”‚       â”œâ”€â”€ samples_20260113_112749.manifest.json
â”‚       â””â”€â”€ samples_20260113_112749.md
â”œâ”€â”€ devtools
â”‚   â”œâ”€â”€ codemap.py
â”‚   â”œâ”€â”€ installer.py
â”‚   â”œâ”€â”€ pm.py
â”‚   â”œâ”€â”€ reporter.py
â”‚   â”œâ”€â”€ sampler.py
â”‚   â””â”€â”€ snapshot.py
â”œâ”€â”€ project_context_analyzer.txt
â”œâ”€â”€ PROJECT_STATUS.json
â”œâ”€â”€ README.md
â”œâ”€â”€ setup.sh
â”œâ”€â”€ snapshots
â”‚   â””â”€â”€ snapshot_full_20260113_091618.md
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ analyzer.py
â”‚   â”œâ”€â”€ doctor.py
â”‚   â”œâ”€â”€ engine.py
â”‚   â”œâ”€â”€ explorer.py
â”‚   â”œâ”€â”€ guide.py
â”‚   â”œâ”€â”€ registry.py
â”‚   â”œâ”€â”€ utils.py
â”‚   â””â”€â”€ wiki.py
â””â”€â”€ tests
    â””â”€â”€ test_recipes.py
```

## 4. File Inventory
(mode: full/interface/head/skip; '*' means truncated when rendered)

```text
mode | bytes  | sha256_12    | path                                              
-----+--------+--------------+---------------------------------------------------
skip | 299    | -            | .gitignore                                        
skip | 1837   | -            | PROJECT_STATUS.json                               
skip | 2786   | -            | README.md                                         
full | 65     | f7752ace0a59 | bin/Wagstaff-Lab                                  
full | 2250   | 524c5d2d4996 | bin/boot.sh                                       
full | 12532  | a626b7bec4b0 | bin/dst_tool.sh                                   
full | 67     | c6931064b944 | bin/pm                                            
full | 824    | f5b10da0f56e | bin/wagstaff                                      
full | 887    | fe118abc74ab | conf/analyzer_focus.json                          
full | 2204   | 6091b29bdccc | conf/samples/parse_other_data.json                
full | 353    | 15952c921af7 | conf/settings.ini                                 
full | 887    | fe118abc74ab | conf/snapshot_profile.json                        
full | 2096   | 45c762a51673 | data/reports/asset_registry.md                    
full | 9771   | 641dac300b3e | data/reports/dst_codemap.json                     
full | 5196   | bb7f66b78652 | data/reports/dst_codemap.md                       
full | 1655   | e177df3496c5 | data/reports/recipe_distribution.md               
full | 3455   | eb55230ae2c1 | data/samples/samples_20260113_105500.manifest.json
full | 98207  | 62a18d214507 | data/samples/samples_20260113_105500.md           
full | 2006   | b9f885cebc8a | data/samples/samples_20260113_112749.manifest.json
full | 40900  | 0ecf222f76c5 | data/samples/samples_20260113_112749.md           
full | 5942   | e724d24f11e6 | devtools/codemap.py                               
full | 3586   | b1feb4cd296f | devtools/installer.py                             
full | 4956   | 21cc6d8ef466 | devtools/pm.py                                    
full | 4763   | 915b1577a0aa | devtools/reporter.py                              
full | 14604  | 2eaf081041e4 | devtools/sampler.py                               
full | 30382  | d4f3890bf272 | devtools/snapshot.py                              
skip | 45153  | -            | project_context_analyzer.txt                      
skip | 896    | -            | setup.sh                                          
full | 111587 | d0467b752cbe | snapshots/snapshot_full_20260113_091618.md        
full | 12469  | 8a4532394b56 | src/analyzer.py                                   
full | 7012   | 69d9d480c023 | src/doctor.py                                     
full | 4409   | 3b06776239e6 | src/engine.py                                     
full | 9616   | 6f0febfb5667 | src/explorer.py                                   
full | 1548   | b69213e54f5e | src/guide.py                                      
full | 2339   | 12dac7d17279 | src/registry.py                                   
full | 1040   | ffc01cb3d8f3 | src/utils.py                                      
full | 8796   | d7709d0e1f1b | src/wiki.py                                       
full | 1479   | 89bad0a5e326 | tests/test_recipes.py                             
```

## 5. File Contents

### File: bin/Wagstaff-Lab
- mode: full
- size_bytes: 65
- sha256_12: f7752ace0a59

```
#!/bin/bash
python3 "/home/steam/Wagstaff-Lab/src/guide.py" "$@"
```

### File: bin/boot.sh
- mode: full
- size_bytes: 2250
- sha256_12: 524c5d2d4996

```sh
#!/bin/bash
# =========================================================
# Wagstaff-Lab Bootloader (å¯åŠ¨å¼•å¯¼ç¨‹åº)
# èŒè´£: è®¾ç½®ç¯å¢ƒåº“(LD_LIBRARY_PATH)å¹¶å¯åŠ¨ DST äºŒè¿›åˆ¶æ–‡ä»¶
# =========================================================

# --- 1. å®šä½é…ç½® ---
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
CONFIG_FILE="$PROJECT_ROOT/conf/settings.ini"

# --- 2. ç®€æ˜“é…ç½®è¯»å–å™¨ ---
read_config() {
    local section=$1
    local key=$2
    local val=$(awk -F ' = ' -v section="[$section]" -v key="$key" '
        $0 == section { in_section=1; next }
        /^\[/ { in_section=0 }
        in_section && $1 == key { print $2; exit }
    ' "$CONFIG_FILE")
    echo "${val/\~/$HOME}"
}

# --- 3. åŠ è½½æ ¸å¿ƒå˜é‡ ---
INSTALL_DIR=$(read_config "PATHS" "DST_ROOT")
CLUSTER_NAME=$(read_config "SERVER" "CLUSTER_NAME")

# --- 4. ç¯å¢ƒæ£€æŸ¥ ---
if [ -z "$INSTALL_DIR" ] || [ -z "$CLUSTER_NAME" ]; then
    echo "âŒ [Boot] é”™è¯¯: æ— æ³•è¯»å–é…ç½®ï¼Œè¯·æ£€æŸ¥ conf/settings.ini"
    exit 1
fi

BIN_DIR="$INSTALL_DIR/bin"

# --- 5. è®¾ç½®ä¾èµ–åº“ (å…³é”®æ­¥éª¤) ---
# è¿™æ˜¯è®© Linux èƒ½è¿è¡Œ DST çš„æ ¸å¿ƒé­”æ³•
export LD_LIBRARY_PATH="$BIN_DIR/lib32:$BIN_DIR:$LD_LIBRARY_PATH"

# --- 6. è¿›å…¥æ‰§è¡Œç›®å½• ---
# å¿…é¡»è¿›å…¥ bin ç›®å½•ï¼Œå¦åˆ™æ¸¸æˆæ‰¾ä¸åˆ° data
cd "$BIN_DIR" || { echo "âŒ [Boot] æ‰¾ä¸åˆ°ç›®å½•: $BIN_DIR"; exit 1; }

echo "âš¡ [Boot] æ­£åœ¨åˆå§‹åŒ– Wagstaff å¼•æ“..."
echo "   - æ¸¸æˆæ ¹ç›®å½•: $INSTALL_DIR"
echo "   - å­˜æ¡£ç°‡åç§°: $CLUSTER_NAME"

# --- 7. å¯åŠ¨è¿›ç¨‹ (Master) ---
# ä½¿ç”¨ -dmS è®©å®ƒåœ¨åå° Screen è¿è¡Œ
screen -dmS "DST_Master" ./dontstarve_dedicated_server_nullrenderer -console -cluster "$CLUSTER_NAME" -shard Master
echo "âœ… [Boot] åœ°é¢æœåŠ¡å™¨ (Master) å·²å¯åŠ¨"

# --- 8. å¯åŠ¨è¿›ç¨‹ (Caves) ---
# åªæœ‰å½“å­˜æ¡£ä¸­å­˜åœ¨ Caves æ–‡ä»¶å¤¹æ—¶æ‰å¯åŠ¨ï¼Œæˆ–è€…ä½ å¯ä»¥é€‰æ‹©å¼ºåˆ¶å¯åŠ¨
# è¿™é‡Œä¸ºäº†ç¨³å¦¥ï¼Œæˆ‘ä»¬ç›´æ¥å¯åŠ¨ï¼Œå¦‚æœæ²¡æ´ç©´é…ç½®æ¸¸æˆä¼šè‡ªåŠ¨åœæ­¢ Caves è¿›ç¨‹ï¼Œæ— ä¼¤å¤§é›…
screen -dmS "DST_Caves" ./dontstarve_dedicated_server_nullrenderer -console -cluster "$CLUSTER_NAME" -shard Caves
echo "âœ… [Boot] æ´ç©´æœåŠ¡å™¨ (Caves) å·²å¯åŠ¨"

echo "âœ¨ å¯åŠ¨åºåˆ—å®Œæˆã€‚"
```

### File: bin/dst_tool.sh
- mode: full
- size_bytes: 12532
- sha256_12: a626b7bec4b0

```sh
#!/bin/bash

# =========================================================
# Wagstaff-Lab Control Center v6.1
# æ¨¡å—åŒ– DST æœåŠ¡å™¨ç®¡ç†è„šæœ¬
# =========================================================

# --- 1. ç¯å¢ƒåˆå§‹åŒ– ---

# è·å–è„šæœ¬æ‰€åœ¨ç›®å½•çš„ç»å¯¹è·¯å¾„ (bin/)
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
# å®šä½é¡¹ç›®æ ¹ç›®å½• (Wagstaff-Lab/)
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
# é…ç½®æ–‡ä»¶è·¯å¾„
CONFIG_FILE="$PROJECT_ROOT/conf/settings.ini"

# --- 2. é…ç½®è¯»å–å‡½æ•° (INI Parser) ---
# ç”¨é€”ï¼šä» settings.ini è¯»å–å˜é‡ï¼Œå¹¶è‡ªåŠ¨å°† ~ æ›¿æ¢ä¸º $HOME
read_config() {
    local section=$1
    local key=$2
    local val=$(awk -F ' = ' -v section="[$section]" -v key="$key" '
        $0 == section { in_section=1; next }
        /^\[/ { in_section=0 }
        in_section && $1 == key { print $2; exit }
    ' "$CONFIG_FILE")
    
    # æ›¿æ¢ ~ ä¸ºå½“å‰ç”¨æˆ· Home ç›®å½•
    echo "${val/\~/$HOME}"
}

# --- 3. åŠ è½½å˜é‡ ---
if [ ! -f "$CONFIG_FILE" ]; then
    echo "âŒ é”™è¯¯: æ‰¾ä¸åˆ°é…ç½®æ–‡ä»¶ $CONFIG_FILE"
    exit 1
fi

DST_DIR=$(read_config "PATHS" "DST_ROOT")
STEAMCMD_DIR=$(read_config "PATHS" "STEAMCMD_DIR")
BACKUP_REPO=$(read_config "PATHS" "BACKUP_DIR")
CLUSTER_NAME=$(read_config "SERVER" "CLUSTER_NAME")
KLEI_HOME=$(read_config "SERVER" "KLEI_HOME")

# [å…³é”®ä¿®æ”¹] å¯åŠ¨è„šæœ¬æŒ‡å‘åŒç›®å½•ä¸‹çš„ boot.sh
START_SCRIPT="$SCRIPT_DIR/boot.sh"

# æ—¥å¿—è·¯å¾„
LOG_MASTER="$KLEI_HOME/$CLUSTER_NAME/Master/server_log.txt"
LOG_CAVES="$KLEI_HOME/$CLUSTER_NAME/Caves/server_log.txt"

# å¯»æ‰¾ Conda Python ç¯å¢ƒ (ä¼˜å…ˆæ‰¾ dst_lab)
PYTHON_EXEC="$HOME/miniconda3/envs/dst_lab/bin/python"
if [ ! -f "$PYTHON_EXEC" ]; then
    # å¤‡ç”¨ï¼šå°è¯•ç³»ç»Ÿ python3
    PYTHON_EXEC=$(which python3)
fi

# ç¡®ä¿å¤‡ä»½ç›®å½•å­˜åœ¨
mkdir -p "$BACKUP_REPO"

# --- é¢œè‰²å®šä¹‰ ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
NC='\033[0m' # No Color

trap 'echo -e "\n${YELLOW}>> è¿”å›ä¸»èœå•...${NC}"; sleep 0.5' SIGINT

# ================= è¾…åŠ©å‡½æ•° =================

print_line() { echo -e "${CYAN}----------------------------------------${NC}"; }
pause() { echo -e "\n${WHITE}æŒ‰å›è½¦é”®ç»§ç»­...${NC}"; read -r; }

# [Security] è§£æç»å¯¹è·¯å¾„ï¼ˆä¼˜å…ˆ realpathï¼Œç¼ºå¤±åˆ™ç”¨ python3ï¼‰
resolve_path() {
    local p="$1"
    if command -v realpath >/dev/null 2>&1; then
        realpath -m "$p"
        return $?
    fi
    python3 - "$p" <<'PY'
import os, sys
try:
    print(os.path.realpath(os.path.expanduser(sys.argv[1])))
except:
    sys.exit(1)
PY
}

# [Security] é«˜å±åˆ é™¤ï¼šä»…å…è®¸åˆ é™¤ KLEI_HOME/CLUSTER_NAME ä¸”åšäºŒæ¬¡ç¡®è®¤
safe_delete_cluster_dir() {
    local base="$KLEI_HOME"
    local cluster="$CLUSTER_NAME"
    local target="$base/$cluster"

    if [ -z "$base" ] || [ -z "$cluster" ]; then
        echo -e "${RED}âŒ KLEI_HOME æˆ– CLUSTER_NAME ä¸ºç©ºï¼Œæ‹’ç»åˆ é™¤${NC}"
        return 1
    fi

    local base_real target_real
    base_real="$(resolve_path "$base")" || return 1
    target_real="$(resolve_path "$target")" || return 1

    # æŠ¤æ 1: ç›®æ ‡ä¸èƒ½æ˜¯ /ã€HOMEã€KLEI_HOME æœ¬èº«
    if [ "$target_real" = "/" ] || [ "$target_real" = "$HOME" ] || [ "$target_real" = "$base_real" ]; then
        echo -e "${RED}âŒ ç›®æ ‡è·¯å¾„å¼‚å¸¸ (ç³»ç»Ÿç›®å½•ä¿æŠ¤)ï¼Œæ‹’ç»åˆ é™¤: $target_real${NC}"
        return 1
    fi

    # æŠ¤æ 2: ç›®æ ‡å¿…é¡»ä¸¥æ ¼ä½äº KLEI_HOME ç›®å½•æ ‘ä¸‹
    case "$target_real" in
        "$base_real"/*) ;;
        *)
            echo -e "${RED}âŒ ç›®æ ‡ä¸åœ¨ KLEI_HOME ä¸‹ (è¶Šæƒä¿æŠ¤)ï¼Œæ‹’ç»åˆ é™¤${NC}"
            echo -e "   KLEI_HOME: $base_real"
            echo -e "   TARGET:    $target_real"
            return 1
            ;;
    esac

    if [ ! -d "$target_real" ]; then
        echo -e "${RED}âŒ å­˜æ¡£ç›®å½•ä¸å­˜åœ¨: $target_real${NC}"
        return 1
    fi

    echo -e "${YELLOW}ğŸ§¹ è­¦å‘Šï¼šå³å°†å½»åº•åˆ é™¤æ—§å­˜æ¡£ç›®å½•:${NC}"
    echo -e "${RED}   $target_real${NC}"
    
    # æŠ¤æ 3: ä¸¥æ ¼æ–‡æœ¬ç¡®è®¤
    read -p "è¯·è¾“å…¥ä»¥ä¸‹å†…å®¹ç¡®è®¤åˆ é™¤: DELETE $target_real : " confirm_del
    if [ "$confirm_del" != "DELETE $target_real" ]; then
        echo -e "${YELLOW}ğŸš« è¾“å…¥ä¸åŒ¹é…ï¼Œå·²å–æ¶ˆåˆ é™¤æ“ä½œ${NC}"
        return 1
    fi

    echo -e "${RED}ğŸ”¥ æ­£åœ¨æ‰§è¡Œé”€æ¯...${NC}"
    rm -rf -- "$target_real"
    return 0
}


check_status() {
    local master_status="${RED}ğŸ”´ æœªè¿è¡Œ${NC}"
    local caves_status="${RED}ğŸ”´ æœªè¿è¡Œ${NC}"
    if screen -ls | grep -q "DST_Master"; then master_status="${GREEN}ğŸŸ¢ è¿è¡Œä¸­${NC}"; fi
    if screen -ls | grep -q "DST_Caves"; then caves_status="${GREEN}ğŸŸ¢ è¿è¡Œä¸­${NC}"; fi
    echo -e "   åœ°é¢: $master_status    æ´ç©´: $caves_status"
}

# æŸ¥çœ‹æ—¥å¿—å‡½æ•°
view_log() {
    local logfile="$1"; local name="$2"
    if [ -f "$logfile" ]; then
        echo -e "${CYAN}ğŸ“º ç›‘è§† $name æ—¥å¿— (Ctrl+C é€€å‡º)${NC}"
        tail -f "$logfile"
    else
        echo -e "${RED}âŒ æ— æ—¥å¿—æ–‡ä»¶: $logfile${NC}"; pause
    fi
}

# å‘é€æŒ‡ä»¤çš„æ ¸å¿ƒå‡½æ•°
send_cmd_to_master() {
    local cmd="$1"
    local desc="$2"
    if ! screen -ls | grep -q "DST_Master"; then
        echo -e "${RED}âŒ åœ°é¢æœæœªè¿è¡Œ${NC}"; pause; return
    fi
    echo -e "${BLUE}ğŸ“¡ $desc${NC}"
    screen -S "DST_Master" -p 0 -X eval "stuff \"$cmd\015\""
    echo -e "${YELLOW}â³ æŒ‡ä»¤å·²å‘é€${NC}"; sleep 1
}

# ================= æ ¸å¿ƒåŠŸèƒ½æ¨¡å— =================

start_server() {
    print_line
    if screen -ls | grep -q "DST_Master"; then
        echo -e "${YELLOW}âš ï¸  æœåŠ¡å™¨å·²åœ¨è¿è¡Œï¼${NC}"; pause; return
    fi
    echo -e "${GREEN}ğŸš€ è°ƒç”¨å¯åŠ¨å¼•å¯¼ç¨‹åº (Bootloader)...${NC}"
    
    # æ£€æŸ¥å¯åŠ¨è„šæœ¬æ˜¯å¦å­˜åœ¨
    if [ -f "$START_SCRIPT" ]; then
        # æ‰§è¡Œ boot.sh
        "$START_SCRIPT"
    else
        echo -e "${RED}âŒ æ‰¾ä¸åˆ°å¯åŠ¨å™¨: $START_SCRIPT${NC}"
        echo "è¯·æ£€æŸ¥ bin/boot.sh æ˜¯å¦å­˜åœ¨ã€‚"
    fi
    pause
}

graceful_stop() {
    print_line
    echo -e "${YELLOW}ğŸ›‘ å‘é€åœæœä¿¡å·...${NC}"
    if ! screen -ls | grep -qE "DST_Master|DST_Caves"; then
        echo -e "${RED}âš ï¸  æœåŠ¡å™¨æœªè¿è¡Œ${NC}"; pause; return
    fi

    # å‘é€å…³é—­æŒ‡ä»¤
    for target in "DST_Master" "DST_Caves"; do
        if screen -list | grep -q "$target"; then
            screen -S "$target" -p 0 -X eval 'stuff "c_shutdown(true)\015"'
        fi
    done

    echo -e "${BLUE}â³ ç­‰å¾…å­˜æ¡£ä¿å­˜ (æœ€å¤š40ç§’)...${NC}"
    for ((i=1; i<=40; i++)); do
        if ! screen -list | grep -qE "DST_Master|DST_Caves"; then
            echo -e "\n${GREEN}âœ… æœåŠ¡å™¨å·²å…³é—­${NC}"; pause; return
        fi
        if tail -n 10 "$LOG_MASTER" 2>/dev/null | grep -q "Shutting down"; then
            echo -e "\n${GREEN}âœ… ç›‘æµ‹åˆ°å…³æœºä¿¡å·${NC}"; break
        fi
        echo -n "."; sleep 0.5
    done
    
    # æ¸…ç†æ®‹ä½™è¿›ç¨‹
    screen -list | grep -E "DST_Master|DST_Caves" | cut -d. -f1 | xargs -r -I{} screen -S {} -X quit
    echo -e "\n${GREEN}âœ… è¿›ç¨‹å·²ç»ˆæ­¢${NC}"; pause
}

restart_server() {
    print_line
    if screen -ls | grep -qE "DST_Master|DST_Caves"; then
        original_pause_def="$(declare -f pause)"; pause() { :; } 
        graceful_stop
        eval "$original_pause_def"
    fi
    read -p "æ˜¯å¦é¡ºä¾¿æ›´æ–°æ¸¸æˆ? (y/n): " up_c
    if [[ "$up_c" == "y" ]]; then update_game; fi
    start_server
}

update_game() {
    print_line
    echo -e "${BLUE}â¬‡ï¸  è°ƒç”¨ SteamCMD æ›´æ–°...${NC}"
    "$STEAMCMD_DIR/steamcmd.sh" +force_install_dir "$DST_DIR" +login anonymous +app_update 343050 validate +quit
    echo -e "${GREEN}âœ… æ›´æ–°å®Œæˆ${NC}"; pause
}

# --- å¤‡ä»½/æ¢å¤ç³»ç»Ÿ ---
create_backup() {
    print_line
    local ts=$(date +"%Y%m%d_%H%M%S")
    if [ ! -d "$KLEI_HOME/$CLUSTER_NAME" ]; then echo -e "${RED}âŒ å­˜æ¡£ä¸å­˜åœ¨: $KLEI_HOME/$CLUSTER_NAME${NC}"; pause; return; fi
    
    echo -e "${CYAN}ğŸ’¾ æ‰“åŒ…å­˜æ¡£: $CLUSTER_NAME ...${NC}"
    tar -zcf "$BACKUP_REPO/backup_${ts}.tar.gz" -C "$KLEI_HOME" "$CLUSTER_NAME"
    echo -e "${GREEN}âœ… å¤‡ä»½å·²åˆ›å»º: backup_${ts}.tar.gz${NC}"; pause
}

restore_backup() {
    print_line
    files=($(ls -1t "$BACKUP_REPO"/*.tar.gz 2>/dev/null))
    if [ ${#files[@]} -eq 0 ]; then echo -e "${RED}âŒ å¤‡ä»½åº“ä¸ºç©º${NC}"; pause; return; fi

    echo -e "${CYAN}ğŸ“‚ æœ€è¿‘å¤‡ä»½:${NC}"
    i=0
    for file in "${files[@]}"; do
        echo -e " [$i] $(basename "$file")"
        ((i++)); if [ $i -ge 10 ]; then break; fi
    done
    
    read -p "é€‰æ‹©åºå· (qé€€å‡º): " c
    if [[ "$c" == "q" ]]; then return; fi
    if ! [[ "$c" =~ ^[0-9]+$ ]] || [ "$c" -ge "$i" ]; then echo "âŒ æ— æ•ˆ"; pause; return; fi

    read -p "âš ï¸  é«˜å±æ“ä½œ: ç¡®è®¤è¦†ç›–å½“å‰å­˜æ¡£? (YES/n): " confirm
    if [[ "$confirm" != "YES" ]]; then return; fi

    # è‡ªåŠ¨åœæœ
    if screen -ls | grep -qE "DST_Master|DST_Caves"; then
        original_pause_def="$(declare -f pause)"; pause() { :; } 
        graceful_stop
        eval "$original_pause_def"
    fi

    echo -e "${YELLOW}ğŸ§¹ å‡†å¤‡æ¸…ç†æ—§å­˜æ¡£...${NC}"
    if ! safe_delete_cluster_dir; then
        echo -e "${RED}âŒ åˆ é™¤æ­¥éª¤å¤±è´¥æˆ–è¢«å–æ¶ˆï¼Œå·²ä¸­æ­¢å›æ¡£æµç¨‹${NC}"
        pause
        return
    fi
    echo -e "${BLUE}ğŸ“¦ è§£å‹å¤‡ä»½...${NC}"
    tar -zxf "${files[$c]}" -C "$KLEI_HOME"
    echo -e "${GREEN}âœ… å›æ¡£æˆåŠŸ${NC}"
    read -p "ç«‹å³å¯åŠ¨? (y/n): " sn
    if [[ "$sn" == "y" ]]; then start_server; else pause; fi
}

# --- Wagstaff å·¥å…·ç®±é›†æˆ ---
run_explorer() {
    local script_path="$PROJECT_ROOT/src/explorer.py"
    if [ -f "$script_path" ]; then
        "$PYTHON_EXEC" "$script_path"
    else
        echo -e "${RED}âŒ æ‰¾ä¸åˆ°å·¥å…·è„šæœ¬: $script_path${NC}"
        pause
    fi
}

run_wiki() {
    local script_path="$PROJECT_ROOT/src/wiki.py"
    if [ ! -f "$script_path" ]; then
        echo -e "${RED}âŒ æ‰¾ä¸åˆ° Wiki è„šæœ¬: $script_path${NC}"; pause; return
    fi

    echo -e "${CYAN}ğŸ“š è¯·è¾“å…¥ç‰©å“ä»£ç è¿›è¡ŒæŸ¥è¯¢ (ä¾‹å¦‚ spear, log, meat)${NC}"
    read -p "ç‰©å“ä»£ç : " item_code
    if [ -n "$item_code" ]; then
        "$PYTHON_EXEC" "$script_path" "$item_code"
    fi
    pause
}
console_menu() {
    while true; do
        clear
        echo -e "   ğŸ® ${CYAN}æ§åˆ¶å°æŒ‡ä»¤ä¸­å¿ƒ${NC} ğŸ®"
        check_status
        echo "--------------------------------"
        echo "1. ğŸ’¾ ç«‹å³ä¿å­˜ (c_save)"
        echo "2. âª å›æ»š1å¤© (c_rollback)"
        echo "3. ğŸ“¢ å‘é€å…¬å‘Š (c_announce)"
        echo "4. â˜ ï¸  é‡ç½®ä¸–ç•Œ (c_regenerateworld)"
        echo "5. ğŸ‘¥ åˆ—å‡ºç©å®¶"
        echo "0. ğŸ”™ è¿”å›"
        echo "--------------------------------"
        read -p "æŒ‡ä»¤: " cc
        case $cc in
            1) send_cmd_to_master "c_save()" "ç«‹å³ä¿å­˜" ;;
            2) send_cmd_to_master "c_rollback(1)" "å›æ»š1å¤©" ;;
            3) read -p "å†…å®¹: " m; send_cmd_to_master "c_announce(\"$m\")" "å…¬å‘Š" ;;
            4) read -p "è¾“å…¥ YES ç¡®è®¤é‡ç½®: " r; [[ "$r" == "YES" ]] && send_cmd_to_master "c_regenerateworld()" "é‡ç½®ä¸–ç•Œ" ;;
            5) send_cmd_to_master "c_listallplayers()" "ç©å®¶åˆ—è¡¨" ;;
            0) return ;;
        esac
    done
}

# ================= ä¸»å¾ªç¯ =================
while true; do
    clear
    echo "==========================================="
    echo -e " ğŸ¦… ${CYAN}Wagstaff-Lab æ§åˆ¶å° v6.1${NC} ğŸ¦…"
    echo "==========================================="
    check_status
    echo -e "${CYAN}--- è¿ç»´ç®¡ç† ---${NC}"
    echo "1. ğŸš€ å¯åŠ¨æœåŠ¡å™¨      2. ğŸ›‘ åœæ­¢æœåŠ¡å™¨"
    echo "3. ğŸ”„ é‡å¯æœåŠ¡å™¨      4. â¬‡ï¸  æ›´æ–°ç‰ˆæœ¬"
    echo -e "${CYAN}--- æ•°æ®ä¸å·¥å…· ---${NC}"
    echo "5. ğŸ’¾ åˆ›å»ºå¤‡ä»½        6. âª æ¢å¤å­˜æ¡£"
    echo "7. ğŸ“œ æŸ¥çœ‹æ—¥å¿—        8. ğŸ® å‘é€æŒ‡ä»¤"
    echo -e "9. ğŸ”¬ ${YELLOW}æºç é€è§†é•œ (Explorer)${NC}"
    echo -e "10.ğŸ“š ${GREEN}Wagstaff ç™¾ç§‘ (Wiki)${NC}"
    echo "0. ğŸšª é€€å‡º"
    echo "==========================================="
    
    read -p "é€‰é¡¹: " choice

    case $choice in
        1) start_server ;;
        2) graceful_stop ;;
        3) restart_server ;;
        4) update_game ;;
        5) create_backup ;;
        6) restore_backup ;;
        7) view_log "$LOG_MASTER" "Master" ;; 
        8) console_menu ;;
        9) run_explorer ;; 
	10) run_wiki ;;
        0) echo -e "${GREEN}å†è§ï¼Œç ”ç©¶å‘˜ã€‚${NC}"; exit 0 ;;
        *) echo "æ— æ•ˆ"; sleep 0.5 ;;
    esac
done
```

### File: bin/pm
- mode: full
- size_bytes: 67
- sha256_12: c6931064b944

```
#!/bin/bash
python3 "/home/steam/Wagstaff-Lab/devtools/pm.py" "$@"
```

### File: bin/wagstaff
- mode: full
- size_bytes: 824
- sha256_12: f5b10da0f56e

```
#!/bin/bash
TOOL="${1:-}"
if [ -z "$TOOL" ]; then
  exec "/home/steam/Wagstaff-Lab/bin/Wagstaff-Lab" "$@"
fi
shift
case "$TOOL" in
  doctor) python3 "/home/steam/Wagstaff-Lab/src/doctor.py" "$@" ;;
  wiki) python3 "/home/steam/Wagstaff-Lab/src/wiki.py" "$@" ;;
  exp) python3 "/home/steam/Wagstaff-Lab/src/explorer.py" "$@" ;;
  pm) python3 "/home/steam/Wagstaff-Lab/devtools/pm.py" "$@" ;;
  report) python3 "/home/steam/Wagstaff-Lab/devtools/reporter.py" "$@" ;;
  snap) python3 "/home/steam/Wagstaff-Lab/devtools/snapshot.py" "$@" ;;
  install) python3 "/home/steam/Wagstaff-Lab/devtools/installer.py" "$@" ;;
  samples) python3 "/home/steam/Wagstaff-Lab/devtools/sampler.py" "$@" ;;
  map) python3 "/home/steam/Wagstaff-Lab/devtools/codemap.py" "$@" ;;
  *) exec "/home/steam/Wagstaff-Lab/bin/Wagstaff-Lab" "$@" ;;
esac
```

### File: conf/analyzer_focus.json
- mode: full
- size_bytes: 887
- sha256_12: fe118abc74ab

```json
{
  "name": "analyzer-focus",
  "default_action": "omit",
  "full": [
    "src/analyzer.py",
    "src/engine.py",
    "src/explorer.py",
    "src/wiki.py",
    "src/utils.py",
    "src/registry.py",
    "tests/**/*.py",
    "devtools/reporter.py",
    "PROJECT_STATUS.json",
    "conf/settings.ini",
    "data/reports/**/*.md"
  ],
  "stub": [
    "README.md",
    "devtools/pm.py",
    "devtools/installer.py",
    "devtools/snapshot.py",
    "bin/**"
  ],
  "omit": [
    "snapshots/**",
    "project_context*.txt",
    "**/*.swp",
    "**/*.log",
    "**/.env*",
    "**/*.png",
    "**/*.pdf"
  ],
  "options": {
    "max_file_bytes": 120000,
    "max_total_bytes": 900000,
    "inventory_limit": 300,
    "include_tree": true,
    "include_env": true,
    "include_git": true,
    "include_registry_summary": true,
    "include_import_graph": true,
    "include_status": true
  }
}
```

### File: conf/samples/parse_other_data.json
- mode: full
- size_bytes: 2204
- sha256_12: 6091b29bdccc

```json
{
  "name": "parse_other_data",
  "description": "Samples for expanding analyzer beyond prefab/recipe: STRINGS, Widgets, Brains, Stategraphs, LootTables, Components.",
  "limits": {
    "max_total_chars": 260000,
    "max_chars_per_file": 18000
  },
  "defaults": {
    "head_lines": 120,
    "snippet_blocks": 10,
    "context_lines": 4
  },
  "categories": [
    {
      "name": "STRINGS",
      "pick_n": 2,
      "candidate_globs": ["scripts/strings.lua", "scripts/*strings*.lua", "scripts/strings_pretranslated.lua"],
      "rank_patterns": ["\\bSTRINGS\\s*=", "\\bSTRINGS\\.[A-Z0-9_]+"],
      "snippet_patterns": ["\\bSTRINGS\\.[A-Z0-9_]+\\s*=", "\\bSTRINGS\\.[A-Z0-9_]+"]
    },
    {
      "name": "Widgets",
      "pick_n": 2,
      "candidate_globs": ["scripts/widgets/**/*.lua", "scripts/screens/**/*.lua"],
      "rank_patterns": ["require\\s*\\(?\\s*[\"']widgets/", "Class\\("],
      "snippet_patterns": ["require\\s*\\(?\\s*[\"']widgets/", "Class\\(", "Widget\\("]
    },
    {
      "name": "Brains",
      "pick_n": 2,
      "candidate_globs": ["scripts/prefabs/**/*.lua", "scripts/brains/**/*.lua"],
      "rank_patterns": ["require\\s*\\(?\\s*[\"']brains/", "SetBrain\\s*\\("],
      "snippet_patterns": ["require\\s*\\(?\\s*[\"']brains/", "SetBrain\\s*\\("]
    },
    {
      "name": "Stategraphs",
      "pick_n": 2,
      "candidate_globs": ["scripts/stategraphs/**/*.lua"],
      "rank_patterns": ["StateGraph\\(", "ActionHandler\\("],
      "snippet_patterns": ["StateGraph\\(", "ActionHandler\\(", "EventHandler\\("]
    },
    {
      "name": "LootTables",
      "pick_n": 2,
      "candidate_globs": ["scripts/prefabs/**/*.lua", "scripts/components/lootdropper.lua"],
      "rank_patterns": ["SetLoot\\s*\\(", "SetChanceLoot\\s*\\(", "AddChanceLoot\\s*\\("],
      "snippet_patterns": ["SetLoot\\s*\\(", "SetChanceLoot\\s*\\(", "AddChanceLoot\\s*\\(", "DropLoot\\s*\\("]
    },
    {
      "name": "Components",
      "pick_n": 2,
      "candidate_globs": ["scripts/components/**/*.lua"],
      "rank_patterns": ["\\bClass\\(", "\\bfunction\\s+[A-Za-z0-9_]+:"],
      "snippet_patterns": ["\\bClass\\(", "\\bfunction\\s+[A-Za-z0-9_]+:"],
      "head_lines": 200
    }
  ]
}
```

### File: conf/settings.ini
- mode: full
- size_bytes: 353
- sha256_12: 15952c921af7

```toml
[PATHS]
# æ¸¸æˆå®‰è£…ç›®å½•
DST_ROOT = ~/dontstarvetogether_dedicated_server
# SteamCMD ç›®å½•
STEAMCMD_DIR = ~/steamcmd
# å¤‡ä»½å­˜æ”¾ç›®å½•
BACKUP_DIR = ~/dst_backups

[SERVER]
# ä½ çš„å­˜æ¡£æ–‡ä»¶å¤¹å (Cluster Name)
CLUSTER_NAME = MyDediServer
# Klei å­˜æ¡£æ ¹ç›®å½• (é€šå¸¸æ˜¯ ~/.klei/DoNotStarveTogether)
KLEI_HOME = ~/.klei/DoNotStarveTogether
```

### File: conf/snapshot_profile.json
- mode: full
- size_bytes: 887
- sha256_12: fe118abc74ab

```json
{
  "name": "analyzer-focus",
  "default_action": "omit",
  "full": [
    "src/analyzer.py",
    "src/engine.py",
    "src/explorer.py",
    "src/wiki.py",
    "src/utils.py",
    "src/registry.py",
    "tests/**/*.py",
    "devtools/reporter.py",
    "PROJECT_STATUS.json",
    "conf/settings.ini",
    "data/reports/**/*.md"
  ],
  "stub": [
    "README.md",
    "devtools/pm.py",
    "devtools/installer.py",
    "devtools/snapshot.py",
    "bin/**"
  ],
  "omit": [
    "snapshots/**",
    "project_context*.txt",
    "**/*.swp",
    "**/*.log",
    "**/.env*",
    "**/*.png",
    "**/*.pdf"
  ],
  "options": {
    "max_file_bytes": 120000,
    "max_total_bytes": 900000,
    "inventory_limit": 300,
    "include_tree": true,
    "include_env": true,
    "include_git": true,
    "include_registry_summary": true,
    "include_import_graph": true,
    "include_status": true
  }
}
```

### File: data/reports/asset_registry.md
- mode: full
- size_bytes: 2096
- sha256_12: 45c762a51673

```md
# Wagstaff Asset Registry

| Category | Total Definitions | Top File |
|----------|-------------------|----------|
| Prefabs | 2381 | `scripts/prefabs/meats.lua` |
| Widgets | 2096 | `scripts/widgets/controls.lua` |
| LootTables | 183 | `scripts/prefabs/deciduoustrees.lua` |
| Brains | 103 | `scripts/prefabs/pigman.lua` |
| STRINGS | 45 | `scripts/strings.lua` |

## Detailed Breakdown

### Prefabs
- `scripts/prefabs/meats.lua`: 30
- `scripts/prefabs/boat.lua`: 19
- `scripts/prefabs/rocks.lua`: 13
- `scripts/prefabs/archive_props.lua`: 13
- `scripts/prefabs/explode_small.lua`: 10
- `scripts/prefabs/staff.lua`: 9
- `scripts/prefabs/planted_tree.lua`: 8
- `scripts/prefabs/hound.lua`: 8
- `scripts/prefabs/wagstaff_npc.lua`: 8
- `scripts/prefabs/spider.lua`: 8

### Widgets
- `scripts/widgets/controls.lua`: 35
- `scripts/screens/playerhud.lua`: 32
- `scripts/screens/lobbyscreen.lua`: 16
- `scripts/screens/multiplayermainscreen.lua`: 15
- `scripts/widgets/redux/templates.lua`: 14
- `scripts/widgets/statusdisplays.lua`: 14
- `scripts/screens/serverlistingscreen.lua`: 14
- `scripts/screens/redux/multiplayermainscreen.lua`: 14
- `scripts/screens/servercreationscreen.lua`: 14
- `scripts/screens/modconfigurationscreen.lua`: 13

### LootTables
- `scripts/prefabs/deciduoustrees.lua`: 7
- `scripts/prefabs/evergreens.lua`: 7
- `scripts/prefabs/moon_altar.lua`: 6
- `scripts/prefabs/farm_plants.lua`: 5
- `scripts/prefabs/merm.lua`: 4
- `scripts/prefabs/veggies.lua`: 4
- `scripts/prefabs/perdshrine.lua`: 4
- `scripts/prefabs/pigman.lua`: 4
- `scripts/prefabs/monkey.lua`: 4
- `scripts/prefabs/oceantree.lua`: 4

### Brains
- `scripts/prefabs/pigman.lua`: 4
- `scripts/prefabs/merm.lua`: 2
- `scripts/prefabs/wobster.lua`: 2
- `scripts/brains/wobysmallbrain.lua`: 2
- `scripts/prefabs/ghost.lua`: 2
- `scripts/prefabs/slurtle.lua`: 2
- `scripts/prefabs/spider.lua`: 2
- `scripts/prefabs/monkey.lua`: 2
- `scripts/brains/catcoonbrain.lua`: 1
- `scripts/brains/pigbrain.lua`: 1

### STRINGS
- `scripts/strings.lua`: 37
- `scripts/skin_strings.lua`: 7
- `scripts/strings_pretranslated.lua`: 1
```

### File: data/reports/dst_codemap.json
- mode: full
- size_bytes: 9771
- sha256_12: 641dac300b3e

```json
{
  "generated": "2026-01-13T14:15:05+08:00",
  "engine_mode": "zip",
  "total_files": 3915,
  "lua_files": 3901,
  "categories": {
    "Prefabs": 1533,
    "Components": 782,
    "Stategraphs": 250,
    "Brains": 184,
    "Behaviours": 28,
    "Widgets": 268,
    "Screens": 134,
    "Strings": 9,
    "Recipes": 2,
    "Tuning": 1
  },
  "top_dirs": [
    {
      "dir": "prefabs",
      "count": 1533
    },
    {
      "dir": "components",
      "count": 782
    },
    {
      "dir": "map",
      "count": 444
    },
    {
      "dir": "widgets",
      "count": 268
    },
    {
      "dir": "stategraphs",
      "count": 250
    },
    {
      "dir": "[Root]",
      "count": 214
    },
    {
      "dir": "brains",
      "count": 184
    },
    {
      "dir": "screens",
      "count": 134
    },
    {
      "dir": "scenarios",
      "count": 50
    },
    {
      "dir": "behaviours",
      "count": 28
    },
    {
      "dir": "util",
      "count": 7
    },
    {
      "dir": "languages",
      "count": 2
    },
    {
      "dir": "tools",
      "count": 2
    },
    {
      "dir": "nis",
      "count": 2
    },
    {
      "dir": "cameras",
      "count": 1
    }
  ],
  "top_second_level": [
    {
      "dir": "map/static_layouts",
      "count": 340
    },
    {
      "dir": "widgets/redux",
      "count": 88
    },
    {
      "dir": "screens/redux",
      "count": 71
    },
    {
      "dir": "map/rooms",
      "count": 42
    },
    {
      "dir": "map/tasks",
      "count": 10
    },
    {
      "dir": "map/tasksets",
      "count": 4
    },
    {
      "dir": "map/levels",
      "count": 4
    },
    {
      "dir": "components/digester.lua",
      "count": 1
    },
    {
      "dir": "prefabs/reviver_cupid_beat_fx.lua",
      "count": 1
    },
    {
      "dir": "prefabs/structure_collapse_fx.lua",
      "count": 1
    },
    {
      "dir": "components/cookbookupdater.lua",
      "count": 1
    },
    {
      "dir": "prefabs/cutreeds.lua",
      "count": 1
    },
    {
      "dir": "prefabs/hermitcrab_relocation_kit.lua",
      "count": 1
    },
    {
      "dir": "components/vanish_on_sleep.lua",
      "count": 1
    },
    {
      "dir": "map/placement.lua",
      "count": 1
    },
    {
      "dir": "prefabs/yotd_boats.lua",
      "count": 1
    },
    {
      "dir": "prefabs/mushtree_webbed.lua",
      "count": 1
    },
    {
      "dir": "components/flotationdevice.lua",
      "count": 1
    },
    {
      "dir": "brains/spatbrain.lua",
      "count": 1
    },
    {
      "dir": "prefabs/chum.lua",
      "count": 1
    },
    {
      "dir": "widgets/listcursor.lua",
      "count": 1
    },
    {
      "dir": "components/wintertreegiftable.lua",
      "count": 1
    },
    {
      "dir": "components/projectedeffects.lua",
      "count": 1
    },
    {
      "dir": "prefabs/shadowchesspieces.lua",
      "count": 1
    },
    {
      "dir": "prefabs/monkeyhut.lua",
      "count": 1
    },
    {
      "dir": "prefabs/boat_leak.lua",
      "count": 1
    },
    {
      "dir": "map/settings.lua",
      "count": 1
    },
    {
      "dir": "components/pocketwatch.lua",
      "count": 1
    },
    {
      "dir": "components/shard_players.lua",
      "count": 1
    },
    {
      "dir": "components/winonateleportpadmanager.lua",
      "count": 1
    },
    {
      "dir": "prefabs/canopyshadows.lua",
      "count": 1
    },
    {
      "dir": "prefabs/alterguardian_lunar_fissures.lua",
      "count": 1
    },
    {
      "dir": "prefabs/hitsparks_fx.lua",
      "count": 1
    },
    {
      "dir": "stategraphs/SGwilson.lua",
      "count": 1
    },
    {
      "dir": "brains/catcoonbrain.lua",
      "count": 1
    },
    {
      "dir": "brains/krampusbrain.lua",
      "count": 1
    },
    {
      "dir": "components/furnituredecor.lua",
      "count": 1
    },
    {
      "dir": "scenarios/chest_ghosts.lua",
      "count": 1
    },
    {
      "dir": "prefabs/atrium_gate_pulsesfx.lua",
      "count": 1
    },
    {
      "dir": "components/klaussackkey.lua",
      "count": 1
    },
    {
      "dir": "brains/rockybrain.lua",
      "count": 1
    },
    {
      "dir": "prefabs/quagmire_parkspike.lua",
      "count": 1
    },
    {
      "dir": "map/caves_retrofit_land.lua",
      "count": 1
    },
    {
      "dir": "widgets/inventorybar.lua",
      "count": 1
    },
    {
      "dir": "components/moistureabsorberuser.lua",
      "count": 1
    },
    {
      "dir": "components/yotc_racestats.lua",
      "count": 1
    },
    {
      "dir": "stategraphs/SGgnarwail.lua",
      "count": 1
    },
    {
      "dir": "prefabs/ancienttrees.lua",
      "count": 1
    },
    {
      "dir": "widgets/nineslice.lua",
      "count": 1
    },
    {
      "dir": "scenarios/icebox_summer.lua",
      "count": 1
    },
    {
      "dir": "components/constructionbuilderuidata.lua",
      "count": 1
    },
    {
      "dir": "components/boatphysics.lua",
      "count": 1
    },
    {
      "dir": "prefabs/carpentry_station.lua",
      "count": 1
    },
    {
      "dir": "prefabs/rope.lua",
      "count": 1
    },
    {
      "dir": "prefabs/gelblob_attach_fx.lua",
      "count": 1
    },
    {
      "dir": "components/areaaware.lua",
      "count": 1
    },
    {
      "dir": "prefabs/lavaarena_fossilizing.lua",
      "count": 1
    },
    {
      "dir": "brains/wagdrone_rollingbrain.lua",
      "count": 1
    },
    {
      "dir": "brains/hostedbrain.lua",
      "count": 1
    },
    {
      "dir": "prefabs/eyeflame.lua",
      "count": 1
    }
  ],
  "largest_lua_files": [
    {
      "path": "scripts/map/static_layouts/maxwellhome.lua",
      "bytes": 1171726
    },
    {
      "path": "scripts/stategraphs/SGwilson.lua",
      "bytes": 903189
    },
    {
      "path": "scripts/strings.lua",
      "bytes": 801652
    },
    {
      "path": "scripts/skins_defs_data.lua",
      "bytes": 739739
    },
    {
      "path": "scripts/prefabs/skinprefabs.lua",
      "bytes": 611329
    },
    {
      "path": "scripts/screens/redux/scrapbookdata.lua",
      "bytes": 552781
    },
    {
      "path": "scripts/skin_strings.lua",
      "bytes": 545013
    },
    {
      "path": "scripts/skin_assets.lua",
      "bytes": 523437
    },
    {
      "path": "scripts/misc_items.lua",
      "bytes": 426198
    },
    {
      "path": "scripts/clothing.lua",
      "bytes": 368314
    },
    {
      "path": "scripts/tuning.lua",
      "bytes": 306452
    },
    {
      "path": "scripts/speech_wanda.lua",
      "bytes": 286689
    },
    {
      "path": "scripts/speech_wickerbottom.lua",
      "bytes": 281552
    },
    {
      "path": "scripts/speech_walter.lua",
      "bytes": 275465
    },
    {
      "path": "scripts/speech_warly.lua",
      "bytes": 264555
    },
    {
      "path": "scripts/speech_wortox.lua",
      "bytes": 259859
    },
    {
      "path": "scripts/speech_winona.lua",
      "bytes": 256407
    },
    {
      "path": "scripts/speech_wendy.lua",
      "bytes": 255887
    },
    {
      "path": "scripts/speech_wathgrithr.lua",
      "bytes": 255692
    },
    {
      "path": "scripts/speech_waxwell.lua",
      "bytes": 252497
    },
    {
      "path": "scripts/speech_woodie.lua",
      "bytes": 252369
    },
    {
      "path": "scripts/speech_willow.lua",
      "bytes": 250964
    },
    {
      "path": "scripts/actions.lua",
      "bytes": 247992
    },
    {
      "path": "scripts/prefabs/hats.lua",
      "bytes": 246091
    },
    {
      "path": "scripts/speech_wolfgang.lua",
      "bytes": 242983
    },
    {
      "path": "scripts/stategraphs/SGwilson_client.lua",
      "bytes": 242649
    },
    {
      "path": "scripts/speech_webber.lua",
      "bytes": 241929
    },
    {
      "path": "scripts/speech_wilson.lua",
      "bytes": 241665
    },
    {
      "path": "scripts/speech_wx78.lua",
      "bytes": 239019
    },
    {
      "path": "scripts/speech_wurt.lua",
      "bytes": 224456
    },
    {
      "path": "scripts/components/playercontroller.lua",
      "bytes": 217095
    },
    {
      "path": "scripts/speech_wormwood.lua",
      "bytes": 196301
    },
    {
      "path": "scripts/recipes.lua",
      "bytes": 185684
    },
    {
      "path": "scripts/stategraphs/SGhermitcrab.lua",
      "bytes": 182595
    },
    {
      "path": "scripts/map/static_layouts/retrofit_moonisland_large.lua",
      "bytes": 171774
    },
    {
      "path": "scripts/debugcommands.lua",
      "bytes": 147903
    },
    {
      "path": "scripts/map/static_layouts/events/quagmire_kitchen.lua",
      "bytes": 147606
    },
    {
      "path": "scripts/prefabskin.lua",
      "bytes": 142184
    },
    {
      "path": "scripts/componentactions.lua",
      "bytes": 132106
    },
    {
      "path": "scripts/worldsettings_overrides.lua",
      "bytes": 130139
    },
    {
      "path": "scripts/screens/redux/optionsscreen.lua",
      "bytes": 126378
    },
    {
      "path": "scripts/map/static_layouts/monkeyisland_retrofitlarge_01.lua",
      "bytes": 123015
    },
    {
      "path": "scripts/fx.lua",
      "bytes": 116026
    },
    {
      "path": "scripts/prefabs/player_common.lua",
      "bytes": 112931
    },
    {
      "path": "scripts/screens/redux/serverlistingscreen.lua",
      "bytes": 111828
    },
    {
      "path": "scripts/map/static_layouts/monkeyisland_retrofitlarge_02.lua",
      "bytes": 105089
    },
    {
      "path": "scripts/screens/serverlistingscreen.lua",
      "bytes": 104807
    },
    {
      "path": "scripts/map/static_layouts/events/lava_arena.lua",
      "bytes": 100927
    },
    {
      "path": "scripts/stategraphs/commonstates.lua",
      "bytes": 91814
    },
    {
      "path": "scripts/map/static_layouts/retrofit_moonisland_medium.lua",
      "bytes": 91154
    }
  ]
}
```

### File: data/reports/dst_codemap.md
- mode: full
- size_bytes: 5196
- sha256_12: bb7f66b78652

```md
# DST Scripts Code Map

## Meta
```yaml
generated: 2026-01-13T14:15:05+08:00
engine_mode: zip
total_files: 3915
lua_files: 3901
```

## Category Counts

| Category | Count |
|---|---:|
| Behaviours | 28 |
| Brains | 184 |
| Components | 782 |
| Prefabs | 1533 |
| Recipes | 2 |
| Screens | 134 |
| Stategraphs | 250 |
| Strings | 9 |
| Tuning | 1 |
| Widgets | 268 |

## Top Directories (Lua)

| Dir | Files |
|---|---:|
| prefabs | 1533 |
| components | 782 |
| map | 444 |
| widgets | 268 |
| stategraphs | 250 |
| [Root] | 214 |
| brains | 184 |
| screens | 134 |
| scenarios | 50 |
| behaviours | 28 |
| util | 7 |
| languages | 2 |
| tools | 2 |
| nis | 2 |
| cameras | 1 |

## Hotspots: Largest Lua Files

| Bytes | Path |
|---:|---|
| 1171726 | `scripts/map/static_layouts/maxwellhome.lua` |
| 903189 | `scripts/stategraphs/SGwilson.lua` |
| 801652 | `scripts/strings.lua` |
| 739739 | `scripts/skins_defs_data.lua` |
| 611329 | `scripts/prefabs/skinprefabs.lua` |
| 552781 | `scripts/screens/redux/scrapbookdata.lua` |
| 545013 | `scripts/skin_strings.lua` |
| 523437 | `scripts/skin_assets.lua` |
| 426198 | `scripts/misc_items.lua` |
| 368314 | `scripts/clothing.lua` |
| 306452 | `scripts/tuning.lua` |
| 286689 | `scripts/speech_wanda.lua` |
| 281552 | `scripts/speech_wickerbottom.lua` |
| 275465 | `scripts/speech_walter.lua` |
| 264555 | `scripts/speech_warly.lua` |
| 259859 | `scripts/speech_wortox.lua` |
| 256407 | `scripts/speech_winona.lua` |
| 255887 | `scripts/speech_wendy.lua` |
| 255692 | `scripts/speech_wathgrithr.lua` |
| 252497 | `scripts/speech_waxwell.lua` |
| 252369 | `scripts/speech_woodie.lua` |
| 250964 | `scripts/speech_willow.lua` |
| 247992 | `scripts/actions.lua` |
| 246091 | `scripts/prefabs/hats.lua` |
| 242983 | `scripts/speech_wolfgang.lua` |
| 242649 | `scripts/stategraphs/SGwilson_client.lua` |
| 241929 | `scripts/speech_webber.lua` |
| 241665 | `scripts/speech_wilson.lua` |
| 239019 | `scripts/speech_wx78.lua` |
| 224456 | `scripts/speech_wurt.lua` |
| 217095 | `scripts/components/playercontroller.lua` |
| 196301 | `scripts/speech_wormwood.lua` |
| 185684 | `scripts/recipes.lua` |
| 182595 | `scripts/stategraphs/SGhermitcrab.lua` |
| 171774 | `scripts/map/static_layouts/retrofit_moonisland_large.lua` |
| 147903 | `scripts/debugcommands.lua` |
| 147606 | `scripts/map/static_layouts/events/quagmire_kitchen.lua` |
| 142184 | `scripts/prefabskin.lua` |
| 132106 | `scripts/componentactions.lua` |
| 130139 | `scripts/worldsettings_overrides.lua` |
| 126378 | `scripts/screens/redux/optionsscreen.lua` |
| 123015 | `scripts/map/static_layouts/monkeyisland_retrofitlarge_01.lua` |
| 116026 | `scripts/fx.lua` |
| 112931 | `scripts/prefabs/player_common.lua` |
| 111828 | `scripts/screens/redux/serverlistingscreen.lua` |
| 105089 | `scripts/map/static_layouts/monkeyisland_retrofitlarge_02.lua` |
| 104807 | `scripts/screens/serverlistingscreen.lua` |
| 100927 | `scripts/map/static_layouts/events/lava_arena.lua` |
| 91814 | `scripts/stategraphs/commonstates.lua` |
| 91154 | `scripts/map/static_layouts/retrofit_moonisland_medium.lua` |

## Top 2nd-level Directories

| Dir | Files |
|---|---:|
| map/static_layouts | 340 |
| widgets/redux | 88 |
| screens/redux | 71 |
| map/rooms | 42 |
| map/tasks | 10 |
| map/tasksets | 4 |
| map/levels | 4 |
| components/digester.lua | 1 |
| prefabs/reviver_cupid_beat_fx.lua | 1 |
| prefabs/structure_collapse_fx.lua | 1 |
| components/cookbookupdater.lua | 1 |
| prefabs/cutreeds.lua | 1 |
| prefabs/hermitcrab_relocation_kit.lua | 1 |
| components/vanish_on_sleep.lua | 1 |
| map/placement.lua | 1 |
| prefabs/yotd_boats.lua | 1 |
| prefabs/mushtree_webbed.lua | 1 |
| components/flotationdevice.lua | 1 |
| brains/spatbrain.lua | 1 |
| prefabs/chum.lua | 1 |
| widgets/listcursor.lua | 1 |
| components/wintertreegiftable.lua | 1 |
| components/projectedeffects.lua | 1 |
| prefabs/shadowchesspieces.lua | 1 |
| prefabs/monkeyhut.lua | 1 |
| prefabs/boat_leak.lua | 1 |
| map/settings.lua | 1 |
| components/pocketwatch.lua | 1 |
| components/shard_players.lua | 1 |
| components/winonateleportpadmanager.lua | 1 |
| prefabs/canopyshadows.lua | 1 |
| prefabs/alterguardian_lunar_fissures.lua | 1 |
| prefabs/hitsparks_fx.lua | 1 |
| stategraphs/SGwilson.lua | 1 |
| brains/catcoonbrain.lua | 1 |
| brains/krampusbrain.lua | 1 |
| components/furnituredecor.lua | 1 |
| scenarios/chest_ghosts.lua | 1 |
| prefabs/atrium_gate_pulsesfx.lua | 1 |
| components/klaussackkey.lua | 1 |
| brains/rockybrain.lua | 1 |
| prefabs/quagmire_parkspike.lua | 1 |
| map/caves_retrofit_land.lua | 1 |
| widgets/inventorybar.lua | 1 |
| components/moistureabsorberuser.lua | 1 |
| components/yotc_racestats.lua | 1 |
| stategraphs/SGgnarwail.lua | 1 |
| prefabs/ancienttrees.lua | 1 |
| widgets/nineslice.lua | 1 |
| scenarios/icebox_summer.lua | 1 |
| components/constructionbuilderuidata.lua | 1 |
| components/boatphysics.lua | 1 |
| prefabs/carpentry_station.lua | 1 |
| prefabs/rope.lua | 1 |
| prefabs/gelblob_attach_fx.lua | 1 |
| components/areaaware.lua | 1 |
| prefabs/lavaarena_fossilizing.lua | 1 |
| brains/wagdrone_rollingbrain.lua | 1 |
| brains/hostedbrain.lua | 1 |
| prefabs/eyeflame.lua | 1 |
```

### File: data/reports/recipe_distribution.md
- mode: full
- size_bytes: 1655
- sha256_12: e177df3496c5

```md
# Wagstaff Recipe Distribution

## Function Usage
- **Recipe2**: 881
- **DeconstructRecipe**: 111
- **Recipe**: 56
- **DoRecipeClick**: 11
- **AddCookerRecipe**: 9
- **SetRecipeUnlocked**: 4
- **ClearAllUnlockedRecipes**: 3
- **UpdateRecipes**: 2
- **OnRecipeDirty**: 2
- **SetRecipe**: 2
- **SetupRecipeIngredientDetails**: 1
- **AddRecipeCard**: 1
- **TestRecipes**: 1
- **RemoveAllRecipes**: 1
- **CanBlueprintRandomRecipe**: 1
- **CleanupDupRecipes**: 1
- **IsRecipeValidForFilter**: 1
- **IsRecipeValidForStation**: 1
- **DeclareLimitedCraftingRecipe**: 1
- **ShouldHintRecipe**: 1
- **PickRandomRecipe**: 1

## File Hotspots (Top 20)
- `scripts/recipes.lua`: 997 recipes
- `scripts/prefabs/quagmire.lua`: 52 recipes
- `scripts/cooking.lua`: 10 recipes
- `scripts/prefabs/hermithouse.lua`: 7 recipes
- `scripts/widgets/redux/craftingmenu_widget.lua`: 3 recipes
- `scripts/prefabs/cookingrecipecard.lua`: 3 recipes
- `scripts/prefabs/hermitcrab_teashop.lua`: 2 recipes
- `scripts/widgets/recipepopup.lua`: 2 recipes
- `scripts/widgets/redux/craftingmenu_pinslot.lua`: 2 recipes
- `scripts/widgets/redux/quagmire_recipebook.lua`: 1 recipes
- `scripts/widgets/controllercrafting_singletab.lua`: 1 recipes
- `scripts/components/quagmire_recipeprices.lua`: 1 recipes
- `scripts/modutil.lua`: 1 recipes
- `scripts/widgets/ingredientui.lua`: 1 recipes
- `scripts/components/quagmire_recipebook.lua`: 1 recipes
- `scripts/prefabs/blueprint.lua`: 1 recipes
- `scripts/widgets/controllercrafting.lua`: 1 recipes
- `scripts/widgets/craftslot.lua`: 1 recipes
- `scripts/quagmire_recipebook.lua`: 1 recipes
- `scripts/widgets/quagmire_recipepopup.lua`: 1 recipes
```

### File: data/samples/samples_20260113_105500.manifest.json
- mode: full
- size_bytes: 3455
- sha256_12: eb55230ae2c1

```json
{
  "generated": "2026-01-13T10:55:01+08:00",
  "engine_mode": "zip",
  "categories": [
    "STRINGS",
    "Widgets",
    "Brains",
    "Stategraphs",
    "LootTables",
    "Components"
  ],
  "chosen": {
    "STRINGS": [
      "scripts/strings.lua",
      "scripts/skin_strings.lua"
    ],
    "Widgets": [
      "scripts/widgets/controls.lua",
      "scripts/screens/playerhud.lua"
    ],
    "Brains": [
      "scripts/prefabs/pigman.lua",
      "scripts/prefabs/merm.lua"
    ],
    "Stategraphs": [
      "scripts/stategraphs/SGwilson.lua",
      "scripts/stategraphs/SGwilson_client.lua"
    ],
    "LootTables": [
      "scripts/prefabs/deciduoustrees.lua",
      "scripts/prefabs/evergreens.lua"
    ],
    "Components": [
      "scripts/components/scenariorunner.lua",
      "scripts/components/debuffable.lua"
    ]
  },
  "files": {
    "STRINGS": [
      {
        "path": "scripts/strings.lua",
        "sha256_12": "c473909148f0",
        "lines": 18126,
        "head_lines": 120,
        "snippet_blocks": 10
      },
      {
        "path": "scripts/skin_strings.lua",
        "sha256_12": "360fcf894f0c",
        "lines": 8463,
        "head_lines": 120,
        "snippet_blocks": 7
      }
    ],
    "Widgets": [
      {
        "path": "scripts/widgets/controls.lua",
        "sha256_12": "3e6ac904ac9c",
        "lines": 1143,
        "head_lines": 120,
        "snippet_blocks": 2
      },
      {
        "path": "scripts/screens/playerhud.lua",
        "sha256_12": "929f8f93ad2b",
        "lines": 1738,
        "head_lines": 120,
        "snippet_blocks": 4
      }
    ],
    "Brains": [
      {
        "path": "scripts/prefabs/pigman.lua",
        "sha256_12": "057ce3dc07e5",
        "lines": 861,
        "head_lines": 120,
        "snippet_blocks": 4
      },
      {
        "path": "scripts/prefabs/merm.lua",
        "sha256_12": "9318b5254591",
        "lines": 1658,
        "head_lines": 120,
        "snippet_blocks": 1
      }
    ],
    "Stategraphs": [
      {
        "path": "scripts/stategraphs/SGwilson.lua",
        "sha256_12": "a4dc61624beb",
        "lines": 25875,
        "head_lines": 120,
        "snippet_blocks": 10
      },
      {
        "path": "scripts/stategraphs/SGwilson_client.lua",
        "sha256_12": "348ab359e83b",
        "lines": 7327,
        "head_lines": 120,
        "snippet_blocks": 10
      }
    ],
    "LootTables": [
      {
        "path": "scripts/prefabs/deciduoustrees.lua",
        "sha256_12": "abeb7b437c95",
        "lines": 1458,
        "head_lines": 120,
        "snippet_blocks": 10
      },
      {
        "path": "scripts/prefabs/evergreens.lua",
        "sha256_12": "bfdc4b4c2c58",
        "lines": 993,
        "head_lines": 120,
        "snippet_blocks": 10
      }
    ],
    "Components": [
      {
        "path": "scripts/components/scenariorunner.lua",
        "sha256_12": "113cd7848f23",
        "lines": 64,
        "head_lines": 64,
        "snippet_blocks": 3
      },
      {
        "path": "scripts/components/debuffable.lua",
        "sha256_12": "6b54db69ec53",
        "lines": 174,
        "head_lines": 120,
        "snippet_blocks": 4
      }
    ]
  },
  "source_reports": {
    "asset_registry": "/home/steam/Wagstaff-Lab/data/reports/asset_registry.md",
    "recipe_distribution": "/home/steam/Wagstaff-Lab/data/reports/recipe_distribution.md"
  },
  "limits": {
    "max_chars_per_file": 18000,
    "max_total_chars": 260000
  }
}
```

### File: data/samples/samples_20260113_105500.md
- mode: full
- size_bytes: 98207
- sha256_12: 62a18d214507

```md
# Wagstaff-Lab Lua Sample Pack

## Meta
```yaml
generated: 2026-01-13T10:55:00+08:00
engine_mode: zip
categories: ['STRINGS', 'Widgets', 'Brains', 'Stategraphs', 'LootTables', 'Components']
n_files_per_category: 2
head_lines: 120
snippet_blocks: 10
context_lines: 4
```

## Category: STRINGS

### File: scripts/strings.lua
> sha256_12=c473909148f0, lines=18126

#### Head
```lua
--[[

***************************************************************
*** NOTICE TO TRANSLATORS: DO NOT EDIT THIS FILE DIRECTLY! ***

We have provided a standard PO file to translation in /scripts/languages/strings.pot
To add a new language:
- Use a PO editor such as POEdit (http://www.poedit.net/) to tranmslate strings.pot
- Load your own PO file under /scripts/languages/language.lua

***************************************************************
]]

--[[
***************************************************************
-- Note for developers to keep the .pot file up to date
-- 1. Open cmd and navigate to the data\scripts folder
-- 2. Enter "..\..\tools\LUA\lua.exe createstringspo.lua" (without quotes) into the cmd line and press return
***************************************************************
]]

--[[
***************************************************************
**                   DST UTF-8 formatting                    **
- Unicode characters can be added to this file in a UTF-8 format.
- For the custom font characters, the unicode private use area of U+E000 to U+F8FF is being used.
- For the emoji font characters, we use the unicode private use area of U+F0000 to U+FFFFD.

- The first digit must be 238, 239, or 243
  - 238 will be used for all controller buttons
  - 239 will be used for non-controller buttons
  - 243 is reserved for emoji
- The second digit can be from 128 to 191, inclusive
  - XBox:				128 to 131		0x80-0x83
  - PC Mouse:			132 to 135		0x84-0x87
  - DualShock4 on PC:	136 to 139		0x88-0x8B
  - PS4:				140 to 143		0x8A-0x8D
  - Switch:             144 to 147      0x90-0x93
  - DualSense:          148 to 151		0x94-0x97
- The third digit can be from 128 to 191, inclusive
  - no reserved meanings
***************************************************************
]]

local stageactor = require("strings_stageactor")

STRINGS =
{
	PSN = "PlayStationâ„¢Network",

    CHARACTER_NAMES =
    {
        wilson = "Wilson P. Higgsbury",
        willow = "Willow",
        wendy = "Wendy",
        wolfgang = "Wolfgang",
        woodie = "Woodie",
        wickerbottom = "Ms. Wickerbottom",
        wx78 = "WX-78",
        wes = "Wes",
        waxwell = "Maxwell",
        wathgrithr = "Wigfrid",
        webber = "Webber",
        winona = "Winona",
        wortox = "Wortox",
        wormwood = "Wormwood",
        warly = "Warly",
        wurt = "Wurt",
        walter = "Walter",
        wanda = "Wanda",
        wonkey = "Wonkey",
        unknown = "The Unknown",
        random = "Random",
    },


    CHARACTER_QUOTES =
    {
        wilson = "\"I'll conquer this world with the power of my MIND!\"",
        willow = "\"All will bathe in the prettiest of flames.\"",
        woodie = "\"That's a nice lookin' tree, eh? Not for long.\"",
        wendy ="\"Abigail? Come back! I'm not done playing with you.\"",
        wolfgang = "\"I am mighty! No one is mightier!\"",
        wx78 = "\"EMPATHY MODULE NOT RESPONDING\"",
        wickerbottom = "\"Shhhh! No talking!\"",
        waxwell = "\"Freedom suits me.\"",
        wes = "...",
        wathgrithr = "\"All the wÃ¶rld's a stage. FÃ¶r me!\"",
        webber = "\"We're always together, and never alone!\"",
        winona = "\"Anything can be fixed with hard work and elbow grease.\"",
        wortox = "\"Pardon me if I don't shake your hand.\"",
        wormwood = "\"Hello friend?\"",
        warly = "\"Nothing worthwhile is ever done on an empty stomach!\"",
        wurt = "\"Mermfolk known for hos-per-tality, florp.\"",
        walter = "\"A Pinetree Pioneer is always prepared!\"",
        wanda = "\"Time! I just need more time!\"",
        wonkey = "\"Ook OOK!\"",
        random = "Anybody could be under that hat.",
    },

    CHARACTER_TITLES =
    {
        wilson = "The Gentleman Scientist",
        willow = "The Firestarter",
        wendy = "The Bereaved",
        woodie = "The Lumberjack",
        wolfgang = "The Strongman",
        wx78 = "The Soulless Automaton",
        wickerbottom = "The Librarian",
        wes = "The Silent",
        waxwell = "The Puppet Master",
        wathgrithr = "The Performance Artist",
        webber = "The Indigestible",
        winona = "The Handywoman",
        wortox = "The Soul Starved",
        wormwood = "The Lonesome",
        warly = "The Culinarian",
        wurt = "The Half-Pint",
        walter = "The Fearless",
        wanda = "The Timekeeper",
```

#### Snippets (line-numbered)

**Snippet 1**
```lua
 8114:         "Nice trade! Let's keep it goin'!",
 8115:     },
 8116: }
 8117: 
 8118: STRINGS.BUNNYMANNAMES =
 8119: {
 8120:     "Brassica",
 8121:     "Bunium",
 8122:     "Burdock",
```

**Snippet 2**
```lua
 8190:     "Ytterbia",
 8191:     "Lutetium",
 8192: }
 8193: 
 8194: STRINGS.PIGNAMES =
 8195: {
 8196:     --emperors
 8197:     "Augustus",
 8198:     "Tiberius",
```

**Snippet 3**
```lua
 8347:     "Smelly",
 8348:     "Salty",
 8349: }
 8350: 
 8351: STRINGS.SWAMPIGNAMES =
 8352: {
 8353:     --farmers
 8354:     "Titus",
 8355:     "Domitian",
```

**Snippet 4**
```lua
 8373:     "Pupienus",
 8374:     "Balbinus",
 8375: }
 8376: 
 8377: STRINGS.CROWNAMES =
 8378: {
 8379:     "Apollo",
 8380: 	"Russel",
 8381: 	"Jet",
```

**Snippet 5**
```lua
 8398:     "Hermia",
 8399:     "Becca",
 8400: }
 8401: 
 8402: STRINGS.MERMNAMES =
 8403: {
 8404:     -- Swamp.
 8405:     "Flargle",
 8406:     "Flop",
```

**Snippet 6**
```lua
 8442:     "Simon",
 8443:     "Trevor",
 8444: }
 8445: 
 8446: STRINGS.SHARKBOINAMES =
 8447: {
 8448: 	"Steve",
 8449: 	"Ronnie",
 8450: 	"Finn",
```

**Snippet 7**
```lua
 8477: 	"Gill",
 8478: 
 8479: }
 8480: 
 8481: STRINGS.UI =
 8482: {
 8483: 	TIME_FORMAT =
 8484: 	{
 8485: 		HHMMSS = "{hours}:{minutes}:{seconds}",
```

**Snippet 8**
```lua
15050:     },
15051: }
15052: 
15053: --these are broken out into their own files for ease of editing
15054: STRINGS.CHARACTERS =
15055: {
15056:     GENERIC = require "speech_wilson",
15057:     WAXWELL = require "speech_waxwell",
15058:     WOLFGANG = require "speech_wolfgang",
```

**Snippet 9**
```lua
15071:     WALTER = require "speech_walter",
15072:     WANDA = require "speech_wanda",
15073: }
15074: 
15075: STRINGS.SHADOW_BATTLEAXE_TALK =
15076: {
15077:     overtime_l2 =
15078:     {
15079:         "Sh-sharp.",
```

**Snippet 10**
```lua
15297:         "Meager.",
15298:     },
15299: }
15300: 
15301: STRINGS.VOIDCLOTH_SCYTHE_TALK =
15302: {
15303:     overtime =
15304:     {
15305:         "You want to cut and ssssslice, yes you do!",
```
### File: scripts/skin_strings.lua
> sha256_12=360fcf894f0c, lines=8463

#### Head
```lua
-- AUTOGENERATED CODE BY export_accountitems.lua

STRINGS.SKIN_QUOTES =
{
	walter_ancient = "\"Where should we go on our next adventure, Woby?\"",
	walter_bee = "\"Maybe if I dress like them, they won't sting me!\"",
	walter_bee_d = "\"Maybe if I dress like them, they won't sting me!\"",
	walter_bee_p = "\"Maybe if I dress like them, they won't sting me!\"",
	walter_detective = "\"Don't worry Sirs and Madams, Woby and I are on the case!\"",
	walter_formal = "\"I'd wear it more often, but it's so heavy with all these badges...\"",
	walter_ice = "\"Brrr... it's a good thing you already have your own winter coat, Woby!\"",
	walter_lunar = "\"Look out evildoers, I've got the moon on my side!\"",
	walter_nature = "\"Every story needs a fearless adventurer and their trusty steed!\"",
	walter_rose = "\"I think I really rose to the occasion! Eh, Woby?\"",
	walter_shadow = "\"I don't need a handbook telling me what to do - I make the rules now!\"",
	walter_survivor = "\"I hope I don't lose any points for the state of my uniform.\"",
	walter_ventriloquist = "\"Want to hear a really scary story?\"",
	walter_victorian = "\"Extra, extra! Read all about it!\"",
	walter_yule = "\"Come on Woby, that Winter's Feast tree won't decorate itself!\"",
	wanda_bishop = "\"This match will require a few more adjournments.\"",
	wanda_bishop_d = "\"This match will require a few more adjournments.\"",
	wanda_bishop_p = "\"This match will require a few more adjournments.\"",
	wanda_formal = "\"Nothing is more fashionable than punctuality.\"",
	wanda_ice = "\"Oh botheration, where have I gotten myself this time?\"",
	wanda_lunar = "\"My future will reveal itself in the phases of the moon.\"",
	wanda_masquerade = "\"Starlight is a blast from the past.\"",
	wanda_nature = "\"Time seems to move slower in the depths of the forest.\"",
	wanda_rose = "\"I suppose I should make time to stop and smell the roses every so often.\"",
	wanda_shadow = "\"There is nothing but dark times ahead.\"",
	wanda_steampunk = "\"Not enough people appreciate the minutiae of temporal tinkering.\"",
	wanda_western = "\"There's always more to do than there is time to do it.\"",
	wanda_yule = "\"So many toys to build, and so little time!\"",
	warly_candyman = "\"I'm thinking of opening a chocolate factory.\"",
	warly_carrat = "\"I must train for the races!\"",
	warly_carrat_d = "\"I must train for the races!\"",
	warly_carrat_p = "\"I must train for the races!\"",
	warly_chef = "\"It's a fine day for some fine dining, non?\"",
	warly_fisherman = "\"I'm on a see-food diet.\"",
	warly_formal = "\"What a treat it is to rub shoulders with the creme de la creme!\"",
	warly_ice = "\"I'd say this look is best served cold.\"",
	warly_lunar = "\"Nothing beats a golden croissant... I mean crescent.\"",
	warly_masquerade = "\"An air of mystery is the secret ingredient for any good soiree.\"",
	warly_nature = "\"I only cook with natural ingredients.\"",
	warly_pirate = "\"I seem to have developed quite a taste for treasure.\"",
	warly_rose = "\"And just a dash of sweet rosewater.\"",
	warly_shadow = "\"I've cooked up something frightful, just for you!\"",
	warly_survivor = "\"All can be lost except my taste!\"",
	warly_victorian = "\"I actually just work in the galley.\"",
	warly_yule = "\"I wonder if Maman missed my holiday baking.\"",
	wathgrithr_ancient = "\"Let us remember the days Ã¶f Ã¶ld!\"",
	wathgrithr_combatant = "\"I yearn fÃ¶r my chance Ã¶n the prÃ¶ving grÃ¶unds!\"",
	wathgrithr_cook = "\"MEEEEEAT.\"",
	wathgrithr_deerclops = "\"I cÃ¶uld take yÃ¶u curs with Ã¶ne eye behind my mask!\"",
	wathgrithr_deerclops_d = "\"I cÃ¶uld take yÃ¶u curs with Ã¶ne eye behind my mask!\"",
	wathgrithr_deerclops_p = "\"I cÃ¶uld take yÃ¶u curs with Ã¶ne eye behind my mask!\"",
	wathgrithr_formal = "\"We will celebrate as if we were in Valhalla!\"",
	wathgrithr_formalp = "\"We will celebrate as if we were in Valhalla!\"",
	wathgrithr_gladiator = "\"My skill in battle is withÃ¶ut peer.\"",
	wathgrithr_ice = "\"Call fÃ¶rth the hÃ¶wling winds and biting cÃ¶ld, the jÃ¶tnar fear them nÃ¶t!\"",
	wathgrithr_lunar = "\"BehÃ¶ld Mani's chÃ¶sen warriÃ¶r!\"",
	wathgrithr_magma = "\"I fear nÃ¶t Surtr's flames!\"",
	wathgrithr_masquerade = "\"Let this be the party tÃ¶ end all parties!\"",
	wathgrithr_nature = "\"I shall fight fÃ¶r the fÃ¶rest!\"",
	wathgrithr_pirate = "\"My name shall live Ã¶n fÃ¶rever, as the scÃ¶urge Ã¶f the seven seas!\"",
	wathgrithr_rose = "\"Applause rÃ¶ars as red, red rÃ¶ses flÃ¶Ã¶d my stage!\"",
	wathgrithr_rosep = "\"Applause rÃ¶ars as red, red rÃ¶ses flÃ¶Ã¶d my stage!\"",
	wathgrithr_scarecrow = "\"I shall scare Ã¶ff all the black winged beasties!\"",
	wathgrithr_shadow = "\"I will destrÃ¶y my enemies!\"",
	wathgrithr_shadowp = "\"I will destrÃ¶y my enemies!\"",
	wathgrithr_survivor = "\"YÃ¶u have tÃ¶ try harder than this tÃ¶ defeat me!\"",
	wathgrithr_survivorp = "\"YÃ¶u have tÃ¶ try harder than this tÃ¶ defeat me!\"",
	wathgrithr_valkyrie = "\"The stage is set fÃ¶r my rise tÃ¶ glÃ¶ry!\"",
	wathgrithr_victorian = "\"WÃ¶rds, wÃ¶rds, wÃ¶rds.\"",
	wathgrithr_western = "\"No beast withstandeth the will of one whose heart runneth wild.\"",
	wathgrithr_wrestler = "\"I am the best that ever was!!\"",
	wathgrithr_yule = "\"GÃ¶Ã¶d tidings to all!\"",
	waxwell_combatant = "\"I've faced worse ordeals.\"",
	waxwell_cook = "\"Everything I make is magnificent.\"",
	waxwell_formal = "\"I just need to find my beautiful assistant.\"",
	waxwell_formalp = "\"I just need to find my beautiful assistant.\"",
	waxwell_gladiator = "\"All those who oppose me shall perish!\"",
	waxwell_ice = "\"Nothing personal pal, the ice industry's a cold business.\"",
	waxwell_krampus = "\"Naughty. Definitely naughty.\"",
	waxwell_krampus_d = "\"Naughty. Definitely naughty.\"",
	waxwell_krampus_p = "\"Naughty. Definitely naughty.\"",
	waxwell_lunar = "\"Perhaps I was wrong to dismiss the moon's power so quickly...\"",
	waxwell_magma = "\"Volcanic power is intoxicating.\"",
	waxwell_masquerade = "\"You expect me to mingle? I was assured I'd have my own private box seat!\"",
	waxwell_nature = "\"There is magic in the trees.\"",
	waxwell_pirate = "\"The sea shows no mercy to fools - and neither will I.\"",
	waxwell_rose = "\"The thorned rose cannot help but prick. It is its nature.\"",
	waxwell_rosep = "\"The thorned rose cannot help but prick. It is its nature.\"",
	waxwell_survivor = "\"Say, pal, I don't look so good.\"",
	waxwell_survivorp = "\"Say, pal, I don't look so good.\"",
	waxwell_unshadow = "\"The poor unsuspecting fool has no idea what's coming.\"",
	waxwell_unshadowp = "\"The poor unsuspecting fool has no idea what's coming.\"",
	waxwell_vampire = "\"I never was one to shy away from theatrics, or a good suit.\"",
	waxwell_victorian = "\"Hmph.\"",
	waxwell_wizard = "\"So few dare to delve into the secrets of dark magic.\"",
	waxwell_yule = "\"Hmph. It's cold out.\"",
	webber_bat = "\"Raaar! ...That's our bat noise.\"",
	webber_bat_d = "\"Raaar! ...That's our bat noise.\"",
	webber_bat_p = "\"Raaar! ...That's our bat noise.\"",
	webber_boy = "\"We were so lonely back then...\"",
	webber_combatant = "\"We don't want to fight if we don't have to.\"",
	webber_cook = "\"Let's get cooking!\"",
	webber_formal = "\"We like parties!\"",
	webber_formalp = "\"We like parties!\"",
	webber_gladiator = "\"If you fight us, you will lose.\"",
	webber_ice = "\"We love playing in the snow!\"",
	webber_lunar = "\"The moon made us... different.\"",
	webber_magma = "\"We're like a walking volcano.\"",
	webber_masquerade = "\"We'll be on our best behavior... probably.\"",
	webber_nature = "\"Only the strongest spiders survive out here!\"",
	webber_pirate = "\"It's good that we know how to make silk, our claws keep catching on the sail...\"",
	webber_punk = "\"Don't mess with us.\"",
	webber_rose = "\"The rose shelters our fur from the morning dew.\"",
	webber_rosep = "\"The rose shelters our fur from the morning dew.\"",
	webber_shadow = "\"Come closer - we are hungry!\"",
	webber_shadowp = "\"Come closer - we are hungry!\"",
```

#### Snippets (line-numbered)

**Snippet 1**
```lua
    1: -- AUTOGENERATED CODE BY export_accountitems.lua
    2: 
    3: STRINGS.SKIN_QUOTES =
    4: {
    5: 	walter_ancient = "\"Where should we go on our next adventure, Woby?\"",
    6: 	walter_bee = "\"Maybe if I dress like them, they won't sting me!\"",
    7: 	walter_bee_d = "\"Maybe if I dress like them, they won't sting me!\"",
```

**Snippet 2**
```lua
  374: 	wx78_wrestler = "\"WITH PARTS MADE IN JAPAN\"",
  375: 	wx78_yule = "\"CRACKING WALNUT CODE\"",
  376: }
  377: 
  378: STRINGS.SKIN_NAMES =
  379: {
  380: 	abigail_ancient = "The Archaic",
  381: 	abigail_creepy = "The Supernatural",
  382: 	abigail_flower_ancient = "The Archaic",
```

**Snippet 3**
```lua
 4195: 	wx78_wrestler = "The Midori Roboto",
 4196: 	wx78_yule = "The Merrymaker",
 4197: }
 4198: 
 4199: STRINGS.SKIN_DESCRIPTIONS =
 4200: {
 4201: 	abigail_ancient = "Flowers smell sweetest at Midsummer.",
 4202: 	abigail_creepy = "Legend says this flower is haunted by the spirit of a young girl.",
 4203: 	abigail_flower_ancient = "n/a",
```

**Snippet 4**
```lua
 8016: 	wx78_wrestler = "You don't want to meet these cold mechanical eyes in the ring.",
 8017: 	wx78_yule = "WX-78 has oft been accused of acting wooden during the holidays.",
 8018: }
 8019: 
 8020: STRINGS.SET_NAMES =
 8021: {
 8022: 	body_ugly_winterhat_black_davys = "Black Winter Hat Ensemble",
 8023: 	body_ugly_winterhat_pink_hibiscus = "Pink Winter Hat Ensemble",
 8024: 	emote_carol = "Caroler's Ensemble",
```

**Snippet 5**
```lua
 8027: 	emote_tiphat = "Appreciative Nodding Ensemble",
 8028: 	emote_yawn = "Yawny Jammies Ensemble",
 8029: }
 8030: 
 8031: STRINGS.SET_DESCRIPTIONS =
 8032: {
 8033: 	body_ugly_winterhat_black_davys = "You might as well get one in every color.",
 8034: 	body_ugly_winterhat_pink_hibiscus = "As a matter of fact, having a matching hat and sweater is VERY fashionable.",
 8035: 	emote_carol = "The spirit of Winter's Feast will keep you warm when you go a-caroling tonight!",
```

**Snippet 6**
```lua
 8038: 	emote_tiphat = "Much obliged.",
 8039: 	emote_yawn = "You are so ready for a nap. You've never been more ready for anything in your entire life.",
 8040: }
 8041: 
 8042: STRINGS.THANKS_POPUP =
 8043: {
 8044: 	ANRARG = "Metheus has taken heed",
 8045: 	ARG = "Pulvis et umbra sumus",
 8046: 	CUPID = "Happy Valentine's Day\nfrom your friends at Klei",
```

**Snippet 7**
```lua
 8066: 	YOTB = "Thanks for playing during the\nYear of the Beefalo event",
 8067: 	YOTP = "Thanks for playing during the\nYear of the Pig King event",
 8068: }
 8069: 
 8070: STRINGS.SKIN_TAG_CATEGORIES =
 8071: {
 8072: 	BEEFCLOTHINGTYPE =
 8073: 	{
 8074: 		BEEFALO_BODY = "Beefalo Body",
```

## Category: Widgets

### File: scripts/widgets/controls.lua
> sha256_12=3e6ac904ac9c, lines=1143

#### Head
```lua

if not IsConsole() then
	require "splitscreenutils_pc"
end

local Screen = require "widgets/screen"
local Button = require "widgets/button"
local AnimButton = require "widgets/animbutton"
local ImageButton = require "widgets/imagebutton"
local Text = require "widgets/text"
local Image = require "widgets/image"
local UIAnim = require "widgets/uianim"
local Inv = require "widgets/inventorybar"
local Widget = require "widgets/widget"
local CraftTabs = require "widgets/crafttabs"
local CraftingMenu = require "widgets/redux/craftingmenu_hud"
local HoverText = require "widgets/hoverer"
local MapControls = require "widgets/mapcontrols"
local ContainerWidget = require("widgets/containerwidget")
local DemoTimer = require "widgets/demotimer"
local SavingIndicator = require "widgets/savingindicator"
local UIClock = require "widgets/uiclock"
local MapScreen = require "screens/mapscreen"
local FollowText = require "widgets/followtext"
local StatusDisplays = require "widgets/statusdisplays"
local SecondaryStatusDisplays = require "widgets/secondarystatusdisplays"
local Lavaarena_StatusDisplays = require "widgets/statusdisplays_lavaarena"
local Quagmire_StatusDisplays = require "widgets/statusdisplays_quagmire"
local Quagmire_StatusCravingDisplay = require "widgets/statusdisplays_quagmire_cravings"
local Quagmire_NotificationWidget = require "widgets/quagmire_notificationwidget"
local QuagmireRecipeBookScreen = require "screens/quagmire_recipebookscreen"
local ChatQueue = require "widgets/redux/chatqueue"
local Desync = require "widgets/desync"
local WorldResetTimer = require "widgets/worldresettimer"
local PlayerDeathNotification = require "widgets/playerdeathnotification"
local GiftItemToast = require "widgets/giftitemtoast"
local YotbToast = require "widgets/yotbtoast"
local SkillTreeToast = require "widgets/skilltreetoast"
local ScrapbookToast = require "widgets/scrapbooktoast"
local VoteDialog = require "widgets/votedialog"
local TEMPLATES = require "widgets/templates"
local UserCommandPickerScreen = require "screens/redux/usercommandpickerscreen"
local UserCommands = require "usercommands"
local Wheel = require "widgets/wheel"
local WheelItem = require "widgets/wheelitem"

local easing = require("easing")
local TeamStatusBars = require("widgets/teamstatusbars")

local WHEEL_RADIUS = 175
local WHEEL_FOCUS_RADIUS = 178      
local NESTED_WHEEL_RADIUS_INCREMENT = 10
local NESTED_WHEEL_FOCUS_RADIUS_INCREMENT = 1

local Controls = Class(Widget, function(self, owner)
    Widget._ctor(self, "Controls")
    self.owner = owner

	local is_splitscreen = IsSplitScreen()
	local is_player1 = IsGameInstance(Instances.Player1)

    self._scrnw, self._scrnh = TheSim:GetScreenSize()

    self.playeractionhint = self:AddChild(FollowText(TALKINGFONT, 28))
    self.playeractionhint:SetHUD(owner.HUD.inst)
    self.playeractionhint:SetOffset(Vector3(0, 100, 0))
    self.playeractionhint:Hide()

    self.playeractionhint_itemhighlight = self:AddChild(FollowText(TALKINGFONT, 28))
    self.playeractionhint_itemhighlight:SetHUD(owner.HUD.inst)
    self.playeractionhint_itemhighlight:SetOffset(Vector3(0, 100, 0))
    self.playeractionhint_itemhighlight:Hide()

    self.attackhint = self:AddChild(FollowText(TALKINGFONT, 28))
    self.attackhint:SetHUD(owner.HUD.inst)
    self.attackhint:SetOffset(Vector3(0, 100, 0))
    self.attackhint:Hide()

    self.groundactionhint = self:AddChild(FollowText(TALKINGFONT, 28))
    self.groundactionhint:SetHUD(owner.HUD.inst)
    self.groundactionhint:SetOffset(Vector3(0, 100, 0))
    self.groundactionhint:Hide()

    self.blackoverlay = self:AddChild(Image("images/global.xml", "square.tex"))
    self.blackoverlay:SetVRegPoint(ANCHOR_MIDDLE)
    self.blackoverlay:SetHRegPoint(ANCHOR_MIDDLE)
    self.blackoverlay:SetVAnchor(ANCHOR_MIDDLE)
    self.blackoverlay:SetHAnchor(ANCHOR_MIDDLE)
    self.blackoverlay:SetScaleMode(SCALEMODE_FILLSCREEN)
    self.blackoverlay:SetClickable(false)
    self.blackoverlay:SetTint(0,0,0,.5)
    self.blackoverlay:Hide()

	self.containerroot_under = self:AddChild(Widget(""))
    self.containerroot = self:AddChild(Widget(""))
    self.containerroot_side_behind = self:AddChild(Widget(""))
    self:MakeScalingNodes()

    self.saving = self.topright_over_root:AddChild(SavingIndicator(self.owner))
    self.saving:SetPosition(-440, 0, 0)

    self.toastlocations = {
        {pos=Vector3(115, 150, 0)},
        {pos=Vector3(215, 150, 0)},
        {pos=Vector3(315, 150, 0)},
        {pos=Vector3(415, 150, 0)},        
    }
	self.toastitems = {}

    self.item_notification = self.topleft_root:AddChild(GiftItemToast(self.owner, self))
    self.item_notification:SetPosition(115, 150, 0)
	table.insert(self.toastitems, self.item_notification)

    self.yotb_notification = self.topleft_root:AddChild(YotbToast(self.owner, self))
    self.yotb_notification:SetPosition(215, 150, 0)
	table.insert(self.toastitems, self.yotb_notification)

    self.skilltree_notification = self.topleft_root:AddChild(SkillTreeToast(self.owner, self))
    self.skilltree_notification:SetPosition(315, 150, 0)
	table.insert(self.toastitems, self.skilltree_notification)
```

#### Snippets (line-numbered)

**Snippet 1**
```lua
   15: local CraftTabs = require "widgets/crafttabs"
   16: local CraftingMenu = require "widgets/redux/craftingmenu_hud"
   17: local HoverText = require "widgets/hoverer"
   18: local MapControls = require "widgets/mapcontrols"
   19: local ContainerWidget = require("widgets/containerwidget")
   20: local DemoTimer = require "widgets/demotimer"
   21: local SavingIndicator = require "widgets/savingindicator"
   22: local UIClock = require "widgets/uiclock"
   23: local MapScreen = require "screens/mapscreen"
```

**Snippet 2**
```lua
   44: local Wheel = require "widgets/wheel"
   45: local WheelItem = require "widgets/wheelitem"
   46: 
   47: local easing = require("easing")
   48: local TeamStatusBars = require("widgets/teamstatusbars")
   49: 
   50: local WHEEL_RADIUS = 175
   51: local WHEEL_FOCUS_RADIUS = 178      
   52: local NESTED_WHEEL_RADIUS_INCREMENT = 10
   53: local NESTED_WHEEL_FOCUS_RADIUS_INCREMENT = 1
   54: 
   55: local Controls = Class(Widget, function(self, owner)
   56:     Widget._ctor(self, "Controls")
   57:     self.owner = owner
   58: 
   59: 	local is_splitscreen = IsSplitScreen()
```
### File: scripts/screens/playerhud.lua
> sha256_12=929f8f93ad2b, lines=1738

#### Head
```lua
local Screen = require "widgets/screen"
local ContainerWidget = require("widgets/containerwidget")
local WriteableWidget = require("widgets/writeablewidget")
local Controls = require("widgets/controls")
local UIAnim = require "widgets/uianim"
local Text = require "widgets/text"
local Widget = require "widgets/widget"
local IceOver = require "widgets/iceover"
local FireOver = require "widgets/fireover"
local BloodOver = require "widgets/bloodover"
local BeefBloodOver = require "widgets/beefbloodover"
local HeatOver = require "widgets/heatover"
local FumeOver = require "widgets/fumeover"
local MiasmaOver = require("widgets/miasmaover")
local MiasmaCloudsOver = require("widgets/miasmacloudsover")
local SandOver = require "widgets/sandover"
local SandDustOver = require "widgets/sanddustover"
local MoonstormOver = require "widgets/moonstormover"
local MoonstormOver_Lightning = require "widgets/moonstormover_lightning"
local RainDomeOver = require("widgets/raindomeover")
local Leafcanopy = require "widgets/leafcanopy"
local MindControlOver = require "widgets/mindcontrolover"
local ParasiteThrallOver = require "widgets/parasitethrallover"
local InkOver = require "widgets/inkover"
local WagpunkUI = require "widgets/wagpunkui"
local GogglesOver = require "widgets/gogglesover"
local NutrientsOver = require "widgets/nutrientsover"
local ScrapMonocleOver = require "widgets/scrapmonocleover"
local NightVisionFruitOver = require "widgets/nightvisionfruitover"
local InspectaclesOver = require("widgets/inspectaclesover")
local RoseGlassesOver = require("widgets/roseglassesover")
local BatOver = require "widgets/batover"
local FlareOver = require "widgets/flareover"
local LunarBurnOver = require("widgets/lunarburnover")
local EndOfMatchPopup = require "widgets/redux/endofmatchpopup"
local PopupNumber = require "widgets/popupnumber"
local RingMeter = require "widgets/ringmeter"
local easing = require("easing")
local PauseScreen = require "screens/redux/pausescreen"
local ChatInputScreen = require "screens/chatinputscreen"
local PlayerStatusScreen = require "screens/playerstatusscreen"
local InputDialogScreen = require "screens/inputdialog"
local CookbookPopupScreen = require "screens/cookbookpopupscreen"
local PlantRegistryPopupScreen = require "screens/plantregistrypopupscreen"
local PlayerInfoPopupScreen = require "screens/playerinfopopupscreen"
local ScrapbookScreen = require "screens/redux/scrapbookscreen"
local InspectaclesScreen = require("screens/redux/inspectaclesscreen")
local BalatroScreen = require("screens/redux/balatroscreen")
local PumpkinCarvingScreen = require("screens/redux/pumpkincarvingscreen")
local PumpkinHatCarvingScreen = require("screens/redux/pumpkinhatcarvingscreen")
local SnowmanDecoratingScreen = require("screens/redux/snowmandecoratingscreen")

local TargetIndicator = require "widgets/targetindicator"

local EventAnnouncer = require "widgets/eventannouncer"
local GiftItemPopUp = require "screens/giftitempopup"
local GridWardrobePopupScreen = require "screens/redux/wardrobepopupgridloadout"
local GridGroomerPopupScreen = require "screens/redux/groomerpopupgridloadout"
local GridHermitCrabWardrobePopupScreen = require "screens/redux/hermitcrabwardrobepopupgridloadout"
local GridScarecrowClothingPopupScreen = require "screens/redux/scarecrowpopupgridloadout"
local PlayerAvatarPopup = require "widgets/playeravatarpopup"
local DressupAvatarPopup = require "widgets/dressupavatarpopup"



local PlayerHud = Class(Screen, function(self)
    Screen._ctor(self, "HUD")

    self.overlayroot = self:AddChild(Widget("overlays"))

    self.under_root = self:AddChild(Widget("under_root"))
    self.root = self:AddChild(Widget("root"))
    self.over_root = self:AddChild(Widget("over_root"))
    self.popupstats_root = self:AddChild(Widget("popupstats_root"))

    self.playerstatusscreen = nil
    self.giftitempopup = nil
    self.wardrobepopup = nil
    self.groomerpopup = nil
    self.playeravatarpopup = nil
    self.recentgifts = nil
    self.recentgiftstask = nil

    self.inst:ListenForEvent("continuefrompause", function() self:RefreshControllers() end, TheWorld)
    self.inst:ListenForEvent("endofmatch", function(world, data) self:ShowEndOfMatchPopup(data) end, TheWorld)
    self.inst:ListenForEvent("debug_rebuild_skilltreedata", function() self:OpenPlayerInfoScreen() end, TheGlobalInstance)
    
    if not TheWorld.ismastersim then
        self.inst:ListenForEvent("deactivateworld", function()
            --Essential cleanup when client is notified of
            --pending server c_reset or c_regenerateworld.
            if self.playeravatarpopup ~= nil then
                if self.playeravatarpopup.started and self.playeravatarpopup.inst:IsValid() then
                    self.playeravatarpopup:Close()
                end
                self.playeravatarpopup = nil
            end
            if self.playerstatusscreen ~= nil then
                if self.playerstatusscreen.shown then
                    self.playerstatusscreen:Close()
                end
                self.playerstatusscreen:CloseUserCommandPickerScreen()
            end
        end, TheWorld)
    else
        self.inst:ListenForEvent("ms_closepopups", self.onclosepopups)
    end
end)

function PlayerHud:CreateOverlays(owner)
    self.overlayroot:KillAllChildren()
    self.under_root:KillAllChildren()
    self.over_root:KillAllChildren()

    self.vig = self.overlayroot:AddChild(UIAnim())
    self.vig:GetAnimState():SetBuild("vig")
    self.vig:GetAnimState():SetBank("vig")
    self.vig:GetAnimState():PlayAnimation("basic", true)
    self.vig:GetAnimState():AnimateWhilePaused(false)
```

#### Snippets (line-numbered)

**Snippet 1**
```lua
    1: local Screen = require "widgets/screen"
    2: local ContainerWidget = require("widgets/containerwidget")
    3: local WriteableWidget = require("widgets/writeablewidget")
    4: local Controls = require("widgets/controls")
    5: local UIAnim = require "widgets/uianim"
    6: local Text = require "widgets/text"
    7: local Widget = require "widgets/widget"
    8: local IceOver = require "widgets/iceover"
```

**Snippet 2**
```lua
   10: local BloodOver = require "widgets/bloodover"
   11: local BeefBloodOver = require "widgets/beefbloodover"
   12: local HeatOver = require "widgets/heatover"
   13: local FumeOver = require "widgets/fumeover"
   14: local MiasmaOver = require("widgets/miasmaover")
   15: local MiasmaCloudsOver = require("widgets/miasmacloudsover")
   16: local SandOver = require "widgets/sandover"
   17: local SandDustOver = require "widgets/sanddustover"
   18: local MoonstormOver = require "widgets/moonstormover"
   19: local MoonstormOver_Lightning = require "widgets/moonstormover_lightning"
   20: local RainDomeOver = require("widgets/raindomeover")
   21: local Leafcanopy = require "widgets/leafcanopy"
   22: local MindControlOver = require "widgets/mindcontrolover"
   23: local ParasiteThrallOver = require "widgets/parasitethrallover"
   24: local InkOver = require "widgets/inkover"
```

**Snippet 3**
```lua
   26: local GogglesOver = require "widgets/gogglesover"
   27: local NutrientsOver = require "widgets/nutrientsover"
   28: local ScrapMonocleOver = require "widgets/scrapmonocleover"
   29: local NightVisionFruitOver = require "widgets/nightvisionfruitover"
   30: local InspectaclesOver = require("widgets/inspectaclesover")
   31: local RoseGlassesOver = require("widgets/roseglassesover")
   32: local BatOver = require "widgets/batover"
   33: local FlareOver = require "widgets/flareover"
   34: local LunarBurnOver = require("widgets/lunarburnover")
   35: local EndOfMatchPopup = require "widgets/redux/endofmatchpopup"
   36: local PopupNumber = require "widgets/popupnumber"
   37: local RingMeter = require "widgets/ringmeter"
   38: local easing = require("easing")
```

**Snippet 4**
```lua
   62: local DressupAvatarPopup = require "widgets/dressupavatarpopup"
   63: 
   64: 
   65: 
   66: local PlayerHud = Class(Screen, function(self)
   67:     Screen._ctor(self, "HUD")
   68: 
   69:     self.overlayroot = self:AddChild(Widget("overlays"))
   70:
```

## Category: Brains

### File: scripts/prefabs/pigman.lua
> sha256_12=057ce3dc07e5, lines=861

#### Head
```lua
local assets =
{
    Asset("ANIM", "anim/ds_pig_basic.zip"),
    Asset("ANIM", "anim/ds_pig_actions.zip"),
    Asset("ANIM", "anim/ds_pig_attacks.zip"),
    Asset("ANIM", "anim/ds_pig_boat_jump.zip"),
    Asset("ANIM", "anim/pig_build.zip"),
    Asset("ANIM", "anim/pigspotted_build.zip"),
    Asset("ANIM", "anim/pig_guard_build.zip"),
    Asset("ANIM", "anim/pigman_yotb.zip"),
    Asset("ANIM", "anim/werepig_build.zip"),
    Asset("ANIM", "anim/werepig_basic.zip"),
    Asset("ANIM", "anim/werepig_actions.zip"),
    Asset("ANIM", "anim/pig_token.zip"),
    Asset("ANIM", "anim/ds_pig_parasite_death.zip"),
    Asset("SOUND", "sound/pig.fsb"),
    Asset("ANIM", "anim/merm_actions.zip"),
}

local PIG_TOKEN_PREFAB = "pig_token"

local prefabs =
{
    "meat",
    "monstermeat",
    "poop",
    "tophat",
    "strawhat",
    "pigskin",
    PIG_TOKEN_PREFAB,

    --"pigcorpse",
}

local MAX_TARGET_SHARES = 5
local SHARE_TARGET_DIST = 30

local function GetPigToken(inst)
	local token=<REDACTED>
	return token
end

local function ontalk(inst, script)
    inst.SoundEmitter:PlaySound("dontstarve/pig/grunt")
end

local function CalcSanityAura(inst, observer)
    return (inst.prefab == "moonpig" and -TUNING.SANITYAURA_LARGE)
        or (inst.components.werebeast ~= nil and inst.components.werebeast:IsInWereState() and -TUNING.SANITYAURA_LARGE)
        or (inst.components.follower ~= nil and inst.components.follower.leader == observer and TUNING.SANITYAURA_SMALL)
        or 0
end

local function ShouldAcceptItem(inst, item)
    if item.components.equippable ~= nil and item.components.equippable.equipslot == EQUIPSLOTS.HEAD then
        return true
    elseif inst.components.eater:CanEat(item) then
        local foodtype = item.components.edible.foodtype
        if foodtype == FOODTYPE.MEAT or foodtype == FOODTYPE.HORRIBLE then
            return inst.components.follower.leader == nil or inst.components.follower:GetLoyaltyPercent() <= TUNING.PIG_FULL_LOYALTY_PERCENT
        elseif foodtype == FOODTYPE.VEGGIE or foodtype == FOODTYPE.RAW then
            local last_eat_time = inst.components.eater:TimeSinceLastEating()
            return (last_eat_time == nil or
                    last_eat_time >= TUNING.PIG_MIN_POOP_PERIOD)
                and (inst.components.inventory == nil or
                    not inst.components.inventory:Has(item.prefab, 1))
        end
        return true
    end
end

local function OnGetItemFromPlayer(inst, giver, item)
    --I eat food
    if item.components.edible ~= nil then
        --meat makes us friends (unless I'm a guard)
        if (    item.components.edible.foodtype == FOODTYPE.MEAT or
                item.components.edible.foodtype == FOODTYPE.HORRIBLE
            ) and
            item.components.inventoryitem ~= nil and
            (   --make sure it didn't drop due to pockets full
                item.components.inventoryitem:GetGrandOwner() == inst or
                --could be merged into a stack
                (   not item:IsValid() and
                    inst.components.inventory:FindItem(function(obj)
                        return obj.prefab == item.prefab
                            and obj.components.stackable ~= nil
                            and obj.components.stackable:IsStack()
                    end) ~= nil)
            ) then
            if inst.components.combat:TargetIs(giver) then
                inst.components.combat:SetTarget(nil)
            elseif giver.components.leader ~= nil and not (inst:HasTag("guard") or giver:HasTag("monster") or giver:HasTag("merm")) then

				if giver.components.minigame_participator == nil then
	                giver:PushEvent("makefriend")
	                giver.components.leader:AddFollower(inst)
				end
                inst.components.follower:AddLoyaltyTime(item.components.edible:GetHunger() * TUNING.PIG_LOYALTY_PER_HUNGER)
                inst.components.follower.maxfollowtime =
                    giver:HasTag("polite")
                    and TUNING.PIG_LOYALTY_MAXTIME + TUNING.PIG_LOYALTY_POLITENESS_MAXTIME_BONUS
                    or TUNING.PIG_LOYALTY_MAXTIME
            end
        end
        if inst.components.sleeper:IsAsleep() then
            inst.components.sleeper:WakeUp()
        end
    end

    --I wear hats
    if item.components.equippable ~= nil and item.components.equippable.equipslot == EQUIPSLOTS.HEAD then
        local current = inst.components.inventory:GetEquippedItem(EQUIPSLOTS.HEAD)
        if current ~= nil then
            inst.components.inventory:DropItem(current)
        end
        inst.components.inventory:Equip(item)
        inst.AnimState:Show("hat")
    end
end
```

#### Snippets (line-numbered)

**Snippet 1**
```lua
  258:         and (inst.components.follower == nil or inst.components.follower.leader == nil
  259:             or (FindEntity(inst, 6, nil, CAMPFIRE_TAGS) ~= nil and inst:IsInLight()))
  260: end
  261: 
  262: local normalbrain = require "brains/pigbrain"
  263: 
  264: local function SuggestTreeTarget(inst, data)
  265:     local ba = inst:GetBufferedAction()
  266:     if data ~= nil and data.tree ~= nil and (ba == nil or ba.action ~= ACTIONS.CHOP) then
```

**Snippet 2**
```lua
  412: local function GuardShouldWake(inst)
  413:     return true
  414: end
  415: 
  416: local guardbrain = require "brains/pigguardbrain"
  417: 
  418: local function SetGuardPig(inst)
  419:     inst:RemoveTag("werepig")
  420:     inst:AddTag("guard")
```

**Snippet 3**
```lua
  503: local function WerepigWakeTest(inst)
  504:     return true
  505: end
  506: 
  507: local werepigbrain = require "brains/werepigbrain"
  508: 
  509: local function SetWerePig(inst)
  510:     inst:AddTag("werepig")
  511:     inst:RemoveTag("guard")
```

**Snippet 4**
```lua
  794: for i, v in ipairs(prefabs) do
  795:     table.insert(moonpigprefabs, v)
  796: end
  797: 
  798: local moonbeastbrain = require "brains/moonbeastbrain"
  799: 
  800: local function OnMoonPetrify(inst)
  801:     if not inst.components.health:IsDead() and (not inst.sg:HasStateTag("busy") or inst:IsAsleep()) then
  802:         local x, y, z = inst.Transform:GetWorldPosition()
```
### File: scripts/prefabs/merm.lua
> sha256_12=9318b5254591, lines=1658

#### Head
```lua
local assets =
{
    Asset("ANIM", "anim/merm_build.zip"),
    Asset("ANIM", "anim/merm_guard_build.zip"),
    Asset("ANIM", "anim/merm_guard_small_build.zip"),
    Asset("ANIM", "anim/merm_actions.zip"),
    Asset("ANIM", "anim/merm_actions_skills.zip"),
    Asset("ANIM", "anim/merm_guard_transformation.zip"),
    Asset("ANIM", "anim/ds_pig_boat_jump.zip"),
    Asset("ANIM", "anim/pigman_yotb.zip"),
    Asset("ANIM", "anim/ds_pig_basic.zip"),
    Asset("ANIM", "anim/ds_pig_actions.zip"),
    Asset("ANIM", "anim/ds_pig_attacks.zip"),
    Asset("ANIM", "anim/ds_pig_elite.zip"),

    Asset("ANIM", "anim/merm_lunar_eye_build.zip"),
    Asset("ANIM", "anim/merm_guard_lunar_eye_build.zip"),
    Asset("ANIM", "anim/merm_guard_small_lunar_eye_build.zip"),

    Asset("ANIM", "anim/merm_lunar_build.zip"),
    Asset("ANIM", "anim/merm_guard_lunar_build.zip"),
    Asset("ANIM", "anim/merm_guard_small_lunar_build.zip"),

    Asset("ANIM", "anim/merm_shadow_build.zip"),
    Asset("ANIM", "anim/merm_guard_shadow_build.zip"),
    Asset("ANIM", "anim/merm_guard_small_shadow_build.zip"),

    Asset("ANIM", "anim/merm_guard_transformation.zip"),

    Asset("ANIM", "anim/ds_pig_parasite_death.zip"),    

    Asset("SOUND", "sound/merm.fsb"),
}

local prefabs =
{
    "pondfish",
    "froglegs",
    "mermking",
    "merm_splash",
    "merm_spawn_fx",
    "merm_shadow",

    "mermking_buff_trident",
    "mermking_buff_crown",
    "mermking_buff_pauldron",

    "lunarmerm_thorns_fx",

    "shadow_merm_spawn_poof_fx",
    "shadow_merm_smacked_poof_fx",
    "merm_soil_marker",

    "mermcorpse",
}

local merm_loot =
{
    "pondfish",
    "froglegs",
}

local merm_guard_loot =
{
    "pondfish",
    "froglegs",
}

local merm_shadow_loot =
{
    "nightmarefuel",
}

SetSharedLootTable("merm_lunar_loot", {
    -- NOTES(JBK): This is added onto whatever the base merm loot was.
    {"tentaclespots", 0.25},
})

local sounds = {
    attack = "dontstarve/creatures/merm/attack",
    hit = "dontstarve/creatures/merm/hurt",
    death = "dontstarve/creatures/merm/death",
    talk = "dontstarve/characters/wurt/merm/warrior/talk",
    buff = "dontstarve/characters/wurt/merm/warrior/yell",
}

local sounds_guard = {
    attack = "dontstarve/characters/wurt/merm/warrior/attack",
    hit = "dontstarve/characters/wurt/merm/warrior/hit",
    death = "dontstarve/characters/wurt/merm/warrior/death",
    talk = "dontstarve/characters/wurt/merm/warrior/talk",
    buff = "dontstarve/characters/wurt/merm/warrior/yell",
}

local merm_brain = require "brains/mermbrain"
local merm_guard_brain = require "brains/mermguardbrain"

--------------------------------------------------------------------------------------------------------------------------------

local SLIGHTDELAY = 1
local LOW_HEALTH_PERCENT = 0.2

local function FindInvaderFn(guy, inst)
    if guy:HasTag("NPC_contestant") then
        return nil
    end

    local leader = inst.components.follower and inst.components.follower.leader

    local leader_guy = guy.components.follower and guy.components.follower.leader
    if leader_guy and leader_guy.components.inventoryitem then
        leader_guy = leader_guy.components.inventoryitem:GetGrandOwner()
    end

    return (guy:HasTag("character") and not guy:HasTag("merm")) and
           not (TheWorld.components.mermkingmanager and TheWorld.components.mermkingmanager:HasKingAnywhere()) and
           not (leader and leader:HasTag("player")) and
           not (leader_guy and (leader_guy:HasTag("merm")) and
                not guy:HasTag("pig") and
                not guy:HasTag("wonkey"))
```

#### Snippets (line-numbered)

**Snippet 1**
```lua
   91:     talk = "dontstarve/characters/wurt/merm/warrior/talk",
   92:     buff = "dontstarve/characters/wurt/merm/warrior/yell",
   93: }
   94: 
   95: local merm_brain = require "brains/mermbrain"
   96: local merm_guard_brain = require "brains/mermguardbrain"
   97: 
   98: --------------------------------------------------------------------------------------------------------------------------------
   99: 
  100: local SLIGHTDELAY = 1
```

## Category: Stategraphs

### File: scripts/stategraphs/SGwilson.lua
> sha256_12=a4dc61624beb, lines=25875

#### Head
```lua
require("stategraphs/commonstates")
local easing = require("easing")
local PlayerCommonExtensions = require("prefabs/player_common_extensions")

local ATTACK_PROP_MUST_TAGS = { "_combat" }
local ATTACK_PROP_CANT_TAGS = { "flying", "shadow", "ghost", "FX", "NOCLICK", "DECOR", "INLIMBO", "playerghost" }

local MOOSE_AOE_MUST_TAGS = { "_combat" }
local MOOSE_AOE_CANT_TAGS = { "INLIMBO", "wall", "companion", "flight", "invisible", "notarget", "noattack" }

local FLOWERS_MUST_TAGS = {"flower"}
local FLOWERS_CANT_TAGS = {"INLIMBO"}

local WORTOX_SHADOW_MULT = 0.6
local WORTOX_LUNAR_OFFSET = 0.1

local function GetLocalAnalogXY(inst)
	if inst.HUD and inst.components.playercontroller then
		local isenabled, ishudblocking = inst.components.playercontroller:IsEnabled()
		if isenabled or ishudblocking then
			local xdir = TheInput:GetAnalogControlValue(CONTROL_MOVE_RIGHT) - TheInput:GetAnalogControlValue(CONTROL_MOVE_LEFT)
			local ydir = TheInput:GetAnalogControlValue(CONTROL_MOVE_UP) - TheInput:GetAnalogControlValue(CONTROL_MOVE_DOWN)
			local deadzone = TUNING.CONTROLLER_DEADZONE_RADIUS
			if math.abs(xdir) >= deadzone or math.abs(ydir) >= deadzone then
				return xdir, ydir
			end
		end
	end
end

local function GetLocalAnalogDir(inst)
	local xdir, ydir = GetLocalAnalogXY(inst)
	if xdir then
		local dir = TheCamera:GetRightVec() * xdir - TheCamera:GetDownVec() * ydir
		return dir:Normalize()
	end
end

local function IsLocalAnalogTriggered(inst)
	return GetLocalAnalogXY(inst) ~= nil
end

local function GetIceStaffProjectileSound(inst, equip)
    if equip.icestaff_coldness then
        if equip.icestaff_coldness > 2 then
            return "dontstarve/wilson/attack_deepfreezestaff_lvl2"
        elseif equip.icestaff_coldness > 1 then
            return "dontstarve/wilson/attack_deepfreezestaff"
        end
    end
    return "dontstarve/wilson/attack_icestaff"
end

local function GetRoyaltyTarget(inst)
    local royalty
    local mindistsq = 25
    for i, v in ipairs(AllPlayers) do
        if v ~= inst and
            not v:HasTag("playerghost") and
            v.entity:IsVisible() and
            v.components.inventory:EquipHasTag("regal") then
            local isregaljoker = v.components.inventory:EquipHasTag("regaljoker")
            if not inst.regaljokertask or inst.regaljokertask and not isregaljoker then
                if not inst.refusestobowtoroyaltytask or inst.refusestobowtoroyaltytask and isregaljoker then
                    local distsq = v:GetDistanceSqToInst(inst)
                    if distsq < mindistsq then
                        mindistsq = distsq
                        royalty = v
                    end
                end
            end
        end
    end
    return royalty
end
local NO_REGALJOKER_RESPONSE_TIME = 6.0
local function ClearRegalJokerTask(inst)
    inst.regaljokertask = nil
end
local NO_REFUSEBOW_RESPONSE_TIME = 6.0
local function ClearRefuseBowTask(inst)
    inst.refusestobowtoroyaltytask = nil
end

local function DoEquipmentFoleySounds(inst)
    for k, v in pairs(inst.components.inventory.equipslots) do
        if v.foleysound ~= nil then
            inst.SoundEmitter:PlaySound(v.foleysound, nil, nil, true)
        end
    end
end

local function DoFoleySounds(inst)
    DoEquipmentFoleySounds(inst)
    if inst.foleysound ~= nil then
        inst.SoundEmitter:PlaySound(inst.foleysound, nil, nil, true)
    end
end

local function DoMountedFoleySounds(inst)
    DoEquipmentFoleySounds(inst)
    local saddle = inst.components.rider:GetSaddle()
    if saddle ~= nil and saddle.mounted_foleysound ~= nil then
        inst.SoundEmitter:PlaySound(saddle.mounted_foleysound, nil, nil, true)
    end
end

local DoRunSounds = function(inst)
    if inst.sg.mem.footsteps > 3 then
        PlayFootstep(inst, .6, true)
    else
        inst.sg.mem.footsteps = inst.sg.mem.footsteps + 1
        PlayFootstep(inst, 1, true)
    end
end

if TheNet:GetServerGameMode() == "lavaarena" or TheNet:GetServerGameMode() == "quagmire" then
    DoRunSounds = event_server_data("common", "stategraphs/SGwilson").OverrideRunSounds(DoRunSounds)
end
```

#### Snippets (line-numbered)

**Snippet 1**
```lua
  713: --------------------------------------------------------------------------
  714: 
  715: local actionhandlers =
  716: {
  717:     ActionHandler(ACTIONS.CHOP,
  718:         function(inst)
  719:             if inst:HasTag("beaver") then
  720:                 return not inst.sg:HasStateTag("gnawing") and "gnaw" or nil
  721:             end
```

**Snippet 2**
```lua
  724:                     "chop" or
  725:                     "chop_start")
  726:                 or nil
  727:         end),
  728:     ActionHandler(ACTIONS.MINE,
  729:         function(inst)
  730:             if inst:HasTag("beaver") then
  731:                 return not inst.sg:HasStateTag("gnawing") and "gnaw" or nil
  732:             end
```

**Snippet 3**
```lua
  735:                     "mine" or
  736:                     "mine_start")
  737:                 or nil
  738:         end),
  739:     ActionHandler(ACTIONS.REMOVELUNARBUILDUP, -- Copy of ACTIONS.MINE
  740:         function(inst)
  741:             if inst:HasTag("beaver") then
  742:                 return not inst.sg:HasStateTag("gnawing") and "gnaw" or nil
  743:             end
```

**Snippet 4**
```lua
  746:                     "mine" or
  747:                     "mine_start")
  748:                 or nil
  749:         end),
  750:     ActionHandler(ACTIONS.HAMMER,
  751:         function(inst)
  752:             if inst:HasTag("beaver") then
  753:                 return not inst.sg:HasStateTag("gnawing") and "gnaw" or nil
  754:             end
```

**Snippet 5**
```lua
  757:                     "hammer" or
  758:                     "hammer_start")
  759:                 or nil
  760:         end),
  761:     ActionHandler(ACTIONS.TERRAFORM, "terraform"),
  762:     ActionHandler(ACTIONS.DIG,
  763:         function(inst)
  764:             if inst:HasTag("beaver") then
  765:                 return not inst.sg:HasStateTag("gnawing") and "gnaw" or nil
  766:             end
```

**Snippet 6**
```lua
  769:                     "dig" or
  770:                     "dig_start")
  771:                 or nil
  772:         end),
  773:     ActionHandler(ACTIONS.NET,
  774:         function(inst, action)
  775:             if action.invobject and action.invobject:HasTag("nabbag") then
  776:                 return "nabbag"
  777:             end
```

**Snippet 7**
```lua
  781: 
  782:             return not inst.sg:HasStateTag("prenet") and (inst.sg:HasStateTag("netting") and "bugnet" or "bugnet_start") or nil
  783:         end),
  784: 
  785:     ActionHandler(ACTIONS.FISH, "fishing_pre"),
  786:     ActionHandler(ACTIONS.FISH_OCEAN, "fishing_ocean_pre"),
  787:     ActionHandler(ACTIONS.OCEAN_FISHING_POND, "fishing_ocean_pre"),
  788:     ActionHandler(ACTIONS.OCEAN_FISHING_CAST, "oceanfishing_cast"),
  789:     ActionHandler(ACTIONS.OCEAN_FISHING_REEL,
  790:         function(inst, action)
  791:             local fishable = action.invobject ~= nil and action.invobject.components.oceanfishingrod.target or nil
  792:             if fishable ~= nil and fishable.components.oceanfishable ~= nil and fishable:HasTag("partiallyhooked") then
  793:                 return "oceanfishing_sethook"
```

**Snippet 8**
```lua
  795:                 return "oceanfishing_reel"
  796:             end
  797:             return nil
  798:         end),
  799:     ActionHandler(ACTIONS.FERTILIZE,
  800:         function(inst, action)
  801:             return (((action.target ~= nil and action.target ~= inst) or action:GetActionPoint() ~= nil) and "doshortaction")
  802:                 or (action.invobject ~= nil and action.invobject:HasTag("slowfertilize") and "fertilize")
  803:                 or "fertilize_short"
  804:         end),
  805:     ActionHandler(ACTIONS.SMOTHER,
  806:         function(inst)
  807:             return inst:HasTag("pyromaniac") and "domediumaction" or "dolongaction"
  808:         end),
  809:     ActionHandler(ACTIONS.MANUALEXTINGUISH,
  810:         function(inst)
  811:             return inst:HasTag("pyromaniac") and "domediumaction" or "dolongaction"
  812:         end),
  813:     ActionHandler(ACTIONS.TRAVEL, "doshortaction"),
  814:     ActionHandler(ACTIONS.LIGHT, "catchonfire"),
  815:     ActionHandler(ACTIONS.UNLOCK, "give"),
  816:     ActionHandler(ACTIONS.USEKLAUSSACKKEY,
  817:         function(inst)
  818:             return inst:HasTag("quagmire_fasthands") and "domediumaction" or "dolongaction"
  819:         end),
  820:     ActionHandler(ACTIONS.TURNOFF, "give"),
  821:     ActionHandler(ACTIONS.TURNON, "give"),
  822:     ActionHandler(ACTIONS.ADDFUEL, "doshortaction"),
  823:     ActionHandler(ACTIONS.ADDWETFUEL, "doshortaction"),
  824:     ActionHandler(ACTIONS.REPAIR, function(inst, action)
  825:         return action.target:HasTag("repairshortaction") and "doshortaction" or "dolongaction"
  826:     end),
  827:     ActionHandler(ACTIONS.READ,
  828:         function(inst, action)
  829:             return (action.invobject ~= nil and action.invobject.components.simplebook ~= nil and "cookbook_open")
  830: 				or (inst.components.reader ~= nil and inst.components.reader:IsAspiringBookworm() and "book_peruse")
  831: 				or "book"
  832:         end),
  833:     ActionHandler(ACTIONS.MAKEBALLOON, "makeballoon"),
  834: 	ActionHandler(ACTIONS.DEPLOY, function(inst, action) 
  835:         if action.invobject and action.invobject:HasTag("graveplanter") then
  836:             return "graveurn_out"
  837:         end
  838:         return action.invobject and action.invobject.components.complexprojectile and "throw_deploy" or "doshortaction" 
  839:     end),
  840:     ActionHandler(ACTIONS.DEPLOY_TILEARRIVE, "doshortaction"),
  841: 	ActionHandler(ACTIONS.DEPLOY_FLOATING, function(inst)
  842: 		inst.sg.statemem.floating = true
  843: 		return "float_action"
  844: 	end),
  845:     ActionHandler(ACTIONS.STORE, "doshortaction"),
  846:     ActionHandler(ACTIONS.DROP,
  847:         function(inst)
  848: 			if not inst.components.inventory:IsFloaterHeld() then
  849: 				return inst.components.inventory:IsHeavyLifting()
  850: 					and not inst.components.rider:IsRiding()
  851: 					and "heavylifting_drop"
  852: 					or "doshortaction"
  853: 			end
  854:         end),
  855:     ActionHandler(ACTIONS.MURDER,
  856:         function(inst)
  857:             return inst:HasTag("quagmire_fasthands") and "domediumaction" or "dolongaction"
  858:         end),
  859:     ActionHandler(ACTIONS.UPGRADE, "dolongaction"),
  860:     ActionHandler(ACTIONS.ACTIVATE,
  861:         function(inst, action)
  862:             return action.target.components.activatable ~= nil
  863: 				and (	(	action.target:HasTag("engineering") and (
  864: 								(inst:HasTag("scientist") and "dolongaction") or
```

**Snippet 9**
```lua
  870:                         "dolongaction"
  871:                     )
  872:                 or nil
  873:         end),
  874:     ActionHandler(ACTIONS.OPEN_CRAFTING, "dostandingaction"),
  875:     ActionHandler(ACTIONS.PICK,
  876:         function(inst, action)
  877:             return
  878: 				(action.target and action.target:HasTag("noquickpick") and "dolongaction") or
  879:                 (inst:HasTag("farmplantfastpicker") and action.target ~= nil and action.target:HasTag("farm_plant") and "domediumaction") or
```

**Snippet 10**
```lua
  900:                     ))
  901:                 )
  902:                 or nil
  903:         end),
  904:     ActionHandler(ACTIONS.CARNIVALGAME_FEED,
  905:         function(inst, action)
  906:             return (inst.components.rider ~= nil and inst.components.rider:IsRiding() and "dolongaction")
  907: 				or "doequippedaction"
  908:         end),
  909:     ActionHandler(ACTIONS.SLEEPIN,
  910:         function(inst, action)
  911:             if action.invobject ~= nil then
  912:                 if action.invobject.onuse ~= nil then
  913:                     action.invobject:onuse(inst)
```
### File: scripts/stategraphs/SGwilson_client.lua
> sha256_12=348ab359e83b, lines=7327

#### Head
```lua
require("stategraphs/commonstates")
local easing = require("easing")

local TIMEOUT = 2

local function GetIceStaffProjectileSound(inst, equip)
    if equip.icestaff_coldness then
        if equip.icestaff_coldness > 2 then
            return "dontstarve/wilson/attack_deepfreezestaff_lvl2"
        elseif equip.icestaff_coldness > 1 then
            return "dontstarve/wilson/attack_deepfreezestaff"
        end
    end
    return "dontstarve/wilson/attack_icestaff"
end

local function DoEquipmentFoleySounds(inst)
    local inventory = inst.replica.inventory
    if inventory ~= nil then
        for k, v in pairs(inventory:GetEquips()) do
            if v.foleysound ~= nil then
                inst.SoundEmitter:PlaySound(v.foleysound, nil, nil, true)
            end
        end
    end
end

local function DoFoleySounds(inst)
    DoEquipmentFoleySounds(inst)
    if inst.foleysound ~= nil then
        inst.SoundEmitter:PlaySound(inst.foleysound, nil, nil, true)
    end
end

local function DoMountedFoleySounds(inst)
    DoEquipmentFoleySounds(inst)
    local rider = inst.replica.rider
    local saddle = rider ~= nil and rider:GetSaddle() or nil
    if saddle ~= nil and saddle.mounted_foleysound ~= nil then
        inst.SoundEmitter:PlaySound(saddle.mounted_foleysound, nil, nil, true)
    end
end

local function DoRunSounds(inst)
    if inst.sg.mem.footsteps > 3 then
        PlayFootstep(inst, .6, true)
    else
        inst.sg.mem.footsteps = inst.sg.mem.footsteps + 1
        PlayFootstep(inst, 1, true)
    end
end

local function PlayMooseFootstep(inst, volume, ispredicted)
    --moose footstep always full volume
    inst.SoundEmitter:PlaySound("dontstarve/characters/woodie/moose/footstep", nil, nil, ispredicted)
    PlayFootstep(inst, volume, ispredicted)
end

local function DoMooseRunSounds(inst)
    --moose footstep always full volume
    inst.SoundEmitter:PlaySound("dontstarve/characters/woodie/moose/footstep", nil, nil, true)
    DoRunSounds(inst)
end

local function DoMountSound(inst, mount, sound)
    if mount ~= nil and mount.sounds ~= nil then
        inst.SoundEmitter:PlaySound(mount.sounds[sound], nil, nil, true)
    end
end

--------------------------------------------------------------------------

local CheckPreviewChannelCastAction --forward declare

local function StopPreviewChannelCast(inst)
	if inst.sg.mem.preview_channelcast_task then
		inst.sg.mem.preview_channelcast_task:Cancel()
		inst.sg.mem.preview_channelcast_task = nil
		inst.sg.mem.preview_channelcast_action = nil
		inst:RemoveEventCallback("performaction", CheckPreviewChannelCastAction)
		inst.components.locomotor:RemovePredictExternalSpeedMultiplier(inst, "preview_channelcast")
	end
end

CheckPreviewChannelCastAction = function(inst)
	if inst:IsChannelCasting() == (inst.sg.mem.preview_channelcast_action.action == ACTIONS.START_CHANNELCAST) then
		StopPreviewChannelCast(inst)
	end
end

--Used for both START_CHANNELCAST and STOP_CHANNELCAST
local function StartPreviewChannelCast(inst, buffaction)
	if buffaction.action == ACTIONS.START_CHANNELCAST then
		if inst:IsChannelCasting() then
			StopPreviewChannelCast(inst)
			return
		end
		inst.components.locomotor:SetPredictExternalSpeedMultiplier(inst, "preview_channelcast", TUNING.CHANNELCAST_SPEED_MOD)
	elseif buffaction.action == ACTIONS.STOP_CHANNELCAST then
		if not inst:IsChannelCasting() then
			StopPreviewChannelCast(inst)
			return
		end
		inst.components.locomotor:SetPredictExternalSpeedMultiplier(inst, "preview_channelcast", 1 / TUNING.CHANNELCAST_SPEED_MOD)
	else
		StopPreviewChannelCast(inst)
		return
	end

	if inst.sg.mem.preview_channelcast_task then
		inst.sg.mem.preview_channelcast_task:Cancel()
	else
		inst:ListenForEvent("performaction", CheckPreviewChannelCastAction)
	end
	inst.sg.mem.preview_channelcast_task = inst:DoTaskInTime(TIMEOUT, StopPreviewChannelCast)
	inst.sg.mem.preview_channelcast_action = buffaction
end

local function IsChannelCasting(inst)
	--essentially prediction, since the actions aren't busy w/ lag states
```

#### Snippets (line-numbered)

**Snippet 1**
```lua
  224: end
  225: 
  226: local actionhandlers =
  227: {
  228:     ActionHandler(ACTIONS.CHOP,
  229:         function(inst)
  230:             if inst:HasTag("beaver") then
  231: 				return not (inst.sg:HasStateTag("gnawing") or inst:HasTag("gnawing")) and "gnaw" or nil
  232:             end
  233: 			return not (inst.sg:HasStateTag("prechop") or inst:HasTag("prechop")) and "chop_start" or nil
  234:         end),
  235:     ActionHandler(ACTIONS.MINE,
  236:         function(inst)
  237:             if inst:HasTag("beaver") then
  238: 				return not (inst.sg:HasStateTag("gnawing") or inst:HasTag("gnawing")) and "gnaw" or nil
  239:             end
  240: 			return not (inst.sg:HasStateTag("premine") or inst:HasTag("premine")) and "mine_start" or nil
  241:         end),
  242:     ActionHandler(ACTIONS.REMOVELUNARBUILDUP, -- Copy of ACTIONS.MINE
  243:         function(inst)
  244:             if inst:HasTag("beaver") then
  245:                 return not (inst.sg:HasStateTag("gnawing") or inst:HasTag("gnawing")) and "gnaw" or nil
  246:             end
  247:             return not (inst.sg:HasStateTag("premine") or inst:HasTag("premine")) and "mine_start" or nil
  248:         end),
  249:     ActionHandler(ACTIONS.HAMMER,
  250:         function(inst)
  251:             if inst:HasTag("beaver") then
  252: 				return not (inst.sg:HasStateTag("gnawing") or inst:HasTag("gnawing")) and "gnaw" or nil
  253:             end
  254: 			return not (inst.sg:HasStateTag("prehammer") or inst:HasTag("prehammer")) and "hammer_start" or nil
  255:         end),
  256:     ActionHandler(ACTIONS.TERRAFORM, "terraform"),
  257:     ActionHandler(ACTIONS.DIG,
  258:         function(inst)
  259:             if inst:HasTag("beaver") then
  260: 				return not (inst.sg:HasStateTag("gnawing") or inst:HasTag("gnawing")) and "gnaw" or nil
  261:             end
  262: 			return not (inst.sg:HasStateTag("predig") or inst:HasTag("predig")) and "dig_start" or nil
  263:         end),
  264:     ActionHandler(ACTIONS.NET,
  265:         function(inst, action)
  266:             if action.invobject and action.invobject:HasTag("nabbag") then
  267:                 return "nabbag"
  268:             end
```

**Snippet 2**
```lua
  271:             end
  272: 
  273:             return not inst.sg:HasStateTag("prenet") and (inst.sg:HasStateTag("netting") and "bugnet" or "bugnet_start") or nil
  274:         end),
  275:     ActionHandler(ACTIONS.FISH, "fishing_pre"),
  276:     ActionHandler(ACTIONS.OCEAN_FISHING_CAST, "oceanfishing_cast"),
  277:     ActionHandler(ACTIONS.OCEAN_FISHING_REEL,
  278:         function(inst, action)
  279:             local fishable = action.invobject ~= nil and action.invobject.replica.oceanfishingrod:GetTarget() or nil
  280:             if fishable ~= nil and fishable:HasTag("partiallyhooked") then
  281:                 return "oceanfishing_sethook"
```

**Snippet 3**
```lua
  283:                 return "oceanfishing_reel"
  284:             end
  285:             return nil
  286:         end),
  287:     ActionHandler(ACTIONS.FERTILIZE,
  288:         function(inst, action)
  289:             return (action.target ~= nil and action.target ~= inst and "doshortaction")
  290:                 or (action.invobject ~= nil and action.invobject:HasTag("slowfertilize") and "fertilize")
  291:                 or "fertilize_short"
  292:         end),
  293:     ActionHandler(ACTIONS.SMOTHER,
  294:         function(inst)
  295:             return inst:HasTag("pyromaniac") and "domediumaction" or "dolongaction"
  296:         end),
  297:     ActionHandler(ACTIONS.MANUALEXTINGUISH,
  298:         function(inst)
  299:             return inst:HasTag("pyromaniac") and "domediumaction" or "dolongaction"
  300:         end),
  301:     ActionHandler(ACTIONS.TRAVEL, "doshortaction"),
  302:     ActionHandler(ACTIONS.LIGHT, "catchonfire"),
  303:     ActionHandler(ACTIONS.UNLOCK, "give"),
  304:     ActionHandler(ACTIONS.USEKLAUSSACKKEY,
  305:         function(inst)
  306:             return inst:HasTag("quagmire_fasthands") and "domediumaction" or "dolongaction"
  307:         end),
  308:     ActionHandler(ACTIONS.TURNOFF, "give"),
  309:     ActionHandler(ACTIONS.TURNON, "give"),
  310:     ActionHandler(ACTIONS.YOTB_UNLOCKSKIN, "dolongaction"),
  311:     ActionHandler(ACTIONS.YOTB_SEW, "dolongaction"),
  312:     ActionHandler(ACTIONS.ADDFUEL, "doshortaction"),
  313:     ActionHandler(ACTIONS.ADDWETFUEL, "doshortaction"),
  314:     ActionHandler(ACTIONS.REPAIR, function(inst, action)
  315:         return action.target:HasTag("repairshortaction") and "doshortaction" or "dolongaction"
  316:     end),
  317:     ActionHandler(ACTIONS.READ,
  318:         function(inst, action)
  319: 			return	(action.invobject ~= nil and action.invobject:HasTag("simplebook")) and "cookbook_open"
  320: 					or inst:HasTag("aspiring_bookworm") and "book_peruse"
  321: 					or "book"
  322:         end),
  323: 	ActionHandler(ACTIONS.MAKEBALLOON, "dolongaction"),
  324: 	ActionHandler(ACTIONS.DEPLOY, function(inst, action) 
  325:             if action.invobject and action.invobject:HasTag("graveplanter") then
  326:                 return "graveurn_out"
  327:             end
  328:             return action.invobject and action.invobject:HasTag("projectile") and "throw_deploy" or "doshortaction" 
  329:         end),
  330:     ActionHandler(ACTIONS.DEPLOY_TILEARRIVE, "doshortaction"),
  331: 	ActionHandler(ACTIONS.DEPLOY_FLOATING, "float_action"),
  332:     ActionHandler(ACTIONS.STORE, "doshortaction"),
  333:     ActionHandler(ACTIONS.DROP,
  334:         function(inst)
  335:             return inst.replica.inventory:IsHeavyLifting()
  336:                 and not (inst.replica.rider ~= nil and inst.replica.rider:IsRiding())
  337:                 and "heavylifting_drop"
  338:                 or "doshortaction"
  339:         end),
  340:     ActionHandler(ACTIONS.MURDER,
  341:         function(inst)
  342:             return inst:HasTag("quagmire_fasthands") and "domediumaction" or "dolongaction"
  343:         end),
  344:     ActionHandler(ACTIONS.UPGRADE, "dolongaction"),
  345:     ActionHandler(ACTIONS.ACTIVATE,
  346:         function(inst, action)
  347: 			return (	action.target:HasTag("engineering") and (
  348: 							(inst:HasTag("scientist") and "dolongaction") or
  349: 							(not inst:HasTag("handyperson") and "dolongestaction")
```

**Snippet 4**
```lua
  352: 				or (action.target:HasTag("standingactivation") and "dostandingaction")
  353:                 or (action.target:HasTag("quickactivation") and "doshortaction")
  354:                 or "dolongaction"
  355:         end),
  356:     ActionHandler(ACTIONS.OPEN_CRAFTING, "dostandingaction"),
  357:     ActionHandler(ACTIONS.PICK,
  358:         function(inst, action)
  359: 			return (action.target:HasTag("noquickpick") and "dolongaction")
  360: 				or (inst:HasTag("farmplantfastpicker") and action.target:HasTag("farm_plant") and "domediumaction")
  361: 				or (inst.replica.rider ~= nil and inst.replica.rider:IsRiding() and (
```

**Snippet 5**
```lua
  368: 				or (inst:HasTag("woodiequickpicker") and "dowoodiefastpick")
  369:                 or (inst:HasTag("quagmire_fasthands") and "domediumaction")
  370:                 or "dolongaction"
  371:         end),
  372:     ActionHandler(ACTIONS.CARNIVALGAME_FEED,
  373:         function(inst, action)
  374:             return (inst.replica.rider ~= nil and inst.replica.rider:IsRiding() and "dolongaction")
  375: 				or "doequippedaction"
  376:         end),
  377:     ActionHandler(ACTIONS.SLEEPIN,
  378:         function(inst, action)
  379:             return action.invobject ~= nil and "bedroll" or "tent"
  380:         end),
  381:     ActionHandler(ACTIONS.TAKEITEM,
  382:         function(inst, action)
  383:             return
  384:                    (action.target ~= nil and action.target:HasTag("inventoryitemholder_take") and "domediumaction")
  385:                 or (action.target ~= nil and action.target.takeitem ~= nil and "give")
  386:                 or "dolongaction"
  387:         end),
  388:     ActionHandler(ACTIONS.TAKESINGLEITEM,
  389:         function(inst, action)
  390:             return
  391:                    (action.target ~= nil and action.target:HasTag("inventoryitemholder_take") and "domediumaction")
  392:                 or (action.target ~= nil and action.target.takeitem ~= nil and "give")
  393:                 or "dolongaction"
  394:         end),
  395:     ActionHandler(ACTIONS.BUILD,
  396:         function(inst, action)
  397:             local rec = GetValidRecipe(action.recipe)
  398: 			return (rec and FunctionOrValue(rec.sg_state, rec, inst))
  399:                 or (inst:HasTag("hungrybuilder") and "dohungrybuild")
  400:                 or (inst:HasTag("fastbuilder") and "domediumaction")
  401:                 or (inst:HasTag("slowbuilder") and "dolongestaction")
  402:                 or "dolongaction"
  403:         end),
  404: 	ActionHandler(ACTIONS.SHAVE, "dolongaction"),
  405:     ActionHandler(ACTIONS.COOK,
  406:         function(inst, action)
  407:             return inst:HasTag("expertchef") and "domediumaction" or "dolongaction"
  408:         end),
  409:     ActionHandler(ACTIONS.FILL, "dolongaction"),
  410:     ActionHandler(ACTIONS.FILL_OCEAN, "dolongaction"),
  411: 
  412:     ActionHandler(ACTIONS.PICKUP, function(inst, action)
  413:             return (inst.replica.rider ~= nil and inst.replica.rider:IsRiding()
  414:                     and (action.target ~= nil and action.target:HasTag("heavy") and "dodismountaction"
  415:                         or "domediumaction")
  416:                     )
  417:                 or "doshortaction"
  418:         end),
  419:     ActionHandler(ACTIONS.NABBAG, "nabbag"),
  420:     ActionHandler(ACTIONS.CHECKTRAP,
  421:         function(inst, action)
  422:             return (inst.replica.rider ~= nil and inst.replica.rider:IsRiding() and "domediumaction")
  423:                 or "doshortaction"
  424:         end),
  425: 	ActionHandler(ACTIONS.RUMMAGE,
  426: 		function(inst, action)
  427: 			if action.invobject then
  428: 				if action.invobject:HasTag("portablestorage") then
  429: 					local container = action.invobject.replica.container
```

**Snippet 6**
```lua
  440: 				end
  441: 			end
  442: 			return "doshortaction"
  443: 		end),
  444:     ActionHandler(ACTIONS.BAIT, "doshortaction"),
  445:     ActionHandler(ACTIONS.HEAL, function(inst, action)
  446:         return inst:HasTag("fasthealer") and "domediumaction" or "dolongaction"
  447:     end),
  448:     ActionHandler(ACTIONS.SEW, "dolongaction"),
  449:     ActionHandler(ACTIONS.TEACH, "dolongaction"),
  450:     ActionHandler(ACTIONS.RESETMINE, "dolongaction"),
  451:     ActionHandler(ACTIONS.EAT,
  452:         function(inst, action)
  453:             if inst.sg:HasStateTag("busy") or inst:HasTag("busy") then
  454:                 return
  455:             end
```

**Snippet 7**
```lua
  469: 				return "float_"..state
  470: 			end
  471: 			return state
  472:         end),
  473:     ActionHandler(ACTIONS.GIVE,
  474:         function(inst, action)
  475:             return action.invobject ~= nil
  476:                 and action.target ~= nil
  477:                 and (   (action.target:HasTag("moonportal") and action.invobject:HasTag("moonportalkey") and "dochannelaction") or
```

**Snippet 8**
```lua
  479:                         (action.target:HasTag("give_dolongaction") and "dolongaction")
  480:                     )
  481:                 or "give"
  482:         end),
  483:     ActionHandler(ACTIONS.APPRAISE, "give"),
  484:     ActionHandler(ACTIONS.GIVETOPLAYER, "give"),
  485:     ActionHandler(ACTIONS.GIVEALLTOPLAYER, "give"),
  486:     ActionHandler(ACTIONS.FEEDPLAYER, "give"),
  487:     ActionHandler(ACTIONS.DECORATEVASE, "dolongaction"),
  488:     ActionHandler(ACTIONS.PLANT, "doshortaction"),
  489:     ActionHandler(ACTIONS.HARVEST,
  490:         function(inst)
  491:             return inst:HasTag("quagmire_fasthands") and "domediumaction" or "dolongaction"
  492:         end),
  493: 	ActionHandler(ACTIONS.PLAY,
  494: 		function(inst, action)
  495: 			if action.invobject ~= nil then
  496: 				return (action.invobject:HasTag("flute") and "play_flute")
  497: 					or (action.invobject:HasTag("horn") and "play_horn")
```

**Snippet 9**
```lua
  499: 					or (action.invobject:HasTag("whistle") and "play_whistle")
  500: 					or nil
  501: 			end
  502: 		end),
  503:     ActionHandler(ACTIONS.JUMPIN, "jumpin_pre"),
  504:     ActionHandler(ACTIONS.JUMPIN_MAP, "jumpin_pre"),
  505:     ActionHandler(ACTIONS.TELEPORT,
  506:         function(inst, action)
  507:             return action.invobject ~= nil and "dolongaction" or "give"
  508:         end),
  509:     ActionHandler(ACTIONS.FAN, "use_fan"),
  510:     ActionHandler(ACTIONS.ERASE_PAPER, "dolongaction"),
  511:     ActionHandler(ACTIONS.DRY, "doshortaction"),
  512:     ActionHandler(ACTIONS.CASTSPELL,
  513:         function(inst, action)
  514:             return action.invobject ~= nil
  515:                 and ((action.invobject:HasTag("gnarwail_horn") and "play_gnarwail_horn")
  516:                     or (action.invobject:HasTag("guitar") and "play_strum")
```

**Snippet 10**
```lua
  521:                     or (action.invobject:HasTag("mermbuffcast") and "mermbuffcastspell")
  522:                     )
  523:                 or "castspell"
  524:         end),
  525:     ActionHandler(ACTIONS.CASTAOE,
  526:         function(inst, action)
  527:             return action.invobject ~= nil
  528: 				and (	(action.invobject:HasTag("book") and "book") or
  529: 						(action.invobject:HasTag("willow_ember") and "castspellmind") or
```

## Category: LootTables

### File: scripts/prefabs/deciduoustrees.lua
> sha256_12=abeb7b437c95, lines=1458

#### Head
```lua
local assets =
{
    Asset("ANIM", "anim/tree_leaf_short.zip"),
    Asset("ANIM", "anim/tree_leaf_normal.zip"),
    Asset("ANIM", "anim/tree_leaf_tall.zip"),
    Asset("ANIM", "anim/tree_leaf_monster.zip"),
    Asset("ANIM", "anim/tree_leaf_trunk_build.zip"), --trunk build (winter leaves build)
    Asset("ANIM", "anim/tree_leaf_green_build.zip"), --spring, summer leaves build
    Asset("ANIM", "anim/tree_leaf_red_build.zip"), --autumn leaves build
    Asset("ANIM", "anim/tree_leaf_orange_build.zip"), --autumn leaves build
    Asset("ANIM", "anim/tree_leaf_yellow_build.zip"), --autumn leaves build
    Asset("ANIM", "anim/tree_leaf_poison_build.zip"), --poison leaves build
    Asset("SOUND", "sound/forest.fsb"),
    Asset("SOUND", "sound/deciduous.fsb"),
    Asset("MINIMAP_IMAGE", "tree_leaf"),
    Asset("MINIMAP_IMAGE", "tree_leaf_burnt"),
    Asset("MINIMAP_IMAGE", "tree_leaf_stump"),
}

local prefabs =
{
    "log",
    "acorn",
    "charcoal",
    "green_leaves",
    "red_leaves",
    "orange_leaves",
    "yellow_leaves",
    "purple_leaves",
    "green_leaves_chop",
    "red_leaves_chop",
    "orange_leaves_chop",
    "yellow_leaves_chop",
    "purple_leaves_chop",
    "deciduous_root",
    "livinglog",
    "nightmarefuel",
    "spoiled_food",
    "birchnutdrake",
    "small_puff",
}

local builds =
{
    normal = { --Green
        leavesbuild="tree_leaf_green_build",
        prefab_name="deciduoustree",
        normal_loot = {"log", "log"},
        short_loot = {"log"},
        tall_loot = {"log", "log", "log", "acorn"},
        drop_acorns=true,
        fx="green_leaves",
        chopfx="green_leaves_chop",
        shelter=true,
    },
    barren = {
        leavesbuild=nil,
        prefab_name="deciduoustree",
        normal_loot = {"log", "log"},
        short_loot = {"log"},
        tall_loot = {"log", "log", "log"},
        drop_acorns=false,
        fx=nil,
        chopfx=nil,
        shelter=false,
    },
    red = {
        leavesbuild="tree_leaf_red_build",
        prefab_name="deciduoustree",
        normal_loot = {"log", "log"},
        short_loot = {"log"},
        tall_loot = {"log", "log", "log", "acorn"},
        drop_acorns=true,
        fx="red_leaves",
        chopfx="red_leaves_chop",
        shelter=true,
    },
    orange = {
        leavesbuild="tree_leaf_orange_build",
        prefab_name="deciduoustree",
        normal_loot = {"log", "log"},
        short_loot = {"log"},
        tall_loot = {"log", "log", "log", "acorn"},
        drop_acorns=true,
        fx="orange_leaves",
        chopfx="orange_leaves_chop",
        shelter=true,
    },
    yellow = {
        leavesbuild="tree_leaf_yellow_build",
        prefab_name="deciduoustree",
        normal_loot = {"log", "log"},
        short_loot = {"log"},
        tall_loot = {"log", "log", "log", "acorn"},
        drop_acorns=true,
        fx="yellow_leaves",
        chopfx="yellow_leaves_chop",
        shelter=true,
    },
    poison = {
        leavesbuild="tree_leaf_poison_build",
        prefab_name="deciduoustree",
        normal_loot = {"livinglog", "acorn", "acorn"},
        short_loot = {"livinglog", "acorn"},
        tall_loot = {"livinglog", "acorn", "acorn", "acorn"},
        drop_acorns=true,
        fx="purple_leaves",
        chopfx="purple_leaves_chop",
        shelter=true,
    },
}

local function makeanims(stage)
    if stage == "monster" then
        return {
            idle="idle_tall",
            sway1="sway_loop_agro",
            sway2="sway_loop_agro",
            swayaggropre="sway_agro_pre",
            swayaggro="sway_loop_agro",
```

#### Snippets (line-numbered)

**Snippet 1**
```lua
  261:     end
  262: 
  263:     if inst.components.growable ~= nil then
  264:         if inst.components.growable.stage == 1 then
  265:             inst.components.lootdropper:SetLoot(GetBuild(inst).short_loot)
  266:         elseif inst.components.growable.stage == 2 then
  267:             inst.components.lootdropper:SetLoot(GetBuild(inst).normal_loot)
  268:         else
  269:             inst.components.lootdropper:SetLoot(GetBuild(inst).tall_loot)
  270:         end
  271:     end
  272: 
  273:     inst.leaf_state = inst.target_leaf_state
```

**Snippet 2**
```lua
  365:         if inst.components.workable ~= nil then
  366:            inst.components.workable:SetWorkLeft(TUNING.DECIDUOUS_CHOPS_SMALL)
  367:         end
  368:         SetLunarHailBuildupAmountSmall(inst)
  369:         inst.components.lootdropper:SetLoot(GetBuild(inst).short_loot)
  370:     end
  371: end
  372: 
  373: local function GrowShort(inst)
```

**Snippet 3**
```lua
  386:     if inst.components.workable ~= nil then
  387:         inst.components.workable:SetWorkLeft(TUNING.DECIDUOUS_CHOPS_NORMAL)
  388:     end
  389:     SetLunarHailBuildupAmountMedium(inst)
  390:     inst.components.lootdropper:SetLoot(GetBuild(inst).normal_loot)
  391: end
  392: 
  393: local function GrowNormal(inst)
  394:     inst.AnimState:PlayAnimation("grow_short_to_normal")
```

**Snippet 4**
```lua
  404:     if inst.components.workable ~= nil then
  405:         inst.components.workable:SetWorkLeft(TUNING.DECIDUOUS_CHOPS_TALL)
  406:     end
  407:     SetLunarHailBuildupAmountLarge(inst)
  408:     inst.components.lootdropper:SetLoot(GetBuild(inst).tall_loot)
  409: end
  410: 
  411: local function GrowTall(inst)
  412:     inst.AnimState:PlayAnimation("grow_normal_to_tall")
```

**Snippet 5**
```lua
  458:     end
  459: end
  460: 
  461: local function dig_up_stump(inst)
  462:     inst.components.lootdropper:SpawnLootPrefab(inst.monster and "livinglog" or "log")
  463:     inst:Remove()
  464: end
  465: 
  466: local function chop_down_tree_shake(inst)
```

**Snippet 6**
```lua
  575:     end
  576: 
  577:     if inst.monster then
  578:         inst.SoundEmitter:PlaySound("dontstarve_DLC001/creatures/deciduous/death")
  579:         inst.components.lootdropper:AddChanceLoot("livinglog", TUNING.DECID_MONSTER_ADDITIONAL_LOOT_CHANCE)
  580:         inst.components.lootdropper:AddChanceLoot("nightmarefuel", TUNING.DECID_MONSTER_ADDITIONAL_LOOT_CHANCE)
  581:         if inst.monster_stop_task ~= nil then
  582:             inst.monster_stop_task:Cancel()
  583:             inst.monster_stop_task = nil
  584:         end
```

**Snippet 7**
```lua
  604:     local he_right = (hispos - pt):Dot(TheCamera:GetRightVec()) > 0
  605:     if he_right then
  606:         inst.AnimState:PlayAnimation(inst.anims.fallleft)
  607:         if inst.components.growable ~= nil and inst.components.growable.stage == 3 and inst.leaf_state == "colorful" then
  608:             inst.components.lootdropper:SpawnLootPrefab("acorn", pt - TheCamera:GetRightVec())
  609:         end
  610:         inst.components.lootdropper:DropLoot(pt - TheCamera:GetRightVec())
  611:     else
  612:         inst.AnimState:PlayAnimation(inst.anims.fallright)
  613:         if inst.components.growable ~= nil and inst.components.growable.stage == 3 and inst.leaf_state == "colorful" then
  614:             inst.components.lootdropper:SpawnLootPrefab("acorn", pt + TheCamera:GetRightVec())
  615:         end
  616:         inst.components.lootdropper:DropLoot(pt + TheCamera:GetRightVec())
  617:     end
  618: 
  619:     inst:DoTaskInTime(.4, chop_down_tree_shake)
  620:
```

**Snippet 8**
```lua
  629:     inst.SoundEmitter:PlaySound("dontstarve/wilson/use_axe_tree")
  630:     inst.AnimState:PlayAnimation(inst.anims.chop_burnt)
  631:     RemovePhysicsColliders(inst)
  632:     inst:ListenForEvent("animover", inst.Remove)
  633:     inst.components.lootdropper:SpawnLootPrefab("charcoal")
  634:     inst.components.lootdropper:DropLoot()
  635:     if inst.acorntask ~= nil then
  636:         inst.acorntask:Cancel()
  637:         inst.acorntask = nil
  638:     end
```

**Snippet 9**
```lua
  662:         inst.monster_stop_task:Cancel()
  663:         inst.monster_stop_task = nil
  664:     end
  665: 
  666:     inst.components.lootdropper:SetLoot({})
  667:     if GetBuild(inst).drop_acorns then
  668:         inst.components.lootdropper:AddChanceLoot("acorn", .1)
  669:     end
  670: 
  671:     if inst.components.workable ~= nil then
  672:         inst.components.workable:SetWorkLeft(1)
```

**Snippet 10**
```lua
  727: end
  728: 
  729: local function OnAcornTask(inst)
  730:     inst.acorntask = nil
  731:     inst.components.lootdropper:DropLoot(math.random() < .5 and inst:GetPosition() + TheCamera:GetRightVec() or inst:GetPosition() - TheCamera:GetRightVec())
  732: end
  733: 
  734: local function tree_burnt(inst)
  735:     OnBurnt(inst)
```
### File: scripts/prefabs/evergreens.lua
> sha256_12=bfdc4b4c2c58, lines=993

#### Head
```lua
local assets =
{
    Asset("ANIM", "anim/evergreen_new.zip"), --build
    Asset("ANIM", "anim/evergreen_new_2.zip"), --build
    Asset("ANIM", "anim/evergreen_tall_old.zip"),
    Asset("ANIM", "anim/evergreen_short_normal.zip"),

    Asset("SOUND", "sound/forest.fsb"),
    Asset("MINIMAP_IMAGE", "evergreen_lumpy"),

    Asset("MINIMAP_IMAGE", "evergreen_burnt"),
    Asset("MINIMAP_IMAGE", "evergreen_stump"),
}

local twiggy_assets =
{
    Asset("ANIM", "anim/twiggy_build.zip"), --build
    Asset("ANIM", "anim/twiggy_short_normal.zip"),
    Asset("ANIM", "anim/twiggy_tall_old.zip"),

    Asset("SOUND", "sound/forest.fsb"),
    Asset("MINIMAP_IMAGE", "twiggy"),

    Asset("MINIMAP_IMAGE", "twiggy_burnt"),
    Asset("MINIMAP_IMAGE", "twiggy_stump"),
}

local prefabs =
{
    "log",
    "pinecone",
    "charcoal",
    "leif",
    "leif_sparse",
    "pine_needles_chop",
    "rock_petrified_tree_short",
    "rock_petrified_tree_med",
    "rock_petrified_tree_tall",
    "rock_petrified_tree_old",
    "petrified_tree_fx_short",
    "petrified_tree_fx_normal",
    "petrified_tree_fx_tall",
    "petrified_tree_fx_old",
    "petrified_trunk_break_fx",
    "small_puff",
}

local twiggy_prefabs =
{
    "log",
    "twigs",
    "twiggy_nut",
    "charcoal",
    "small_puff",
}

local builds =
{
    normal = {
        file="evergreen_new",
        file_bank = "evergreen_short",
        prefab_name="evergreen",
        regrowth_product="pinecone_sapling",
        regrowth_tuning=TUNING.EVERGREEN_REGROWTH,
        grow_times=TUNING.EVERGREEN_GROW_TIME,
        normal_loot = {"log", "log", "pinecone"},
        short_loot = {"log"},
        tall_loot = {"log", "log", "log", "pinecone", "pinecone"},
        drop_pinecones=true,
        leif="leif",
        chop_camshake_delay=0.4,
    },
    sparse = {
        file="evergreen_new_2",
        file_bank = "evergreen_short",
        prefab_name="evergreen_sparse",
        regrowth_product="lumpy_sapling",
        regrowth_tuning=TUNING.EVERGREEN_SPARSE_REGROWTH,
        grow_times=TUNING.EVERGREEN_GROW_TIME,
        normal_loot = {"log","log"},
        short_loot = {"log"},
        tall_loot = {"log", "log","log"},
        drop_pinecones=false,
        leif="leif_sparse",
        chop_camshake_delay=0.4,
    },
    twiggy = {
        file="twiggy_build",
        file_bank = "twiggy",
        prefab_name="twiggytree",
        regrowth_product="twiggy_nut_sapling",
        regrowth_tuning=TUNING.EVERGREEN_REGROWTH,
        grow_times=TUNING.TWIGGY_TREE_GROW_TIME,
        normal_loot = {"log","twigs","twiggy_nut"},
        short_loot = {"twigs"},
        tall_loot = {"log", "twigs","twigs","twiggy_nut","twiggy_nut"},
        drop_pinecones=false,
        rebirth_loot = {loot="twigs", max=2},
        chop_camshake_delay=20*FRAMES,
    },
}

local function makeanims(stage)
    return {
        idle="idle_"..stage,
        sway1="sway1_loop_"..stage,
        sway2="sway2_loop_"..stage,
        chop="chop_"..stage,
        fallleft="fallleft_"..stage,
        fallright="fallright_"..stage,
        stump="stump_"..stage,
        burning="burning_loop_"..stage,
        burnt="burnt_"..stage,
        chop_burnt="chop_burnt_"..stage,
        idle_chop_burnt="idle_chop_burnt_"..stage,
    }
end

local short_anims = makeanims("short")
local tall_anims = makeanims("tall")
```

#### Snippets (line-numbered)

**Snippet 1**
```lua
  134:     idle_chop_burnt="idle_chop_burnt_tall",
  135: }
  136: 
  137: local function dig_up_stump(inst, chopper)
  138:     inst.components.lootdropper:SpawnLootPrefab("log")
  139:     inst:Remove()
  140: end
  141: 
  142: local function chop_down_burnt_tree(inst, chopper)
```

**Snippet 2**
```lua
  147:     end
  148:     inst.AnimState:PlayAnimation(inst.anims.chop_burnt)
  149:     RemovePhysicsColliders(inst)
  150:     inst:ListenForEvent("animover", inst.Remove)
  151:     inst.components.lootdropper:SpawnLootPrefab("charcoal")
  152:     inst.components.lootdropper:DropLoot()
  153:     if inst.pineconetask ~= nil then
  154:         inst.pineconetask:Cancel()
  155:         inst.pineconetask = nil
  156:     end
```

**Snippet 3**
```lua
  172:         inst:RemoveComponent("petrifiable")
  173:         inst:RemoveTag("shelter")
  174:         MakeHauntableWork(inst)
  175: 
  176:         inst.components.lootdropper:SetLoot({})
  177:         if GetBuild(inst).drop_pinecones then
  178:             inst.components.lootdropper:AddChanceLoot("pinecone", 0.1)
  179:         end
  180: 
  181:         if GetBuild(inst).drop_pinecones_twiggy then
  182:             inst.components.lootdropper:AddChanceLoot("twiggy_nut", 0.1)
  183:         end
  184: 
  185:         if inst.components.workable then
  186:             inst.components.workable:SetWorkLeft(1)
```

**Snippet 4**
```lua
  219:         end
  220:         local prob = 1-(numloot/rebirth_loot.max)
  221:         if math.random() < prob then
  222:             inst:DoTaskInTime(17*FRAMES, function()
  223:                 inst.components.lootdropper:SpawnLootPrefab(rebirth_loot.loot)
  224:             end)
  225:         end
  226:         inst._lastrebirth = GetTime()
  227:     end
```

**Snippet 5**
```lua
  242:         inst.components.workable:SetWorkLeft(TUNING.EVERGREEN_CHOPS_SMALL)
  243:     end
  244:     SetLunarHailBuildupAmountSmall(inst)
  245: 
  246:     inst.components.lootdropper:SetLoot(GetBuild(inst).short_loot)
  247: 
  248:     if inst.build ~= "twiggy" then
  249:         inst:AddTag("shelter")
  250:     end
```

**Snippet 6**
```lua
  266:         inst.components.workable:SetWorkLeft(TUNING.EVERGREEN_CHOPS_NORMAL)
  267:     end
  268:     SetLunarHailBuildupAmountMedium(inst)
  269: 
  270:     inst.components.lootdropper:SetLoot(GetBuild(inst).normal_loot)
  271: 
  272:     if inst.build ~= "twiggy" then
  273:         inst:AddTag("shelter")
  274:     end
```

**Snippet 7**
```lua
  288:         inst.components.workable:SetWorkLeft(TUNING.EVERGREEN_CHOPS_TALL)
  289:     end
  290:     SetLunarHailBuildupAmountLarge(inst)
  291: 
  292:     inst.components.lootdropper:SetLoot(GetBuild(inst).tall_loot)
  293: 
  294:     if inst.build ~= "twiggy" then
  295:         inst:AddTag("shelter")
  296:     end
```

**Snippet 8**
```lua
  311:         inst.components.workable:SetWorkLeft(1)
  312:     end
  313: 
  314:     if GetBuild(inst).drop_pinecones then
  315:         inst.components.lootdropper:SetLoot({"pinecone"})
  316:     elseif GetBuild(inst).drop_pinecones_twiggy then
  317:         inst.components.lootdropper:SetLoot({"twiggy_nut"})
  318:     else
  319: 
  320:         inst.components.lootdropper:SetLoot({})
  321:     end
  322: 
  323:     inst:RemoveTag("shelter")
  324:
```

**Snippet 9**
```lua
  499:     end
  500: 
  501:     if he_right then
  502:         inst.AnimState:PlayAnimation(inst.anims.fallleft)
  503:         inst.components.lootdropper:DropLoot(pt - TheCamera:GetRightVec())
  504:     else
  505:         inst.AnimState:PlayAnimation(inst.anims.fallright)
  506:         inst.components.lootdropper:DropLoot(pt + TheCamera:GetRightVec())
  507:     end
  508: 
  509:     if inst.build ~= "twiggy" then
  510:         inst:DoTaskInTime(GetBuild(inst).chop_camshake_delay, chop_down_tree_shake)
```

**Snippet 10**
```lua
  540:     local pt = inst:GetPosition()
  541:     local angle = math.random() * TWOPI
  542:     pt.x = pt.x + math.cos(angle)
  543:     pt.z = pt.z + math.sin(angle)
  544:     inst.components.lootdropper:DropLoot(pt)
  545:     inst.pineconetask = nil
  546:     inst.burntcone = true
  547: end
  548:
```

## Category: Components

### File: scripts/components/scenariorunner.lua
> sha256_12=113cd7848f23, lines=64

#### Head
```lua
local ScenarioRunner = Class(function(self, inst)
    self.inst = inst
	self.scriptname = nil
	self.script = nil
	self.hasrunonce = false
end)

function ScenarioRunner:OnLoad(data)
	if data then
		if data.scriptname then
			self:SetScript(data.scriptname)
		end
		if data.hasrunonce then
			self.hasrunonce = data.hasrunonce
		end
	end
end

function ScenarioRunner:OnSave()
	local data = {}
	data.hasrunonce = self.hasrunonce
	if self.scriptname then data.scriptname = self.scriptname end
	return data
end

function ScenarioRunner:SetScript(name)
	if self.scriptname ~= nil then
		print("Warning! The scenario runner on "..self.inst.name.." already has a script '"..self.scriptname.."' but we are adding a script '"..name.."'")
	end
	self.scriptname = name
	self.script = require("scenarios/"..name)
	assert(self.script.OnCreate or self.script.OnLoad, "Scenario '"..name.."' doesn't export an OnLoad or OnCreate.")
end

function ScenarioRunner:Run()
	if not self.hasrunonce and self.script.OnCreate then
		self.script.OnCreate(self.inst, self)
		self.hasrunonce = true
	end

	if self.script.OnLoad then
		self.script.OnLoad(self.inst, self)
	else
		self:ClearScenario()
	end
end

function ScenarioRunner:ClearScenario()
	self.inst:RemoveComponent("scenariorunner")
	if self.script.OnDestroy then
		self.script.OnDestroy(self.inst)
	end
end

function ScenarioRunner:Reset()
	if self.script.OnDestroy then
		self.script.OnDestroy(self.inst)
	end
	self.script = nil
	self.scriptname = nil
	self.hasrunonce = false
end

return ScenarioRunner
```

#### Snippets (line-numbered)

**Snippet 1**
```lua
    1: local ScenarioRunner = Class(function(self, inst)
    2:     self.inst = inst
    3: 	self.scriptname = nil
    4: 	self.script = nil
    5: 	self.hasrunonce = false
    6: end)
    7: 
    8: function ScenarioRunner:OnLoad(data)
    9: 	if data then
   10: 		if data.scriptname then
   11: 			self:SetScript(data.scriptname)
   12: 		end
```

**Snippet 2**
```lua
   15: 		end
   16: 	end
   17: end
   18: 
   19: function ScenarioRunner:OnSave()
   20: 	local data = {}
   21: 	data.hasrunonce = self.hasrunonce
   22: 	if self.scriptname then data.scriptname = self.scriptname end
   23: 	return data
```

**Snippet 3**
```lua
   28: 		print("Warning! The scenario runner on "..self.inst.name.." already has a script '"..self.scriptname.."' but we are adding a script '"..name.."'")
   29: 	end
   30: 	self.scriptname = name
   31: 	self.script = require("scenarios/"..name)
   32: 	assert(self.script.OnCreate or self.script.OnLoad, "Scenario '"..name.."' doesn't export an OnLoad or OnCreate.")
   33: end
   34: 
   35: function ScenarioRunner:Run()
   36: 	if not self.hasrunonce and self.script.OnCreate then
   37: 		self.script.OnCreate(self.inst, self)
   38: 		self.hasrunonce = true
   39: 	end
   40: 
   41: 	if self.script.OnLoad then
   42: 		self.script.OnLoad(self.inst, self)
   43: 	else
   44: 		self:ClearScenario()
   45: 	end
   46: end
```
### File: scripts/components/debuffable.lua
> sha256_12=6b54db69ec53, lines=174

#### Head
```lua
local function onenable(self, enable)
    if enable then
        self.inst:AddTag("debuffable")
    else
        self.inst:RemoveTag("debuffable")
    end
end

local Debuffable = Class(function(self, inst)
    self.inst = inst
    self.enable = true
    self.followsymbol = ""
    self.followoffset = Vector3(0, 0, 0)
    self.debuffs = {}

    --V2C: Recommended to explicitly add tag to prefab pristine state
    --inst:AddTag("debuffable")
end,
nil,
{
    enable = onenable,
})

function Debuffable:IsEnabled()
    return self.enable
end

function Debuffable:Enable(enable)
    self.enable = enable
    if not enable then
        local k = next(self.debuffs)
        while k ~= nil do
            self:RemoveDebuff(k)
            k = next(self.debuffs)
        end
    end
end

function Debuffable:RemoveOnDespawn()
    local toremove = {}
    for k, v in pairs(self.debuffs) do
        if not (v.inst.components.debuff ~= nil and v.inst.components.debuff.keepondespawn) then
            table.insert(toremove, k)
        end
    end
    for i, v in ipairs(toremove) do
        self:RemoveDebuff(v)
    end
end

function Debuffable:SetFollowSymbol(symbol, x, y, z)
    self.followsymbol = symbol
    self.followoffset.x = x
    self.followoffset.y = y
    self.followoffset.z = z
    for k, v in pairs(self.debuffs) do
        if v.inst.components.debuff ~= nil then
            v.inst.components.debuff:ChangeFollowSymbol(symbol, self.followoffset)
        end
    end
end

function Debuffable:HasDebuff(name)
    return self.debuffs[name] ~= nil
end

function Debuffable:GetDebuff(name)
    local debuff = self.debuffs[name]
    return debuff ~= nil and debuff.inst or nil
end

local function RegisterDebuff(self, name, ent, data, buffer)
    if ent.components.debuff ~= nil then
        self.debuffs[name] =
        {
            inst = ent,
            onremove = function(debuff)
							self.debuffs[name] = nil
							if self.ondebuffremoved ~= nil then
								self.ondebuffremoved(self.inst, name, debuff)
							end
						end,
        }
        self.inst:ListenForEvent("onremove", self.debuffs[name].onremove, ent)
        ent.persists = false
        ent.components.debuff:AttachTo(name, self.inst, self.followsymbol, self.followoffset, data, buffer)
		if self.ondebuffadded ~= nil then
			self.ondebuffadded(self.inst, name, ent, data, buffer)
		end
    else
        ent:Remove()
    end
end

function Debuffable:AddDebuff(name, prefab, data, buffer)
    if self.enable then
		if self.debuffs[name] == nil then
			local ent = SpawnPrefab(prefab)
			if ent ~= nil then
				RegisterDebuff(self, name, ent, data, buffer)
			end
			return ent
		else
			self.debuffs[name].inst.components.debuff:Extend(self.followsymbol, self.followoffset, data, buffer)
			return self.debuffs[name].inst
		end
    end
end

function Debuffable:RemoveDebuff(name)
    local debuff = self.debuffs[name]
    if debuff ~= nil then
        self.debuffs[name] = nil
        self.inst:RemoveEventCallback("onremove", debuff.onremove, debuff.inst)
		if self.ondebuffremoved ~= nil then
			self.ondebuffremoved(self.inst, name, debuff.inst)
		end
        if debuff.inst.components.debuff ~= nil then
            debuff.inst.components.debuff:OnDetach()
        else
```

#### Snippets (line-numbered)

**Snippet 1**
```lua
    5:         self.inst:RemoveTag("debuffable")
    6:     end
    7: end
    8: 
    9: local Debuffable = Class(function(self, inst)
   10:     self.inst = inst
   11:     self.enable = true
   12:     self.followsymbol = ""
   13:     self.followoffset = Vector3(0, 0, 0)
```

**Snippet 2**
```lua
  122:         end
  123:     end
  124: end
  125: 
  126: function Debuffable:OnSave()
  127:     if next(self.debuffs) == nil then
  128:         return
  129:     end
  130:
```

**Snippet 3**
```lua
  135:     end
  136:     return { debuffs = data, add_component_if_missing = true }
  137: end
  138: 
  139: function Debuffable:OnLoad(data)
  140:     if data ~= nil and data.debuffs ~= nil then
  141:         for k, v in pairs(data.debuffs) do
  142:             if self.debuffs[k] == nil then
  143:                 local ent = SpawnSaveRecord(v)
```

**Snippet 4**
```lua
  149:     end
  150: end
  151: 
  152: function Debuffable:TransferComponent(newinst)
  153:     local data = self:OnSave()
  154:     if data then
  155:         local newcomponent = newinst.components.debuffable
  156:         if not newcomponent then
  157:             newinst:AddComponent("debuffable")
  158:             newcomponent = newinst.components.debuffable
  159:         end
  160:         newcomponent:OnLoad(data)
  161:     end
  162: end
  163: 
  164: function Debuffable:GetDebugString()
  165: 	local str = "Num Buffs: " .. tostring(GetTableSize(self.debuffs))
  166: 
  167:     for k, v in pairs(self.debuffs) do
  168: 		str = str .. "\n  " .. tostring(v.inst.prefab)
```

## Summary
```yaml
total_chars: 97602
output: /home/steam/Wagstaff-Lab/data/samples/samples_20260113_105500.md
```
```

### File: data/samples/samples_20260113_112749.manifest.json
- mode: full
- size_bytes: 2006
- sha256_12: b9f885cebc8a

```json
{
  "generated": "2026-01-13T11:27:49+08:00",
  "engine_mode": "zip",
  "template": {
    "name": "parse_other_data",
    "description": "Samples for expanding analyzer beyond prefab/recipe: STRINGS, Widgets, Brains, Stategraphs, LootTables, Components."
  },
  "categories": [
    "STRINGS",
    "Widgets",
    "Brains",
    "Stategraphs",
    "LootTables",
    "Components"
  ],
  "chosen": {
    "STRINGS": [
      "scripts/strings.lua",
      "scripts/dlcsupport_strings.lua"
    ],
    "Widgets": [
      "scripts/screens/redux/lobbyscreen.lua",
      "scripts/screens/redux/multiplayermainscreen.lua"
    ],
    "Brains": [],
    "Stategraphs": [],
    "LootTables": [
      "scripts/components/lootdropper.lua"
    ],
    "Components": []
  },
  "files": {
    "STRINGS": [
      {
        "path": "scripts/strings.lua",
        "sha256_12": "c473909148f0",
        "lines": 18126,
        "head_lines": 120,
        "snippet_blocks": 10
      },
      {
        "path": "scripts/dlcsupport_strings.lua",
        "sha256_12": "503f1a6380ef",
        "lines": 102,
        "head_lines": 102,
        "snippet_blocks": 2
      }
    ],
    "Widgets": [
      {
        "path": "scripts/screens/redux/lobbyscreen.lua",
        "sha256_12": "788ed557fcc6",
        "lines": 852,
        "head_lines": 120,
        "snippet_blocks": 10
      },
      {
        "path": "scripts/screens/redux/multiplayermainscreen.lua",
        "sha256_12": "3ade80d11037",
        "lines": 1319,
        "head_lines": 120,
        "snippet_blocks": 10
      }
    ],
    "Brains": [],
    "Stategraphs": [],
    "LootTables": [
      {
        "path": "scripts/components/lootdropper.lua",
        "sha256_12": "96a241a22ccb",
        "lines": 426,
        "head_lines": 120,
        "snippet_blocks": 3
      }
    ],
    "Components": []
  },
  "limits": {
    "max_chars_per_file": 18000,
    "max_total_chars": 260000
  },
  "defaults": {
    "head_lines": 120,
    "snippet_blocks": 10,
    "context_lines": 4
  }
}
```

### File: data/samples/samples_20260113_112749.md
- mode: full
- size_bytes: 40900
- sha256_12: 0ecf222f76c5

```md
# Wagstaff-Lab Lua Sample Pack

## Meta
```yaml
generated: 2026-01-13T11:27:49+08:00
engine_mode: zip
template: parse_other_data
categories: ['STRINGS', 'Widgets', 'Brains', 'Stategraphs', 'LootTables', 'Components']
max_total_chars: 260000
max_chars_per_file: 18000
```

## Category: STRINGS

### File: scripts/strings.lua
> sha256_12=c473909148f0, lines=18126

#### Head
```lua
--[[

***************************************************************
*** NOTICE TO TRANSLATORS: DO NOT EDIT THIS FILE DIRECTLY! ***

We have provided a standard PO file to translation in /scripts/languages/strings.pot
To add a new language:
- Use a PO editor such as POEdit (http://www.poedit.net/) to tranmslate strings.pot
- Load your own PO file under /scripts/languages/language.lua

***************************************************************
]]

--[[
***************************************************************
-- Note for developers to keep the .pot file up to date
-- 1. Open cmd and navigate to the data\scripts folder
-- 2. Enter "..\..\tools\LUA\lua.exe createstringspo.lua" (without quotes) into the cmd line and press return
***************************************************************
]]

--[[
***************************************************************
**                   DST UTF-8 formatting                    **
- Unicode characters can be added to this file in a UTF-8 format.
- For the custom font characters, the unicode private use area of U+E000 to U+F8FF is being used.
- For the emoji font characters, we use the unicode private use area of U+F0000 to U+FFFFD.

- The first digit must be 238, 239, or 243
  - 238 will be used for all controller buttons
  - 239 will be used for non-controller buttons
  - 243 is reserved for emoji
- The second digit can be from 128 to 191, inclusive
  - XBox:				128 to 131		0x80-0x83
  - PC Mouse:			132 to 135		0x84-0x87
  - DualShock4 on PC:	136 to 139		0x88-0x8B
  - PS4:				140 to 143		0x8A-0x8D
  - Switch:             144 to 147      0x90-0x93
  - DualSense:          148 to 151		0x94-0x97
- The third digit can be from 128 to 191, inclusive
  - no reserved meanings
***************************************************************
]]

local stageactor = require("strings_stageactor")

STRINGS =
{
	PSN = "PlayStationâ„¢Network",

    CHARACTER_NAMES =
    {
        wilson = "Wilson P. Higgsbury",
        willow = "Willow",
        wendy = "Wendy",
        wolfgang = "Wolfgang",
        woodie = "Woodie",
        wickerbottom = "Ms. Wickerbottom",
        wx78 = "WX-78",
        wes = "Wes",
        waxwell = "Maxwell",
        wathgrithr = "Wigfrid",
        webber = "Webber",
        winona = "Winona",
        wortox = "Wortox",
        wormwood = "Wormwood",
        warly = "Warly",
        wurt = "Wurt",
        walter = "Walter",
        wanda = "Wanda",
        wonkey = "Wonkey",
        unknown = "The Unknown",
        random = "Random",
    },


    CHARACTER_QUOTES =
    {
        wilson = "\"I'll conquer this world with the power of my MIND!\"",
        willow = "\"All will bathe in the prettiest of flames.\"",
        woodie = "\"That's a nice lookin' tree, eh? Not for long.\"",
        wendy ="\"Abigail? Come back! I'm not done playing with you.\"",
        wolfgang = "\"I am mighty! No one is mightier!\"",
        wx78 = "\"EMPATHY MODULE NOT RESPONDING\"",
        wickerbottom = "\"Shhhh! No talking!\"",
        waxwell = "\"Freedom suits me.\"",
        wes = "...",
        wathgrithr = "\"All the wÃ¶rld's a stage. FÃ¶r me!\"",
        webber = "\"We're always together, and never alone!\"",
        winona = "\"Anything can be fixed with hard work and elbow grease.\"",
        wortox = "\"Pardon me if I don't shake your hand.\"",
        wormwood = "\"Hello friend?\"",
        warly = "\"Nothing worthwhile is ever done on an empty stomach!\"",
        wurt = "\"Mermfolk known for hos-per-tality, florp.\"",
        walter = "\"A Pinetree Pioneer is always prepared!\"",
        wanda = "\"Time! I just need more time!\"",
        wonkey = "\"Ook OOK!\"",
        random = "Anybody could be under that hat.",
    },

    CHARACTER_TITLES =
    {
        wilson = "The Gentleman Scientist",
        willow = "The Firestarter",
        wendy = "The Bereaved",
        woodie = "The Lumberjack",
        wolfgang = "The Strongman",
        wx78 = "The Soulless Automaton",
        wickerbottom = "The Librarian",
        wes = "The Silent",
        waxwell = "The Puppet Master",
        wathgrithr = "The Performance Artist",
        webber = "The Indigestible",
        winona = "The Handywoman",
        wortox = "The Soul Starved",
        wormwood = "The Lonesome",
        warly = "The Culinarian",
        wurt = "The Half-Pint",
        walter = "The Fearless",
        wanda = "The Timekeeper",
```

#### Snippets (line-numbered)

**Snippet 1**
```lua
8114:         "Nice trade! Let's keep it goin'!",
8115:     },
8116: }
8117: 
8118: STRINGS.BUNNYMANNAMES =
8119: {
8120:     "Brassica",
8121:     "Bunium",
8122:     "Burdock",
```

**Snippet 2**
```lua
8190:     "Ytterbia",
8191:     "Lutetium",
8192: }
8193: 
8194: STRINGS.PIGNAMES =
8195: {
8196:     --emperors
8197:     "Augustus",
8198:     "Tiberius",
```

**Snippet 3**
```lua
8347:     "Smelly",
8348:     "Salty",
8349: }
8350: 
8351: STRINGS.SWAMPIGNAMES =
8352: {
8353:     --farmers
8354:     "Titus",
8355:     "Domitian",
```

**Snippet 4**
```lua
8373:     "Pupienus",
8374:     "Balbinus",
8375: }
8376: 
8377: STRINGS.CROWNAMES =
8378: {
8379:     "Apollo",
8380: 	"Russel",
8381: 	"Jet",
```

**Snippet 5**
```lua
8398:     "Hermia",
8399:     "Becca",
8400: }
8401: 
8402: STRINGS.MERMNAMES =
8403: {
8404:     -- Swamp.
8405:     "Flargle",
8406:     "Flop",
```

**Snippet 6**
```lua
8442:     "Simon",
8443:     "Trevor",
8444: }
8445: 
8446: STRINGS.SHARKBOINAMES =
8447: {
8448: 	"Steve",
8449: 	"Ronnie",
8450: 	"Finn",
```

**Snippet 7**
```lua
8477: 	"Gill",
8478: 
8479: }
8480: 
8481: STRINGS.UI =
8482: {
8483: 	TIME_FORMAT =
8484: 	{
8485: 		HHMMSS = "{hours}:{minutes}:{seconds}",
```

**Snippet 8**
```lua
9223:         WEGAMEOFFLINEMODE = "Connection to WeGame Failed",
9224:         WEGAMEFFLINEMODEDESC = "Couldn't connect to WeGame (scheduled maintenance or connectivity issues). Characters and worlds from online games will be unavailable. Play offline?",
9225:         STEAMOFFLINEMODE = "Connection to Steam Failed",
9226:         STEAMOFFLINEMODEDESC = "Couldn't connect to Steam (scheduled maintenance or connectivity issues). Characters and worlds from online games will be unavailable. Play offline?",
9227:         PSN_OFFLINEMODE = "Connection to "..STRINGS.PSN.." failed",
9228:         PSN_OFFLINEMODEDESC = "Couldn't connect to "..STRINGS.PSN.." (scheduled maintenance or connectivity issues). Characters and worlds from online games will be unavailable. Play offline?",
9229:         NOT_SIGNED_IN_TO_PSN = "Not Signed In to "..STRINGS.PSN.."",
9230:         NOT_SIGNED_IN_TO_PSN_DESC = "You are not signed in to "..STRINGS.PSN..". Characters and worlds from online games will be unavailable. Play offline?",
9231:         NO_INTERNET_CONNECTION = "No internet connection",
9232:         NO_INTERNET_CONNECTION_DESC = "Could not connect to the internet. Characters and worlds from online games will be unavailable. Play offline?",
9233:         NO_PS_PLUS_MEMBERSHIP = "PlayStationÂ®Plus",
9234:         NO_PS_PLUS_MEMBERSHIP_DESC = "Online play requires an active PlayStationÂ®Plus membership.\nCharacters and worlds from online games will be unavailable. Play offline?",
```

**Snippet 9**
```lua
10548:             ID_DST_DESTINATION_SERVER_NOT_AVAILABLE = "The server you were playing on is unavailable. Please try again later.",
10549:             ID_DST_DEDICATED_SERVER_STARTUP_FAILED = "There was some sort of trouble starting the server. Please try again.",
10550: 			ID_SPLITSCREEN_INGAME_PLAYER2_SIGNED_OUT_OF_PS4 = "Your split-screen partner logged out in the middle of a game!",
10551: 			ID_SPLITSCREEN_UI_PLAYER2_SIGNED_OUT_OF_PS4 = "Your split-screen partner logged out. Return to the main menu to find another.",
10552: 			ID_SPLITSCREEN_INGAME_PLAYER1_SIGNED_OUT_OF_PSN = "Player 1 has signed out of "..STRINGS.PSN.." in the middle of a game!",
10553: 			ID_SPLITSCREEN_INGAME_PLAYER2_SIGNED_OUT_OF_PSN = "Player 2 has signed out of "..STRINGS.PSN.." in the middle of a game!",
10554: 			ID_SPLITSCREEN_UI_PLAYER1_SIGNED_OUT_OF_PSN = "You have signed out of "..STRINGS.PSN..". Now we have to set everything back up again...",
10555: 			ID_SPLITSCREEN_UI_PLAYER2_SIGNED_OUT_OF_PSN = "Your split-screen partner signed out. Return to the main menu to find another.",
10556:             ID_DST_NETWORK_CONNECTION_LOST = "Check your connection and try again.",
10557:             ID_DST_SAVE_FILE_DAMAGED = "Your world is damaged and cannot be loaded.",
10558:         },
```

**Snippet 10**
```lua
15050:     },
15051: }
15052: 
15053: --these are broken out into their own files for ease of editing
15054: STRINGS.CHARACTERS =
15055: {
15056:     GENERIC = require "speech_wilson",
15057:     WAXWELL = require "speech_waxwell",
15058:     WOLFGANG = require "speech_wolfgang",
```

### File: scripts/dlcsupport_strings.lua
> sha256_12=503f1a6380ef, lines=102

#### Head
```lua
USE_PREFIX = {} -- A table of which strings use prefixes and which use suffixes when constructing names in EntityScript
USE_PREFIX[STRINGS.SMOLDERINGITEM] = true
USE_PREFIX[STRINGS.WITHEREDITEM] = true
USE_PREFIX[STRINGS.WET_PREFIX.FOOD] = true
USE_PREFIX[STRINGS.WET_PREFIX.CLOTHING] = true
USE_PREFIX[STRINGS.WET_PREFIX.TOOL] = true
USE_PREFIX[STRINGS.WET_PREFIX.FUEL] = true
USE_PREFIX[STRINGS.WET_PREFIX.GENERIC] = true
USE_PREFIX[STRINGS.WET_PREFIX.WETGOOP] = true -- Special case using inst.wet_prefix set on wet goop to WET_PREFIX.WETGOOP
USE_PREFIX[STRINGS.NAMES.WETGOOP] = true -- Special case using inst.wet_prefix set on wet goop to WET_PREFIX.WETGOOP
USE_PREFIX[STRINGS.WET_PREFIX.RABBITHOLE] = true -- Special case using inst.wet_prefix on rabbit hole set to WET_PREFIX.RABBITHOLE
USE_PREFIX[STRINGS.NAMES.RABBITHOLE] = true -- Special case using inst.wet_prefix on rabbit hole set to WET_PREFIX.RABBITHOLE

local function TryGuaranteeCoverage(item, usePrefix)
    -- Look for item in the STRINGS.NAMES table
    local name = nil
    for i,v in pairs(STRINGS.NAMES) do
        if item == v then
            -- If we find it, save the key so we can look for that key in the STRINGS.WET_PREFIX table
            name = i
            break
        end
    end
    if name and STRINGS.WET_PREFIX[name] then USE_PREFIX[STRINGS.WET_PREFIX[name]] = usePrefix end

    -- And vice versa for prefix
    local prefix = nil
    for i,v in pairs(STRINGS.WET_PREFIX) do
        if item == v then
            prefix = i
            break
        end
    end
    if prefix and STRINGS.NAMES[prefix] then USE_PREFIX[STRINGS.NAMES[prefix]] = usePrefix end

    -- Now check if the value is a key itself in either of the tables. If so, add its value to USES_PREFIX
    if STRINGS.NAMES[string.upper(item)] then USE_PREFIX[STRINGS.NAMES[string.upper(item)]] = usePrefix end
    if STRINGS.WET_PREFIX[string.upper(item)] then USE_PREFIX[STRINGS.WET_PREFIX[string.upper(item)]] = usePrefix end
end

-- Check if the item uses a prefix or a suffix
local function UsesPrefix(item)
    if type(item) == "string" then
        return USE_PREFIX[item]
    end
end

-- Use this to make all adjectives into suffixes
function MakeAllSuffixes(fn)
    if type(fn) ~= "function" then
        fn = false
    end
    for k, v in pairs(USE_PREFIX) do
        USE_PREFIX[k] = fn
    end
end

-- Use this to make all adjectives into prefixes
function MakeAllPrefixes(fn)
    if type(fn) ~= "function" then
        fn = true
    end
    for k, v in pairs(USE_PREFIX) do
        USE_PREFIX[k] = fn
    end
end

 -- Use this to specify whether a particular item should use a prefix or a suffix
 -- This can also be used to add a new item to the USE_PREFIX table
function SetUsesPrefix(item, usePrefix)
    if type(item) == "string" and usePrefix ~= nil then
        USE_PREFIX[item] = usePrefix
        TryGuaranteeCoverage(item, usePrefix)
    end
end

function ConstructAdjectivedName(inst, name, adjective)
    -- Pull the real name based on the prefab if we have only been handed that for some reason
    if name == nil and inst ~= nil and inst.prefab ~= nil then
        name = STRINGS.NAMES[string.upper(inst.prefab)]
    end

    -- Adjective is stronger binding: we only want to base it off the name for special cases (in which case the adjective won't be in the table)
    local usePrefix = UsesPrefix(adjective)
    if usePrefix == nil then
        usePrefix = UsesPrefix(name)
    end

    -- First check if USES_PREFIX for this thing is a function
    if type(usePrefix) == "function" then
        -- If so, try the function, but only use the result if it returns a string
        local tryfunction = usePrefix(inst, name, adjective)
        if type(tryfunction) == "string" then
            return tryfunction
        end
    end

    -- If we don't have a string yet (either the entry in the table wasn't a function or the function returned a bad value), try the table value directly
    return usePrefix ~= false
        and (adjective.." "..name)
        or (name.." "..adjective)
end
```

#### Snippets (line-numbered)

**Snippet 1**
```lua
 1: USE_PREFIX = {} -- A table of which strings use prefixes and which use suffixes when constructing names in EntityScript
 2: USE_PREFIX[STRINGS.SMOLDERINGITEM] = true
 3: USE_PREFIX[STRINGS.WITHEREDITEM] = true
 4: USE_PREFIX[STRINGS.WET_PREFIX.FOOD] = true
 5: USE_PREFIX[STRINGS.WET_PREFIX.CLOTHING] = true
 6: USE_PREFIX[STRINGS.WET_PREFIX.TOOL] = true
 7: USE_PREFIX[STRINGS.WET_PREFIX.FUEL] = true
 8: USE_PREFIX[STRINGS.WET_PREFIX.GENERIC] = true
 9: USE_PREFIX[STRINGS.WET_PREFIX.WETGOOP] = true -- Special case using inst.wet_prefix set on wet goop to WET_PREFIX.WETGOOP
10: USE_PREFIX[STRINGS.NAMES.WETGOOP] = true -- Special case using inst.wet_prefix set on wet goop to WET_PREFIX.WETGOOP
11: USE_PREFIX[STRINGS.WET_PREFIX.RABBITHOLE] = true -- Special case using inst.wet_prefix on rabbit hole set to WET_PREFIX.RABBITHOLE
12: USE_PREFIX[STRINGS.NAMES.RABBITHOLE] = true -- Special case using inst.wet_prefix on rabbit hole set to WET_PREFIX.RABBITHOLE
13: 
14: local function TryGuaranteeCoverage(item, usePrefix)
15:     -- Look for item in the STRINGS.NAMES table
16:     local name = nil
17:     for i,v in pairs(STRINGS.NAMES) do
18:         if item == v then
19:             -- If we find it, save the key so we can look for that key in the STRINGS.WET_PREFIX table
20:             name = i
21:             break
22:         end
23:     end
24:     if name and STRINGS.WET_PREFIX[name] then USE_PREFIX[STRINGS.WET_PREFIX[name]] = usePrefix end
25: 
26:     -- And vice versa for prefix
27:     local prefix = nil
28:     for i,v in pairs(STRINGS.WET_PREFIX) do
29:         if item == v then
30:             prefix = i
31:             break
32:         end
33:     end
34:     if prefix and STRINGS.NAMES[prefix] then USE_PREFIX[STRINGS.NAMES[prefix]] = usePrefix end
35: 
36:     -- Now check if the value is a key itself in either of the tables. If so, add its value to USES_PREFIX
37:     if STRINGS.NAMES[string.upper(item)] then USE_PREFIX[STRINGS.NAMES[string.upper(item)]] = usePrefix end
38:     if STRINGS.WET_PREFIX[string.upper(item)] then USE_PREFIX[STRINGS.WET_PREFIX[string.upper(item)]] = usePrefix end
39: end
40: 
41: -- Check if the item uses a prefix or a suffix
42: local function UsesPrefix(item)
```

**Snippet 2**
```lua
76: 
77: function ConstructAdjectivedName(inst, name, adjective)
78:     -- Pull the real name based on the prefab if we have only been handed that for some reason
79:     if name == nil and inst ~= nil and inst.prefab ~= nil then
80:         name = STRINGS.NAMES[string.upper(inst.prefab)]
81:     end
82: 
83:     -- Adjective is stronger binding: we only want to base it off the name for special cases (in which case the adjective won't be in the table)
84:     local usePrefix = UsesPrefix(adjective)
```


## Category: Widgets

### File: scripts/screens/redux/lobbyscreen.lua
> sha256_12=788ed557fcc6, lines=852

#### Head
```lua
local ChatSidebar = require "widgets/redux/chatsidebar"
local WxpLobbyPanel = require "widgets/redux/wxplobbypanel"
local MvpWidget = require "widgets/mvploadingwidget"
local OnlineStatus = require "widgets/onlinestatus"
local Screen = require "widgets/screen"
local Text = require "widgets/text"
local Widget = require "widgets/widget"
local LoadoutSelect = require "widgets/redux/loadoutselect"
local CharacterButton = require "widgets/redux/characterbutton"
local CharacterSelect = require "widgets/redux/characterselect"
local WaitingForPlayers = require "widgets/waitingforplayers"
local PopupDialogScreen = require "screens/redux/popupdialog"
local LavaarenaBookWidget = require "widgets/redux/lavaarena_book"

local TEMPLATES = require "widgets/redux/templates"


require("util")
require("networking")
require("stringutil")

local DEBUG_MODE = BRANCH == "dev"

local REFRESH_INTERVAL = .25

local function StartGame(this)
    if this.startbutton then
        this.startbutton:Disable()
    end

    if this.cb then
		local skins = this.currentskins
        this.cb(this.character_for_game, skins.base, skins.body, skins.hand, skins.legs, skins.feet) --parameters are base_prefab, skin_base, clothing_body, clothing_hand, then clothing_legs
    end
end

local LobbyPanel = Class(Widget, function(self, panel_name)
    Widget._ctor(self, panel_name)
end)

local ServerLockedPanel = Class(Widget, function(self, owner)
    LobbyPanel._ctor(self, "ServerLockedPanel")
    self.title = ""

    function self:OnGainFocus()
		owner.active = false
		owner:Disable()

		TheFrontEnd:PushScreen(PopupDialogScreen(STRINGS.UI.LOBBYSCREEN.SERVER_SHUTDOWN_TITLE, STRINGS.UI.LOBBYSCREEN.SERVER_SHUTDOWN_BODY, {{text=STRINGS.UI.LOBBYSCREEN.DISCONNECT, cb = function() DoRestart(true) end}}))
	end
end)

local WxpPanel = Class(LobbyPanel, function(self, owner)
    LobbyPanel._ctor(self, "WxpPanel")

	local outcome = Settings.match_results ~= nil and Settings.match_results.outcome or {}

	self.title = STRINGS.UI.WXPLOBBYPANEL[string.upper(TheNet:GetServerGameMode())][outcome.won and "TITLE_VICTORY" or "TITLE_DEFEAT"]
	self.next_button_title = Settings.match_results.wxp_data == nil and STRINGS.UI.WXPLOBBYPANEL.CONTINUE or STRINGS.UI.WXPLOBBYPANEL.SKIP

	local show_mvp_cards = Settings.match_results.mvp_cards ~= nil
	if show_mvp_cards then
		self.mvp_widget = self:AddChild(MvpWidget())
		self.mvp_widget:PopulateData()
		self.mvp_widget:SetScale(.55)
		self.mvp_widget:SetPosition(0, 75)
	end

	self.wxp = self:AddChild(WxpLobbyPanel(owner.profile, function() owner.next_button:SetText(STRINGS.UI.WXPLOBBYPANEL.CONTINUE) end))
    self.wxp:SetPosition(0, show_mvp_cards and -145 or 70)

	local info_y = 285
	if outcome.lb_submit == false then
		local score = self:AddChild(Text(CHATFONT, 18, STRINGS.UI.WXPLOBBYPANEL.LEADERBOARD_ERROR .. " ("..tostring(outcome.lb_response)..")"))
		score:SetPosition(190, info_y)
		score:SetColour(UICOLOURS.RED)
		score:SetRegionSize(500, 20)
		score:SetHAlign(ANCHOR_RIGHT)
		info_y = info_y - 20
	end
	if outcome.tournament_ticket ~= nil and Client_IsTournamentActive() and TheSim:IsBorrowed() then
		local score = self:AddChild(Text(CHATFONT, 18, STRINGS.UI.WXPLOBBYPANEL.STEAM.TOURNAMENTS_NO_ACCOUNT_SHARING))
		score:SetPosition(190, info_y)
		score:SetColour(UICOLOURS.RED)
		score:SetRegionSize(500, 20)
		score:SetHAlign(ANCHOR_RIGHT)
		info_y = info_y - 20
	end


	info_y = 285

	if outcome.score ~= nil then
		local score = self:AddChild(Text(CHATFONT, 18, subfmt(STRINGS.UI.WXPLOBBYPANEL.SCORE, {score = outcome.score})))
		score:SetPosition(-250, info_y)
		score:SetColour(UICOLOURS.GOLD)
		score:SetRegionSize(400, 20)
		score:SetHAlign(ANCHOR_LEFT)
		info_y = info_y - 20
	end
	if outcome.tributes_success ~= nil then
		local score = self:AddChild(Text(CHATFONT, 18, subfmt(STRINGS.UI.WXPLOBBYPANEL.TRIBUTES, {success = outcome.tributes_success, failed = outcome.tributes_failed})))
		score:SetPosition(-250, info_y)
		score:SetColour(UICOLOURS.GOLD)
		score:SetRegionSize(400, 20)
		score:SetHAlign(ANCHOR_LEFT)
		info_y = info_y - 20
	end
	if outcome.time ~= nil then
		local match_time = self:AddChild(Text(CHATFONT, 18, subfmt(STRINGS.UI.WXPLOBBYPANEL.MATCH_TIME, {time = str_seconds(outcome.time)})))
		match_time:SetPosition(-250, info_y)
		match_time:SetColour(UICOLOURS.GOLD)
		match_time:SetRegionSize(400, 20)
		match_time:SetHAlign(ANCHOR_LEFT)
		info_y = info_y - 20
	end
	if outcome.total_deaths ~= nil then
		local text = outcome.total_deaths == 0 and STRINGS.UI.WXPLOBBYPANEL.NO_DEATHS or subfmt(STRINGS.UI.WXPLOBBYPANEL.DEATHS, {deaths = outcome.total_deaths})
		local deaths = self:AddChild(Text(CHATFONT, 18, text))
		deaths:SetPosition(-250, info_y)
```

#### Snippets (line-numbered)

**Snippet 1**
```lua
 1: local ChatSidebar = require "widgets/redux/chatsidebar"
 2: local WxpLobbyPanel = require "widgets/redux/wxplobbypanel"
 3: local MvpWidget = require "widgets/mvploadingwidget"
 4: local OnlineStatus = require "widgets/onlinestatus"
 5: local Screen = require "widgets/screen"
 6: local Text = require "widgets/text"
 7: local Widget = require "widgets/widget"
 8: local LoadoutSelect = require "widgets/redux/loadoutselect"
 9: local CharacterButton = require "widgets/redux/characterbutton"
10: local CharacterSelect = require "widgets/redux/characterselect"
11: local WaitingForPlayers = require "widgets/waitingforplayers"
12: local PopupDialogScreen = require "screens/redux/popupdialog"
13: local LavaarenaBookWidget = require "widgets/redux/lavaarena_book"
14: 
15: local TEMPLATES = require "widgets/redux/templates"
16: 
17: 
18: require("util")
19: require("networking")
```

**Snippet 2**
```lua
33:         this.cb(this.character_for_game, skins.base, skins.body, skins.hand, skins.legs, skins.feet) --parameters are base_prefab, skin_base, clothing_body, clothing_hand, then clothing_legs
34:     end
35: end
36: 
37: local LobbyPanel = Class(Widget, function(self, panel_name)
38:     Widget._ctor(self, panel_name)
39: end)
40: 
41: local ServerLockedPanel = Class(Widget, function(self, owner)
42:     LobbyPanel._ctor(self, "ServerLockedPanel")
43:     self.title = ""
44: 
45:     function self:OnGainFocus()
```

**Snippet 3**
```lua
49: 		TheFrontEnd:PushScreen(PopupDialogScreen(STRINGS.UI.LOBBYSCREEN.SERVER_SHUTDOWN_TITLE, STRINGS.UI.LOBBYSCREEN.SERVER_SHUTDOWN_BODY, {{text=STRINGS.UI.LOBBYSCREEN.DISCONNECT, cb = function() DoRestart(true) end}}))
50: 	end
51: end)
52: 
53: local WxpPanel = Class(LobbyPanel, function(self, owner)
54:     LobbyPanel._ctor(self, "WxpPanel")
55: 
56: 	local outcome = Settings.match_results ~= nil and Settings.match_results.outcome or {}
57: 
```

**Snippet 4**
```lua
59: 	self.next_button_title = Settings.match_results.wxp_data == nil and STRINGS.UI.WXPLOBBYPANEL.CONTINUE or STRINGS.UI.WXPLOBBYPANEL.SKIP
60: 
61: 	local show_mvp_cards = Settings.match_results.mvp_cards ~= nil
62: 	if show_mvp_cards then
63: 		self.mvp_widget = self:AddChild(MvpWidget())
64: 		self.mvp_widget:PopulateData()
65: 		self.mvp_widget:SetScale(.55)
66: 		self.mvp_widget:SetPosition(0, 75)
67: 	end
```

**Snippet 5**
```lua
158: 	end
159: 
160: end)
161: 
162: local CharacterSelectPanel = Class(LobbyPanel, function(self, owner)
163:     LobbyPanel._ctor(self, "CharacterSelectPanel")
164: 
165:     TheSkillTree:ApplyOnlineProfileData() -- NOTES(JBK): We do not care if this fails this is to apply data if it is available. Widgets using this state should check TheSkillTree.synced for the state.
166: 
```

**Snippet 6**
```lua
171:     local function OnCharacterClick(hero)
172:         owner.next_button:onclick()
173:     end
174: 
175: 	local CharacterButtonCtor = Class(CharacterButton, function(self, character, cbPortraitFocused, cbPortraitClicked)
176: 		CharacterButton._ctor(self, character, cbPortraitFocused, cbPortraitClicked)
177: 	end)
178: 
179: 	local function BuildCharacterDetailsWidget(char)
180: 		local root = Widget("char_root")
181: 		root:SetPosition(85, -100)
182: 
183: 		root.portrait = root:AddChild(Image())
184: 		root.portrait:SetPosition(-100, 80)
```

**Snippet 7**
```lua
215: 		root.perks = root:AddChild(Text(HEADERFONT, 20, "", UICOLOURS.GREY))
216: 		root.perks:SetHAlign(ANCHOR_LEFT)
217: 		root.perks:SetVAlign(ANCHOR_TOP)
218: 
219: 		root.inv = root:AddChild(TEMPLATES.MakeStartingInventoryWidget(nil, true))
220: 		root.inv:SetPosition(root._perks_left, -200)
221: 
222: 		root.SetPortrait = function(self, character)
223: 			self.currentcharacter = character -- required because this is how the lobbyscreen determines which character is selected
```

**Snippet 8**
```lua
305: 	    return table.concat(t, "  ")
306: 	end]]
307: end)
308: 
309: local LoadoutPanel = Class(LobbyPanel, function(self, owner)
310:     LobbyPanel._ctor(self, "LoadoutPanel")
311: 
312:     self:SetPosition(-160, 0)
313: 
```

**Snippet 9**
```lua
410: 		end
411: 	end
412: end)
413: 
414: local WaitingPanel = Class(LobbyPanel, function(self, owner)
415:     LobbyPanel._ctor(self, "WaitingPanel")
416: 
417: 	self.title = STRINGS.UI.LOBBYSCREEN.WAITING_FOR_PLAYERS_TITLE
418: 
```

**Snippet 10**
```lua
450: 		return false
451: 	end
452: end)
453: 
454: local LavaarenaFestivalBookPannel = Class(LobbyPanel, function(self, owner)
455:     LobbyPanel._ctor(self, "LavaarenaFestivalBookPannel")
456: 
457: 	self.title = ""
458: 	self.next_button_title = STRINGS.UI.LOBBYSCREEN.NEXT
459: 
460: 	self.eventbook = self:AddChild(LavaarenaBookWidget(owner.chat_sidebar.chatbox, nil, GetFestivalEventSeasons(FESTIVAL_EVENTS.LAVAARENA)))
461: 	self.eventbook:SetPosition(0, 0)
462: 
463: 	self.focus_forward = self.eventbook
464: 
```

### File: scripts/screens/redux/multiplayermainscreen.lua
> sha256_12=3ade80d11037, lines=1319

#### Head
```lua
local Screen = require "widgets/screen"
local AnimButton = require "widgets/animbutton"
local ImageButton = require "widgets/imagebutton"
local Menu = require "widgets/menu"
local Text = require "widgets/text"
local Image = require "widgets/image"
local UIAnim = require "widgets/uianim"
local Widget = require "widgets/widget"
require "os"

local PopupDialogScreen = require "screens/redux/popupdialog"
local FestivalEventScreen = require "screens/redux/festivaleventscreen"
local ModsScreen = require "screens/redux/modsscreen"
local OptionsScreen = require "screens/redux/optionsscreen"
local CompendiumScreen = require "screens/redux/compendiumscreen"
local PlayerSummaryScreen = require "screens/redux/playersummaryscreen"
local QuickJoinScreen = require "screens/redux/quickjoinscreen"
local ServerListingScreen = require "screens/redux/serverlistingscreen"
local ServerSlotScreen = require "screens/redux/serverslotscreen"

local TEMPLATES = require "widgets/redux/templates"

local FriendsManager = require "widgets/friendsmanager"
local OnlineStatus = require "widgets/onlinestatus"
local ThankYouPopup = require "screens/thankyoupopup"
local ItemBoxOpenerPopup = require "screens/redux/itemboxopenerpopup"
local SkinGifts = require("skin_gifts")
local Stats = require("stats")

local MainMenuMotdPanel = require "widgets/redux/mainmenu_motdpanel"
local MainMenuStatsPanel = require "widgets/redux/mainmenu_statspanel"
local PurchasePackScreen = require "screens/redux/purchasepackscreen"

local KitcoonPuppet = require "widgets/kitcoonpuppet"

local SHOW_DST_DEBUG_HOST_JOIN = BRANCH == "dev"
local SHOW_QUICKJOIN = false

local IS_BETA = BRANCH == "staging" --or BRANCH == "dev"
local IS_DEV_BUILD = BRANCH == "dev"

local function PlayBannerSound(inst, self, sound)
    if self.bannersoundsenabled then
        TheFrontEnd:GetSound():PlaySound(sound)
    end
end

local function _MakeGenericBanner(uianim, build, bank, anim, scale)
	uianim:GetAnimState():SetBuild(build)
	uianim:GetAnimState():SetBank(bank or build)
	uianim:SetScale(scale or 0.667)
	uianim:GetAnimState():PlayAnimation(anim or "loop", true)
	return uianim
end

--------------------------------------------------------------------------
--Old banners
--[[
local function MakeWaterloggedBanner(self, banner_root, uianim)
	_MakeGenericBanner(banner_root:AddChild(UIAnim()), "dst_menu_waterlogged"):MoveToBack()
end

local function MakeMoonstormBanner(self, banner_root, uianim)
	_MakeGenericBanner(uianim, "dst_menu_moonstorm_background", nil, "loop_w1")
	uianim.inst:ListenForEvent("animover", function()
		uianim:GetAnimState():PlayAnimation("loop_w"..math.random(3))
	end)

	local anim_wrench = _MakeGenericBanner(banner_root:AddChild(UIAnim()), "dst_menu_moonstorm_wrench", nil, "loop_w1")
    anim_wrench:GetAnimState():SetErosionParams(0.06, 0, -1.0)
    anim_wrench.inst.holo_time = 0
    anim_wrench.inst:DoPeriodicTask(FRAMES, function()
        anim_wrench.inst.holo_time = anim_wrench.inst.holo_time + FRAMES
        anim_wrench:GetAnimState():SetErosionParams(0.06, anim_wrench.inst.holo_time, -1.0)
    end)
    anim_wrench.inst:ListenForEvent("animover", function()
        -- This is a hack to get it to loop in sync with Wilson in the background,
        -- since the Wilson anim isn't set to loop either (it switches randomly
        -- between different animations)
        anim_wrench:GetAnimState():PlayAnimation("loop_w1")
    end)

	local anim_wagstaff = _MakeGenericBanner(banner_root:AddChild(UIAnim()), "dst_menu_moonstorm_wagstaff", nil, "loop_w2")
    anim_wagstaff:GetAnimState():SetErosionParams(1, 0, -1.0)
    anim_wagstaff:GetAnimState():SetMultColour(1, 1, 1, 0.9)

    local wagstaff_erosion_min = 0.02 -- Not 0 so there's always a little bit of influence on the alpha from the lines
    local wagstaff_erosion_max = 1.2 -- Overshoots 1.2 to get more stable alpha lines when close to fully faded out
    local wagstaff_erosion_speed = 1.65
    local wagstaff_visible_time_min = 5.2
    local wagstaff_visible_time_variance = 3.4
    local wagstaff_invisible_time_min = 8
    local wagstaff_invisible_time_variance = 5.7
    --
    anim_wagstaff.inst.holo_time = 0
    anim_wagstaff.inst.holo_erosion = 1
    anim_wagstaff.inst.holo_fade_in = false
    anim_wagstaff.inst.holo_position = math.random(3)
    anim_wagstaff.inst:DoPeriodicTask(FRAMES, function()
        if anim_wagstaff.inst.holo_fade_in then
            anim_wagstaff.inst.holo_erosion = math.max(wagstaff_erosion_min, anim_wagstaff.inst.holo_erosion - FRAMES * wagstaff_erosion_speed)
        else
            anim_wagstaff.inst.holo_erosion = math.min(wagstaff_erosion_max, anim_wagstaff.inst.holo_erosion + FRAMES * wagstaff_erosion_speed)
        end
        anim_wagstaff.inst.holo_time = anim_wagstaff.inst.holo_time + FRAMES
        anim_wagstaff:GetAnimState():SetErosionParams(anim_wagstaff.inst.holo_erosion, anim_wagstaff.inst.holo_time, -1)
    end)
    local holo_fade_in
    local holo_fade_out
    holo_fade_out = function(inst)
        anim_wagstaff.inst.holo_fade_in = false

        inst:DoTaskInTime(wagstaff_invisible_time_min + wagstaff_invisible_time_variance * math.random(), holo_fade_in)
    end
    holo_fade_in = function(inst)
        anim_wagstaff.inst.holo_fade_in = true
        anim_wagstaff.inst.holo_time = 0

        local anim_variations = {[1] = 1, [2] = 1, [3] = 1}
        anim_variations[anim_wagstaff.inst.holo_position] = 0
```

#### Snippets (line-numbered)

**Snippet 1**
```lua
 1: local Screen = require "widgets/screen"
 2: local AnimButton = require "widgets/animbutton"
 3: local ImageButton = require "widgets/imagebutton"
 4: local Menu = require "widgets/menu"
 5: local Text = require "widgets/text"
 6: local Image = require "widgets/image"
 7: local UIAnim = require "widgets/uianim"
 8: local Widget = require "widgets/widget"
 9: require "os"
10: 
11: local PopupDialogScreen = require "screens/redux/popupdialog"
12: local FestivalEventScreen = require "screens/redux/festivaleventscreen"
```

**Snippet 2**
```lua
17: local QuickJoinScreen = require "screens/redux/quickjoinscreen"
18: local ServerListingScreen = require "screens/redux/serverlistingscreen"
19: local ServerSlotScreen = require "screens/redux/serverslotscreen"
20: 
21: local TEMPLATES = require "widgets/redux/templates"
22: 
23: local FriendsManager = require "widgets/friendsmanager"
24: local OnlineStatus = require "widgets/onlinestatus"
25: local ThankYouPopup = require "screens/thankyoupopup"
26: local ItemBoxOpenerPopup = require "screens/redux/itemboxopenerpopup"
27: local SkinGifts = require("skin_gifts")
28: local Stats = require("stats")
29: 
30: local MainMenuMotdPanel = require "widgets/redux/mainmenu_motdpanel"
31: local MainMenuStatsPanel = require "widgets/redux/mainmenu_statspanel"
32: local PurchasePackScreen = require "screens/redux/purchasepackscreen"
33: 
34: local KitcoonPuppet = require "widgets/kitcoonpuppet"
35: 
36: local SHOW_DST_DEBUG_HOST_JOIN = BRANCH == "dev"
37: local SHOW_QUICKJOIN = false
38: 
```

**Snippet 3**
```lua
351: 
352: function MakeBanner(self)
353: 	local title_str = nil
354: 
355: 	local banner_root = Widget("banner_root")
356: 	local uianim = banner_root:AddChild(UIAnim())
357: 
358: 	if IS_BETA then
359: 		title_str = STRINGS.UI.MAINSCREEN.MAINBANNER_BETA_TITLE
```

**Snippet 4**
```lua
476:         return nil
477:     end
478: end
479: 
480: local MultiplayerMainScreen = Class(Screen, function(self, prev_screen, profile, offline, session_data)
481: 	Screen._ctor(self, "MultiplayerMainScreen")
482: 
483: 	self.info_font = BODYTEXTFONT -- CHATFONT, FALLBACK_FONT, CHATFONT_OUTLINE
484: 
```

**Snippet 5**
```lua
538:     end
539:     })
540: end
541: function MultiplayerMainScreen:DoInit()
542:     self.fixed_root = self:AddChild(Widget("root"))
543:     self.fixed_root:SetVAnchor(ANCHOR_MIDDLE)
544:     self.fixed_root:SetHAnchor(ANCHOR_MIDDLE)
545:     self.fixed_root:SetScaleMode(SCALEMODE_PROPORTIONAL)
546: 
```

**Snippet 6**
```lua
692: function MultiplayerMainScreen:OnRawKey(key, down)
693: end
694: 
695: function MultiplayerMainScreen:_FadeToScreen(screen_ctor, data)
696:     self.last_focus_widget = TheFrontEnd:GetFocusWidget()
697:     self.menu:Disable()
698:     self.leaving = true --Note(Peter): what is this even used for?!?
699: 
700:     TheFrontEnd:FadeToScreen( self, function() return screen_ctor(self, unpack(data)) end, nil )
```

**Snippet 7**
```lua
733:     if GetFestivalEventInfo().FEMUSIC ~= nil then
734:         self:StopMusic() --only stop the main menu music if we have something for the next screeen
735:     end
736: 
737: 	self.last_focus_widget = TheFrontEnd:GetFocusWidget()
738:     self.menu:Disable()
739:     self.leaving = true --Note(Peter): what is this even used for?!?
740: 
741:     TheFrontEnd:Fade(FADE_OUT, SCREEN_FADE_TIME, function()
```

**Snippet 8**
```lua
792:     self:_GoToOnlineScreen(ServerSlotScreen, {})
793: end
794: 
795: function MultiplayerMainScreen:_GoToOnlineScreen(screen_ctor, data)
796:     self.last_focus_widget = TheFrontEnd:GetFocusWidget()
797:     self.menu:Disable()
798:     self.leaving = true --Note(Peter): what is this even used for?!?
799:     TheFrontEnd:Fade(FADE_OUT, SCREEN_FADE_TIME, function()
800:         Profile:ShowedNewUserPopup()
```

**Snippet 9**
```lua
856:     if self:CheckNewUser(self.OnQuickJoinServersButton, STRINGS.UI.MAINSCREEN.NEWUSER_NO_QUICKJOIN) then
857:         return
858:     end
859: 
860:     self.last_focus_widget = TheFrontEnd:GetFocusWidget()
861:     self.menu:Disable()
862:     self.leaving = true
863: 
864:     -- QuickJoin is a popup, so don't fade to it.
```

**Snippet 10**
```lua
878:     self:_FadeToScreen(ModsScreen, {})
879: end
880: 
881: function MultiplayerMainScreen:Quit()
882:     self.last_focus_widget = TheFrontEnd:GetFocusWidget()
883:     TheFrontEnd:PushScreen(PopupDialogScreen(
884:             STRINGS.UI.MAINSCREEN.ASKQUIT,
885:             STRINGS.UI.MAINSCREEN.ASKQUITDESC,
886:             {
```


## Category: Brains


## Category: Stategraphs


## Category: LootTables

### File: scripts/components/lootdropper.lua
> sha256_12=96a241a22ccb, lines=426

#### Head
```lua
local LootDropper = Class(function(self, inst)
    self.inst = inst
    self.numrandomloot = nil
    self.randomloot = nil
    self.chancerandomloot = nil
    self.totalrandomweight = nil
    self.chanceloot = nil
    self.ifnotchanceloot = nil
    self.droppingchanceloot = false
    self.loot = nil
    self.chanceloottable = nil

    self.trappable = true
    self.droprecipeloot = true

    self.lootfn = nil
    self.flingtargetpos = nil
    self.flingtargetvariance = nil
end)

LootTables = {}
function SetSharedLootTable(name, table)
    LootTables[name] = table
end

function LootDropper:SetChanceLootTable(name)
    self.chanceloottable = name
end

function LootDropper:SetLoot(loots)
    self.loot = loots
    self.chanceloot = nil
    self.randomloot = nil
    self.numrandomloot = nil
end

function LootDropper:SetLootSetupFn(fn)
    self.lootsetupfn = fn
end

function LootDropper:AddRandomLoot(prefab, weight)
    if not self.randomloot then
        self.randomloot = {}
        self.totalrandomweight = 0
    end

    table.insert(self.randomloot, { prefab = prefab, weight = weight })
    self.totalrandomweight = self.totalrandomweight + weight
end

function LootDropper:ClearRandomLoot()
    self.randomloot = nil
    self.totalrandomweight = nil
    self.numrandomloot = nil
end

-- This overrides the normal loot table while haunted
function LootDropper:AddRandomHauntedLoot(prefab, weight)
    if not self.randomhauntedloot then
        self.randomhauntedloot = {}
        self.totalhauntedrandomweight = 0
    end

    table.insert(self.randomhauntedloot, { prefab = prefab, weight = weight })
    self.totalhauntedrandomweight = self.totalhauntedrandomweight + weight
end

function LootDropper:AddChanceLoot(prefab, chance)
    if not self.chanceloot then
        self.chanceloot = {}
    end
    table.insert(self.chanceloot, { prefab = prefab, chance = chance })
end

function LootDropper:AddIfNotChanceLoot(prefab)
    if not self.ifnotchanceloot then
        self.ifnotchanceloot = {}
    end
    table.insert(self.ifnotchanceloot, { prefab = prefab })
end

function LootDropper:PickRandomLoot()
    if self.inst.components.hauntable and self.inst.components.hauntable.haunted and self.totalhauntedrandomweight and self.totalhauntedrandomweight > 0 and self.randomhauntedloot then
        local rnd = math.random()*self.totalhauntedrandomweight
        for k,v in pairs(self.randomhauntedloot) do
            rnd = rnd - v.weight
            if rnd <= 0 then
                return v.prefab
            end
        end
    elseif self.totalrandomweight and self.totalrandomweight > 0 and self.randomloot then
        local rnd = math.random()*self.totalrandomweight
        for k,v in pairs(self.randomloot) do
            rnd = rnd - v.weight
            if rnd <= 0 then
                return v.prefab
            end
        end
    end
end

function LootDropper:GetFullRecipeLoot(recipe)
    local loot = {}

    for k,v in ipairs(recipe.ingredients) do
        local amt = v.amount
        for n = 1, amt do
            if v.deconstruct then
                local recipeloot = self:GetFullRecipeLoot(AllRecipes[v.type])
                for k,v in ipairs(recipeloot) do
                    table.insert(loot, v)
                end
            else
                table.insert(loot, v.type)
            end
        end
    end

    return loot
end
```

#### Snippets (line-numbered)

**Snippet 1**
```lua
26: function LootDropper:SetChanceLootTable(name)
27:     self.chanceloottable = name
28: end
29: 
30: function LootDropper:SetLoot(loots)
31:     self.loot = loots
32:     self.chanceloot = nil
33:     self.randomloot = nil
34:     self.numrandomloot = nil
```

**Snippet 2**
```lua
64:     table.insert(self.randomhauntedloot, { prefab = prefab, weight = weight })
65:     self.totalhauntedrandomweight = self.totalhauntedrandomweight + weight
66: end
67: 
68: function LootDropper:AddChanceLoot(prefab, chance)
69:     if not self.chanceloot then
70:         self.chanceloot = {}
71:     end
72:     table.insert(self.chanceloot, { prefab = prefab, chance = chance })
```

**Snippet 3**
```lua
367:     end
368: end
369: 
370: local DONT_BURN_LOOT_TAGS = {"tree", "boulder"}
371: function LootDropper:DropLoot(pt, prefabs)
372:     prefabs = prefabs or self:GenerateLoot()
373: 
374:     if self.inst:HasTag("burnt")
375:         or (self.inst.components.burnable ~= nil and
```


## Category: Components


## Summary
```yaml
total_chars: 40798
output: /home/steam/Wagstaff-Lab/data/samples/samples_20260113_112749.md
```
```

### File: devtools/codemap.py
- mode: full
- size_bytes: 5942
- sha256_12: e724d24f11e6

```py
#!/usr/bin/env python3
"""Wagstaff-Lab DST Code Map (Report)

Goal
- ç³»ç»ŸåŒ–æ¢³ç† DST scripts ç»“æ„ï¼šç›®å½•åˆ†å¸ƒã€å…³é”®ç±»åˆ«æ•°é‡ã€çƒ­ç‚¹æ–‡ä»¶ï¼ˆæŒ‰ä½“é‡ï¼‰ã€‚
- ä¸ºåç»­â€œè§£æå…¶ä»–æ•°æ®â€æä¾›å®è§‚è§†å›¾ä¸ä¼˜å…ˆçº§çº¿ç´¢ã€‚

Outputs
- data/reports/dst_codemap.md
- data/reports/dst_codemap.json

This tool reads DST scripts through src/engine.py (scripts.zip / scripts/).
"""

from __future__ import annotations

import argparse
import json
import os
import sys
from collections import Counter, defaultdict
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Tuple

PROJECT_ROOT = Path(__file__).resolve().parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

from engine import WagstaffEngine  # type: ignore

REPORT_DIR = PROJECT_ROOT / "data" / "reports"


def _now_iso() -> str:
    return datetime.now().astimezone().isoformat(timespec="seconds")


def _file_size(engine: WagstaffEngine, path: str) -> int:
    try:
        if engine.mode == "zip":
            return engine.source.getinfo(path).file_size  # type: ignore[attr-defined]
        real = os.path.join(engine.source, path.replace("scripts/", ""))  # type: ignore[arg-type]
        return os.path.getsize(real)
    except Exception:
        return -1


def build_codemap(engine: WagstaffEngine) -> Dict[str, object]:
    files = list(engine.file_list)
    lua_files = [f for f in files if f.endswith(".lua")]

    # Directory distribution (normalize scripts/ prefix)
    top_dir = Counter()
    second_dir = Counter()

    for f in lua_files:
        clean = f[8:] if f.startswith("scripts/") else f
        parts = clean.split("/")
        if len(parts) == 1:
            top_dir["[Root]"] += 1
        else:
            top_dir[parts[0]] += 1
            if len(parts) >= 2:
                second_dir[f"{parts[0]}/{parts[1]}"] += 1

    # Category counts
    categories: Dict[str, List[str]] = {
        "Prefabs": [f for f in lua_files if f.startswith("scripts/prefabs/")],
        "Components": [f for f in lua_files if f.startswith("scripts/components/")],
        "Stategraphs": [f for f in lua_files if f.startswith("scripts/stategraphs/")],
        "Brains": [f for f in lua_files if f.startswith("scripts/brains/")],
        "Behaviours": [f for f in lua_files if f.startswith("scripts/behaviours/")],
        "Widgets": [f for f in lua_files if f.startswith("scripts/widgets/")],
        "Screens": [f for f in lua_files if f.startswith("scripts/screens/")],
        "Strings": [f for f in lua_files if "strings" in f and f.startswith("scripts/")],
        "Recipes": [f for f in lua_files if f.endswith("recipes.lua") or f.endswith("recipes2.lua")],
        "Tuning": [f for f in lua_files if f.endswith("tuning.lua")],
    }

    cat_counts = {k: len(v) for k, v in categories.items()}

    # Largest files
    size_list: List[Tuple[int, str]] = []
    for f in lua_files:
        size_list.append((_file_size(engine, f), f))
    size_list.sort(key=lambda x: x[0], reverse=True)

    largest = [{"path": p, "bytes": s} for s, p in size_list[:50] if s >= 0]

    # Top directories
    top_dirs = [{"dir": d, "count": c} for d, c in top_dir.most_common(40)]
    top_second = [{"dir": d, "count": c} for d, c in second_dir.most_common(60)]

    return {
        "generated": _now_iso(),
        "engine_mode": engine.mode,
        "total_files": len(files),
        "lua_files": len(lua_files),
        "categories": cat_counts,
        "top_dirs": top_dirs,
        "top_second_level": top_second,
        "largest_lua_files": largest,
    }


def render_md(doc: Dict[str, object]) -> str:
    lines: List[str] = []
    lines.append("# DST Scripts Code Map")
    lines.append("")
    lines.append("## Meta")
    lines.append("```yaml")
    lines.append(f"generated: {doc.get('generated')}")
    lines.append(f"engine_mode: {doc.get('engine_mode')}")
    lines.append(f"total_files: {doc.get('total_files')}")
    lines.append(f"lua_files: {doc.get('lua_files')}")
    lines.append("```")

    lines.append("")
    lines.append("## Category Counts")
    lines.append("")
    lines.append("| Category | Count |")
    lines.append("|---|---:|")
    for k, v in sorted((doc.get("categories") or {}).items(), key=lambda x: x[0]):
        lines.append(f"| {k} | {v} |")

    lines.append("")
    lines.append("## Top Directories (Lua)")
    lines.append("")
    lines.append("| Dir | Files |")
    lines.append("|---|---:|")
    for item in doc.get("top_dirs") or []:
        lines.append(f"| {item['dir']} | {item['count']} |")

    lines.append("")
    lines.append("## Hotspots: Largest Lua Files")
    lines.append("")
    lines.append("| Bytes | Path |")
    lines.append("|---:|---|")
    for item in doc.get("largest_lua_files") or []:
        lines.append(f"| {item['bytes']} | `{item['path']}` |")

    lines.append("")
    lines.append("## Top 2nd-level Directories")
    lines.append("")
    lines.append("| Dir | Files |")
    lines.append("|---|---:|")
    for item in doc.get("top_second_level") or []:
        lines.append(f"| {item['dir']} | {item['count']} |")

    return "\n".join(lines) + "\n"


def main() -> None:
    parser = argparse.ArgumentParser(description="Generate DST scripts code map report.")
    parser.add_argument("--out-md", default=str(REPORT_DIR / "dst_codemap.md"))
    parser.add_argument("--out-json", default=str(REPORT_DIR / "dst_codemap.json"))
    args = parser.parse_args()

    REPORT_DIR.mkdir(parents=True, exist_ok=True)

    engine = WagstaffEngine(load_db=False, silent=True)
    doc = build_codemap(engine)

    md_path = Path(args.out_md)
    json_path = Path(args.out_json)

    md_path.write_text(render_md(doc), encoding="utf-8")
    json_path.write_text(json.dumps(doc, ensure_ascii=False, indent=2), encoding="utf-8")

    print(f"âœ… Code map written: {md_path}")
    print(f"âœ… JSON written: {json_path}")


if __name__ == "__main__":
    main()
```

### File: devtools/installer.py
- mode: full
- size_bytes: 3586
- sha256_12: b1feb4cd296f

```py
#!/usr/bin/env python3
import os
import sys
from pathlib import Path
from rich.console import Console

# å¼•å…¥æ³¨å†Œè¡¨
sys.path.append(os.path.join(os.path.dirname(__file__), "../src"))
from registry import get_tools

console = Console()

CURRENT_FILE = Path(__file__).resolve()
PROJECT_ROOT = CURRENT_FILE.parent.parent
BIN_DIR = PROJECT_ROOT / "bin"
SRC_DIR = PROJECT_ROOT / "src"
DEV_DIR = PROJECT_ROOT / "devtools"

def get_shell_config():
    home = Path.home()
    shell = os.environ.get("SHELL", "")
    if "zsh" in shell: return home / ".zshrc"
    elif "bash" in shell: return home / ".bashrc"
    else: return home / ".profile"

def create_wrappers():
    # 1. åˆ›å»º 'Wagstaff-Lab' ä¸»å…¥å£
    main_wrapper = BIN_DIR / "Wagstaff-Lab"
    with open(main_wrapper, 'w') as f:
        f.write('#!/bin/bash\n')
        f.write(f'python3 "{SRC_DIR}/guide.py" "$@"\n')
    os.chmod(main_wrapper, 0o755)
    
    # 2. åˆ›å»º 'pm' å¿«æ·æŒ‡ä»¤
    pm_wrapper = BIN_DIR / "pm"
    with open(pm_wrapper, 'w') as f:
        f.write('#!/bin/bash\n')
        f.write(f'python3 "{DEV_DIR}/pm.py" "$@"\n')
    os.chmod(pm_wrapper, 0o755)

    # 3. åŠ¨æ€åˆ›å»º 'wagstaff' å·¥å…·ç®± (åŸºäº Registry)
    ws_wrapper = BIN_DIR / "wagstaff"
    with open(ws_wrapper, 'w') as f:
        f.write('#!/bin/bash\n')
        
        # [ä¿®å¤é€»è¾‘] æ›´åŠ ç¨³å¥çš„å‚æ•°å¤„ç†
        # 1. è·å–ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä¸ºç©ºå­—ç¬¦ä¸² (é˜²æ­¢ unbound variable æŠ¥é”™)
        f.write('TOOL="${1:-}"\n')
        
        # 2. å¦‚æœå‚æ•°ä¸ºç©ºï¼Œç›´æ¥è½¬äº¤æ§åˆ¶æƒç»™ä¸»é¢æ¿ (exec æ›¿æ¢è¿›ç¨‹)
        f.write('if [ -z "$TOOL" ]; then\n')
        f.write(f'  exec "{main_wrapper}" "$@"\n')
        f.write('fi\n')
        
        # 3. åªæœ‰åœ¨æœ‰å‚æ•°æ—¶æ‰ shift
        f.write('shift\n')
        
        f.write('case "$TOOL" in\n')
        
        # --- åŠ¨æ€ç”Ÿæˆ Case åˆ†æ”¯ ---
        tools = get_tools()
        registered_aliases = []
        
        for tool in tools:
            alias = tool.get('alias')
            if not alias: continue # è·³è¿‡æ²¡æœ‰åˆ«åçš„å·¥å…·
            
            folder = tool.get('folder', 'src')
            if folder == 'src': abs_path = SRC_DIR
            elif folder == 'devtools': abs_path = DEV_DIR
            else: abs_path = PROJECT_ROOT / folder
            
            f.write(f'  {alias}) python3 "{abs_path}/{tool["file"]}" "$@" ;;\n')
            registered_aliases.append(f"{alias} ({tool['desc']})")
        # ------------------------

        # é»˜è®¤æƒ…å†µä¹Ÿè½¬äº¤ç»™ä¸»é¢æ¿
        f.write(f'  *) exec "{main_wrapper}" "$@" ;;\n') 
        f.write('esac\n')
    os.chmod(ws_wrapper, 0o755)
    
    console.print(f"[green]âœ… æŒ‡ä»¤æ³¨å†ŒæˆåŠŸ (Registry Driven)[/green]")
    console.print(f"   å·²è‡ªåŠ¨æ³¨å†Œ {len(registered_aliases)} ä¸ªå­å‘½ä»¤åˆ° 'wagstaff'")

def register_to_path():
    rc_file = get_shell_config()
    bin_path_str = str(BIN_DIR)
    
    if not rc_file.exists(): return

    content = rc_file.read_text()
    if f'export PATH="{bin_path_str}:$PATH"' in content:
        console.print("[dim]âš¡ ç¯å¢ƒå˜é‡å·²å°±ç»ª[/dim]")
    else:
        try:
            with open(rc_file, 'a') as f:
                f.write(f'\n# Wagstaff-Lab Environment\nexport PATH="{bin_path_str}:$PATH"\n')
            console.print(f"[green]âœ… PATH å·²æ›´æ–°[/green]")
        except Exception:
            pass

def main():
    console.print("[bold blue]ğŸ”§ Wagstaff-Lab è‡ªåŠ¨åŒ–æ³¨å†Œä¸­å¿ƒ[/bold blue]")
    create_wrappers()
    register_to_path()

if __name__ == "__main__":
    main()
```

### File: devtools/pm.py
- mode: full
- size_bytes: 4956
- sha256_12: 21cc6d8ef466

```py
#!/usr/bin/env python3
import os
import json
import sys
from pathlib import Path
from datetime import datetime
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.prompt import Prompt, IntPrompt

console = Console()

# [ä¿®å¤] é”å®šç»å¯¹è·¯å¾„ï¼Œä¸å†ä¾èµ–å½“å‰å·¥ä½œç›®å½•
PROJECT_ROOT = Path(__file__).resolve().parent.parent
STATUS_FILE = PROJECT_ROOT / "PROJECT_STATUS.json"

class ProjectManager:
    def __init__(self):
        self.data = self._load()

    def _load(self):
        # [ä¼˜åŒ–] ä½¿ç”¨ Path å¯¹è±¡æ£€æŸ¥æ–‡ä»¶
        if STATUS_FILE.exists():
            with open(STATUS_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        return {"objective": "Unset", "tasks": [], "logs": [], "guidelines": []}

    def _save(self):
        # [ä¼˜åŒ–] åŸå­å†™å…¥ï¼šå…ˆå†™ .tmp å†é‡å‘½åï¼Œé˜²æ­¢æ•°æ®æŸå
        tmp = STATUS_FILE.with_name(STATUS_FILE.name + ".tmp")
        with open(tmp, 'w', encoding='utf-8') as f:
            json.dump(self.data, f, indent=2, ensure_ascii=False)
        tmp.replace(STATUS_FILE)

    def set_objective(self, obj):
        self.data["objective"] = obj
        self._save()
        console.print(f"[green]âœ… ç›®æ ‡æ›´æ–°:[/green] {obj}")

    def add_task(self, task):
        self.data["tasks"].append({"desc": task, "status": "todo", "time": str(datetime.now())})
        self._save()
        console.print(f"[green]âœ… ä»»åŠ¡+1:[/green] {task}")
    
    def add_rule(self, rule):
        if "guidelines" not in self.data: self.data["guidelines"] = []
        self.data["guidelines"].append(rule)
        self._save()
        console.print(f"[bold magenta]ğŸ“œ å®—æ—¨å½•å…¥:[/bold magenta] {rule}")

    def complete_task(self, index):
        if 0 <= index < len(self.data["tasks"]):
            self.data["tasks"][index]["status"] = "done"
            self._save()
            console.print(f"[green]ğŸ‰ å®Œæˆ:[/green] {self.data['tasks'][index]['desc']}")
        else:
            console.print("[red]âŒ ç´¢å¼•æ— æ•ˆ[/red]")

    def log_entry(self, msg):
        self.data["logs"].append(f"[{datetime.now().strftime('%Y-%m-%d %H:%M')}] {msg}")
        if len(self.data["logs"]) > 10: self.data["logs"].pop(0)
        self._save()
        console.print("[green]ğŸ“ æ—¥å¿—å·²è®°å½•[/green]")

    def show_status(self):
        console.clear()
        console.print(Panel(f"[bold blue]ğŸ¯ ç›®æ ‡: {self.data.get('objective', 'Unset')}[/bold blue]"))
        
        t_table = Table(title="ä»»åŠ¡æ¸…å•", box=None)
        t_table.add_column("ID", style="dim"); t_table.add_column("çŠ¶æ€"); t_table.add_column("å†…å®¹")
        for i, t in enumerate(self.data["tasks"]):
            status = "âœ…" if t["status"] == "done" else "â¬œ"
            style = "dim strike" if t["status"] == "done" else "bold"
            t_table.add_row(str(i), status, f"[{style}]{t['desc']}[/{style}]")
        console.print(t_table)
        
        if self.data.get("logs"):
            console.print("\n[dim]ğŸ“œ æœ€è¿‘æ—¥å¿—:[/dim]")
            for l in self.data["logs"][-3:]:
                console.print(f"  {l}")

    def interactive_mode(self):
        while True:
            self.show_status()
            console.print("\n[bold cyan]æ“ä½œèœå•:[/bold cyan]")
            console.print("1. [green]âœ… å®Œæˆä»»åŠ¡[/]  2. [blue]â• æ–°å¢ä»»åŠ¡[/]  3. [magenta]ğŸ“ å†™æ—¥å¿—[/]  4. [yellow]ğŸ¯ æ”¹ç›®æ ‡[/]  0. [red]é€€å‡º[/]")
            
            choice = Prompt.ask("é€‰æ‹©æ“ä½œ", choices=["0", "1", "2", "3", "4"], default="0")
            
            if choice == "0": break
            elif choice == "1":
                idx = IntPrompt.ask("è¾“å…¥ä»»åŠ¡ID")
                self.complete_task(idx)
            elif choice == "2":
                desc = Prompt.ask("è¾“å…¥ä»»åŠ¡æè¿°")
                self.add_task(desc)
            elif choice == "3":
                log = Prompt.ask("è¾“å…¥æ—¥å¿—å†…å®¹")
                self.log_entry(log)
            elif choice == "4":
                obj = Prompt.ask("è¾“å…¥æ–°ç›®æ ‡")
                self.set_objective(obj)
            
            if choice != "0":
                input("\næŒ‰å›è½¦ç»§ç»­...")

def main():
    pm = ProjectManager()
    if len(sys.argv) > 1:
        cmd = sys.argv[1]
        content = " ".join(sys.argv[2:])
        
        if cmd == "obj": pm.set_objective(content)
        elif cmd == "add": pm.add_task(content)
        elif cmd == "rule": pm.add_rule(content)
        elif cmd == "done":
            # [ä¿®å¤] å¢åŠ å‚æ•°æ£€æŸ¥
            if len(sys.argv) < 3:
                console.print("[red]ç”¨æ³•: pm done <task_id>[/red]")
                return
            pm.complete_task(int(sys.argv[2]))
        elif cmd == "log": pm.log_entry(content)
        elif cmd == "ui": pm.interactive_mode()
        else: pm.show_status()
    else:
        pm.interactive_mode()

if __name__ == "__main__":
    main()
```

### File: devtools/reporter.py
- mode: full
- size_bytes: 4763
- sha256_12: 915b1577a0aa

```py
#!/usr/bin/env python3
import os
import sys
import re
from collections import Counter, defaultdict
from rich.console import Console
from rich.progress import track

# æŒ‚è½½ src å¹¶å¼•å…¥å¼•æ“
sys.path.append(os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "src"))
from engine import WagstaffEngine

console = Console()

# === [ä¿®å¤] åŠ¨æ€å®šä½é¡¹ç›®è·¯å¾„ ===
CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.dirname(CURRENT_DIR)
REPORT_DIR = os.path.join(PROJECT_ROOT, "data", "reports")

class WagstaffReporter:
    def __init__(self):
        # å¯åŠ¨å¼•æ“ï¼Œä¸éœ€è¦åŠ è½½æ•°æ®åº“(æˆ‘ä»¬åªåšæ­£åˆ™æ‰«æ)
        self.engine = WagstaffEngine(load_db=False, silent=True)
        self._ensure_report_dir()

    def _ensure_report_dir(self):
        if not os.path.exists(REPORT_DIR):
            os.makedirs(REPORT_DIR)
            console.print(f"[green]ğŸ“ åˆ›å»ºæŠ¥å‘Šç›®å½•: {REPORT_DIR}[/green]")

    def generate_asset_report(self):
        """æ‰«æå…¨æœèµ„äº§åˆ†å¸ƒ"""
        console.print("[bold blue]ğŸ“¡ æ­£åœ¨ç”Ÿæˆèµ„äº§åˆ†å¸ƒæŠ¥å‘Š...[/bold blue]")
        
        TARGETS = {
            "STRINGS": re.compile(r'STRINGS\.[A-Z0-9_]+\s*='),
            "Prefabs": re.compile(r'\bPrefab\s*\('),
            "LootTables": re.compile(r'\bSetLoot\s*\(|\bSetChanceLoot\s*\('),
            "Brains": re.compile(r'require\s*[\("\']brains/'),
            "Widgets": re.compile(r'require\s*[\("\']widgets/'),
        }
        
        stats = defaultdict(Counter)
        lua_files = [f for f in self.engine.file_list if f.endswith(".lua")]
        
        for fname in track(lua_files, description="Scanning Assets..."):
            content = self.engine.read_file(fname)
            if not content: continue
            clean = re.sub(r'--.*$', '', content, flags=re.MULTILINE)
            
            for cat, pattern in TARGETS.items():
                matches = pattern.findall(clean)
                if matches:
                    stats[cat][fname] += len(matches)

        out_path = os.path.join(REPORT_DIR, "asset_registry.md")
        with open(out_path, 'w', encoding='utf-8') as f:
            f.write("# Wagstaff Asset Registry\n\n")
            f.write("| Category | Total Definitions | Top File |\n")
            f.write("|----------|-------------------|----------|\n")
            for cat, file_counts in stats.items():
                total = sum(file_counts.values())
                top_file = file_counts.most_common(1)[0][0]
                f.write(f"| {cat} | {total} | `{top_file}` |\n")
            
            f.write("\n## Detailed Breakdown\n")
            for cat, file_counts in stats.items():
                f.write(f"\n### {cat}\n")
                for fname, count in file_counts.most_common(10):
                    f.write(f"- `{fname}`: {count}\n")
        console.print(f"[green]âœ… æŠ¥å‘Šå·²ä¿å­˜: {out_path}[/green]")

    def generate_recipe_report(self):
        """æ‰«æé…æ–¹åˆ†å¸ƒ"""
        console.print("[bold blue]ğŸ³ æ­£åœ¨ç”Ÿæˆé…æ–¹åˆ†å¸ƒæŠ¥å‘Š...[/bold blue]")
        
        pattern = re.compile(r'^\s*([a-zA-Z0-9_]*Recipe[a-zA-Z0-9_]*)\s*\(', re.MULTILINE)
        stats = Counter()
        file_stats = defaultdict(int)
        
        lua_files = [f for f in self.engine.file_list if f.endswith(".lua")]
        
        for fname in track(lua_files, description="Scanning Recipes..."):
            content = self.engine.read_file(fname)
            if not content: continue
            clean = re.sub(r'--.*$', '', content, flags=re.MULTILINE)
            
            matches = pattern.findall(clean)
            for m in matches:
                if "Get" in m or "Find" in m: continue
                stats[m] += 1
                file_stats[fname] += 1

        out_path = os.path.join(REPORT_DIR, "recipe_distribution.md")
        with open(out_path, 'w', encoding='utf-8') as f:
            f.write("# Wagstaff Recipe Distribution\n\n")
            f.write("## Function Usage\n")
            for func, count in stats.most_common():
                f.write(f"- **{func}**: {count}\n")
            f.write("\n## File Hotspots (Top 20)\n")
            for fname, count in sorted(file_stats.items(), key=lambda x:x[1], reverse=True)[:20]:
                f.write(f"- `{fname}`: {count} recipes\n")

        console.print(f"[green]âœ… æŠ¥å‘Šå·²ä¿å­˜: {out_path}[/green]")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python reporter.py [assets|recipes|all]")
        sys.exit(1)
    reporter = WagstaffReporter()
    cmd = sys.argv[1]
    if cmd == "assets" or cmd == "all": reporter.generate_asset_report()
    if cmd == "recipes" or cmd == "all": reporter.generate_recipe_report()
```

### File: devtools/sampler.py
- mode: full
- size_bytes: 14604
- sha256_12: 2eaf081041e4

```py
#!/usr/bin/env python3
"""Wagstaff-Lab Sample Pack Generator

Purpose
- ä¸ºâ€œè§£æå…¶ä»–æ•°æ®ç±»å‹ï¼ˆSTRINGS/Widgets/Brains/Stategraphs/LootTables/Componentsâ€¦ï¼‰â€å‡†å¤‡å¯å¤ç”¨æ ·æœ¬ã€‚
- è¾“å‡ºä¸€ä¸ª *å¯ç›´æ¥å–‚ç»™å¤§æ¨¡å‹* çš„ Markdownï¼ˆå¸¦ head + line-numbered snippetsï¼‰ï¼Œå¹¶è½ç›˜ manifest.json ä¾¿äºè¿½æº¯ã€‚

Outputs
- data/samples/samples_<timestamp>.md
- data/samples/samples_<timestamp>.manifest.json

Notes
- è¯»å–æ•°æ®æºæ¥è‡ª DST çš„ scripts.zip / scripts/ ç›®å½•ï¼ˆé€šè¿‡ src/engine.pyï¼‰ã€‚
- æ ·æœ¬é€‰æ‹©ä¼˜å…ˆå‚è€ƒ data/reports/asset_registry.mdï¼ˆå¦‚æœå­˜åœ¨ï¼‰ã€‚
"""

from __future__ import annotations

import argparse
import hashlib
import json
import os
import random
import re
import sys
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Sequence, Tuple

# Mount src/
PROJECT_ROOT = Path(__file__).resolve().parent.parent
sys.path.append(str(PROJECT_ROOT / "src"))

from engine import WagstaffEngine  # type: ignore

OUT_DIR = PROJECT_ROOT / "data" / "samples"
REPORT_DIR = PROJECT_ROOT / "data" / "reports"

DEFAULT_CATEGORIES = ["STRINGS", "Widgets", "Brains", "Stategraphs", "LootTables", "Components"]

# Fallback picks (used when no report-based guidance is available)
DEFAULT_FILES: Dict[str, List[str]] = {
    "STRINGS": ["scripts/strings.lua", "scripts/skin_strings.lua"],
    "Widgets": ["scripts/widgets/controls.lua", "scripts/screens/playerhud.lua"],
    "Brains": ["scripts/prefabs/pigman.lua", "scripts/prefabs/merm.lua"],
    "Stategraphs": ["scripts/stategraphs/SGwilson.lua", "scripts/stategraphs/SGwilson_client.lua"],
    "LootTables": ["scripts/prefabs/deciduoustrees.lua", "scripts/prefabs/evergreens.lua"],
    "Components": ["scripts/components/scenariorunner.lua", "scripts/components/debuffable.lua"],
}

CATEGORY_PREFIX_HINTS: Dict[str, List[str]] = {
    "Components": ["scripts/components/"],
    "Stategraphs": ["scripts/stategraphs/"],
    "Widgets": ["scripts/widgets/", "scripts/screens/"],
    "Brains": ["scripts/brains/", "scripts/behaviours/"]
}

# Snippet patterns are intentionally lightweight (line-based) for speed.
CATEGORY_PATTERNS: Dict[str, List[re.Pattern]] = {
    "STRINGS": [
        re.compile(r"\bSTRINGS\.[A-Z0-9_]+\b"),
        re.compile(r"\bSTRINGS\s*=\s*\{"),
    ],
    "Widgets": [
        re.compile(r"\brequire\s*\(?[\"']widgets/"),
        re.compile(r"\bClass\s*\("),
        re.compile(r"\bWidget\b"),
    ],
    "Brains": [
        re.compile(r"\brequire\s*\(?[\"']brains/"),
        re.compile(r"\brequire\s*\(?[\"']behaviours/"),
        re.compile(r"\bBrain\b"),
    ],
    "Stategraphs": [
        re.compile(r"\bStateGraph\s*\("),
        re.compile(r"\bstates\s*=\s*\{"),
        re.compile(r"\bevents\s*=\s*\{"),
    ],
    "LootTables": [
        re.compile(r"\bSetLoot\s*\("),
        re.compile(r"\bSetChanceLoot\s*\("),
        re.compile(r"\bloot\b"),
    ],
    "Components": [
        re.compile(r"\bClass\s*\("),
        re.compile(r"\binst:AddComponent\b"),
        re.compile(r"\bself\.[a-zA-Z0-9_]+\s*=\s*"),
    ],
}


def _now_iso() -> str:
    # Keep timezone offset (astimezone) for reproducibility across machines.
    return datetime.now().astimezone().isoformat(timespec="seconds")


def _now_ts() -> str:
    return datetime.now().strftime("%Y%m%d_%H%M%S")


def _sha256_12_text(text: str) -> str:
    h = hashlib.sha256(text.encode("utf-8", errors="replace"))
    return h.hexdigest()[:12]


def _safe_read_asset_registry(path: Path) -> Dict[str, List[str]]:
    """Parse data/reports/asset_registry.md into {Category: [file1, file2, ...]}.

    This report is generated by devtools/reporter.py. It includes sections like:
    ### Widgets
    - `scripts/widgets/controls.lua`: 35
    """
    if not path.exists():
        return {}

    text = path.read_text(encoding="utf-8", errors="replace")
    lines = text.splitlines()

    current: Optional[str] = None
    out: Dict[str, List[str]] = {}

    header_re = re.compile(r"^###\s+(.+?)\s*$")
    item_re = re.compile(r"^\-\s+`([^`]+)`:\s*\d+\s*$")

    for line in lines:
        m = header_re.match(line)
        if m:
            current = m.group(1).strip()
            out.setdefault(current, [])
            continue
        m = item_re.match(line)
        if m and current:
            out.setdefault(current, []).append(m.group(1).strip())

    return out


def _file_size(engine: WagstaffEngine, path: str) -> int:
    try:
        if engine.mode == "zip":
            return engine.source.getinfo(path).file_size  # type: ignore[attr-defined]
        # folder
        real = os.path.join(engine.source, path.replace("scripts/", ""))  # type: ignore[arg-type]
        return os.path.getsize(real)
    except Exception:
        return -1


def _choose_files(
    engine: WagstaffEngine,
    category: str,
    n: int,
    registry_map: Dict[str, List[str]],
    rng: random.Random,
) -> List[str]:
    # 1) Prefer asset_registry.md hints
    picked: List[str] = []
    if category in registry_map:
        for p in registry_map[category]:
            if p in engine.file_list:
                picked.append(p)
            if len(picked) >= n:
                return picked

    # 2) Fallback defaults
    for p in DEFAULT_FILES.get(category, []):
        if p in engine.file_list and p not in picked:
            picked.append(p)
        if len(picked) >= n:
            return picked

    # 3) Prefix-based discovery
    prefixes = CATEGORY_PREFIX_HINTS.get(category, [])
    if prefixes:
        candidates: List[str] = []
        for f in engine.file_list:
            if not f.endswith(".lua"):
                continue
            if any(f.startswith(pref) for pref in prefixes):
                candidates.append(f)

        # Prefer larger files (tend to contain more structure)
        candidates.sort(key=lambda p: _file_size(engine, p), reverse=True)
        for p in candidates:
            if p not in picked:
                picked.append(p)
            if len(picked) >= n:
                return picked

    # 4) Last resort: random lua files
    lua_files = [f for f in engine.file_list if f.endswith(".lua")]
    rng.shuffle(lua_files)
    for p in lua_files:
        if p not in picked:
            picked.append(p)
        if len(picked) >= n:
            return picked

    return picked


def _pick_snippet_lines(
    lines: List[str],
    patterns: Sequence[re.Pattern],
    snippet_blocks: int,
    context_lines: int,
    rng: random.Random,
) -> List[Tuple[int, int]]:
    """Return a list of (start_idx, end_idx_exclusive) ranges."""
    match_idxs: List[int] = []
    for i, line in enumerate(lines):
        for pat in patterns:
            if pat.search(line):
                match_idxs.append(i)
                break

    # Dedup while preserving order
    seen = set()
    match_idxs = [i for i in match_idxs if not (i in seen or seen.add(i))]

    # If too many matches, sample evenly across the file for coverage
    chosen_idxs: List[int] = []
    if len(match_idxs) == 0:
        # fallback: choose some random anchors
        if lines:
            anchors = list(range(0, len(lines), max(1, len(lines) // max(1, snippet_blocks))))
            rng.shuffle(anchors)
            chosen_idxs = sorted(anchors[:snippet_blocks])
    elif len(match_idxs) <= snippet_blocks:
        chosen_idxs = match_idxs
    else:
        if snippet_blocks == 1:
            chosen_idxs = [match_idxs[len(match_idxs) // 2]]
        else:
            for k in range(snippet_blocks):
                pos = int(k * (len(match_idxs) - 1) / (snippet_blocks - 1))
                chosen_idxs.append(match_idxs[pos])

    ranges: List[Tuple[int, int]] = []
    covered: List[Tuple[int, int]] = []

    for idx in chosen_idxs:
        s = max(0, idx - context_lines)
        e = min(len(lines), idx + context_lines + 1)

        # Skip heavy overlap
        overlapped = False
        for cs, ce in covered:
            if not (e <= cs or s >= ce):
                overlapped = True
                break
        if overlapped:
            continue

        covered.append((s, e))
        ranges.append((s, e))

    return ranges


def _render_snippet(lines: List[str], start: int, end: int) -> str:
    out: List[str] = []
    for i in range(start, end):
        ln = i + 1
        out.append(f"{ln:5d}: {lines[i]}")
    return "\n".join(out)


def _cap_text(text: str, max_chars: int) -> Tuple[str, bool]:
    if len(text) <= max_chars:
        return text, False
    return text[: max_chars - 200] + "\n\n[TRUNCATED: per-file cap]\n", True


@dataclass
class FileSample:
    path: str
    sha256_12: str
    lines: int
    head_lines: int
    snippet_blocks: int
    rendered: str


def build_sample_pack(
    categories: List[str],
    n_files_per_category: int,
    head_lines: int,
    snippet_blocks: int,
    context_lines: int,
    max_chars_per_file: int,
    max_total_chars: int,
    seed: int,
) -> Tuple[str, Dict[str, object]]:
    engine = WagstaffEngine(load_db=False, silent=True)

    asset_registry_path = REPORT_DIR / "asset_registry.md"
    recipe_distribution_path = REPORT_DIR / "recipe_distribution.md"

    registry_map = _safe_read_asset_registry(asset_registry_path)

    rng = random.Random(seed)

    # Collect samples
    chosen: Dict[str, List[str]] = {}
    files_meta: Dict[str, List[Dict[str, object]]] = {}

    md: List[str] = []
    md.append("# Wagstaff-Lab Lua Sample Pack")
    md.append("")
    md.append("## Meta")
    md.append("```yaml")
    md.append(f"generated: {_now_iso()}")
    md.append(f"engine_mode: {engine.mode}")
    md.append(f"categories: {categories}")
    md.append(f"n_files_per_category: {n_files_per_category}")
    md.append(f"head_lines: {head_lines}")
    md.append(f"snippet_blocks: {snippet_blocks}")
    md.append(f"context_lines: {context_lines}")
    md.append("```")

    total_chars = sum(len(x) + 1 for x in md)

    for cat in categories:
        md.append("")
        md.append(f"## Category: {cat}")
        md.append("")

        selected = _choose_files(engine, cat, n_files_per_category, registry_map, rng)
        chosen[cat] = selected
        files_meta[cat] = []

        patterns = CATEGORY_PATTERNS.get(cat, [])

        for p in selected:
            content = engine.read_file(p) or ""
            if not content:
                continue

            lines = content.splitlines()

            head = "\n".join(lines[:head_lines])
            ranges = _pick_snippet_lines(lines, patterns, snippet_blocks, context_lines, rng)

            snips: List[str] = []
            for i, (s, e) in enumerate(ranges, start=1):
                snips.append(f"**Snippet {i}**\n```lua\n{_render_snippet(lines, s, e)}\n```")

            rendered = []
            rendered.append(f"### File: {p}")
            sha = _sha256_12_text(content)
            rendered.append(f"> sha256_12={sha}, lines={len(lines)}")
            rendered.append("")
            rendered.append("#### Head")
            rendered.append("```lua")
            rendered.append(head)
            rendered.append("```")
            rendered.append("")
            rendered.append("#### Snippets (line-numbered)")
            rendered.append("")
            rendered.append("\n\n".join(snips) if snips else "(no snippets found)")

            block = "\n".join(rendered) + "\n"
            block, truncated = _cap_text(block, max_chars_per_file)

            # Total budget check
            if total_chars + len(block) > max_total_chars:
                md.append("\n[STOP: max_total_chars reached]\n")
                break

            md.append(block)
            total_chars += len(block)

            files_meta[cat].append(
                {
                    "path": p,
                    "sha256_12": sha,
                    "lines": len(lines),
                    "head_lines": min(head_lines, len(lines)),
                    "snippet_blocks": len(ranges),
                    "truncated": truncated,
                }
            )

    manifest: Dict[str, object] = {
        "generated": _now_iso(),
        "engine_mode": engine.mode,
        "categories": categories,
        "chosen": chosen,
        "files": files_meta,
        "source_reports": {
            "asset_registry": str(asset_registry_path) if asset_registry_path.exists() else None,
            "recipe_distribution": str(recipe_distribution_path) if recipe_distribution_path.exists() else None,
        },
        "params": {
            "n_files_per_category": n_files_per_category,
            "head_lines": head_lines,
            "snippet_blocks": snippet_blocks,
            "context_lines": context_lines,
            "seed": seed,
        },
        "limits": {
            "max_chars_per_file": max_chars_per_file,
            "max_total_chars": max_total_chars,
        },
    }

    return "\n".join(md) + "\n", manifest


def main() -> None:
    parser = argparse.ArgumentParser(description="Generate DST Lua sample pack for parser development.")
    parser.add_argument("--categories", nargs="*", default=DEFAULT_CATEGORIES, help="Categories to include")
    parser.add_argument("--n", type=int, default=2, help="Files per category")
    parser.add_argument("--head-lines", type=int, default=120)
    parser.add_argument("--snippet-blocks", type=int, default=10)
    parser.add_argument("--context-lines", type=int, default=4)
    parser.add_argument("--max-chars-per-file", type=int, default=18000)
    parser.add_argument("--max-total-chars", type=int, default=260000)
    parser.add_argument("--seed", type=int, default=0)
    parser.add_argument("--out-dir", default=str(OUT_DIR))
    args = parser.parse_args()

    out_dir = Path(args.out_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    md, manifest = build_sample_pack(
        categories=list(args.categories),
        n_files_per_category=args.n,
        head_lines=args.head_lines,
        snippet_blocks=args.snippet_blocks,
        context_lines=args.context_lines,
        max_chars_per_file=args.max_chars_per_file,
        max_total_chars=args.max_total_chars,
        seed=args.seed,
    )

    ts = _now_ts()
    md_path = out_dir / f"samples_{ts}.md"
    manifest_path = out_dir / f"samples_{ts}.manifest.json"

    md_path.write_text(md, encoding="utf-8")
    manifest_path.write_text(json.dumps(manifest, ensure_ascii=False, indent=2), encoding="utf-8")

    print(f"âœ… Sample pack written: {md_path}")
    print(f"âœ… Manifest written: {manifest_path}")


if __name__ == "__main__":
    main()
```

### File: devtools/snapshot.py
- mode: full
- size_bytes: 30382
- sha256_12: d4f3890bf272

```py
#!/usr/bin/env python3
"""Wagstaff-Lab Snapshot (v4)

Goal:
- Provide two primary modes:
  - core: LLM-friendly snapshot (project overview + core code full + non-core interfaces/head)
  - archive: archival snapshot (full content as much as possible + optional zip bundle)
- Provide custom templates via JSON config (growth-friendly).

Default behavior:
- `wagstaff snap` => core template => writes project_context.txt

Template config:
- Default path: conf/snapshot_templates.json
- See the example template file for schema.
"""

from __future__ import annotations

import argparse
import ast
import fnmatch
import hashlib
import json
import os
import platform
import re
import subprocess
import sys
import textwrap
import zipfile
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path, PurePosixPath
from typing import Any, Dict, Iterable, List, Optional, Tuple

PROJECT_ROOT = Path(__file__).resolve().parent.parent
DEFAULT_CONFIG = PROJECT_ROOT / "conf" / "snapshot_templates.json"

DEFAULT_IGNORE_DIRS = {
    ".git",
    "__pycache__",
    ".pytest_cache",
    "logs",
    "env",
    "venv",
    ".idea",
    ".vscode",
    "node_modules",
    "dist",
    "build",
}

DEFAULT_IGNORE_FILES = {
    "project_context.txt",
    ".DS_Store",
    "id_rsa",
    "id_ed25519",
    "known_hosts",
}

# Conservative binary-ish extensions we almost never want in an LLM snapshot.
DEFAULT_IGNORE_GLOBS = [
    "data/snapshots/**",
    "**/*.swp",
    "**/*.swo",
    "**/*.tmp",
    "**/*.bak",
    "**/*.log",
    "**/*.zip",
    "**/*.tar",
    "**/*.tar.gz",
    "**/*.gz",
    "**/*.7z",
    "**/*.rar",
    "**/*.png",
    "**/*.jpg",
    "**/*.jpeg",
    "**/*.webp",
    "**/*.pdf",
    "**/*.mp4",
    "**/*.mov",
    "**/*.sqlite",
    "**/*.db",
    "**/.env",
    "**/.env.*",
    "**/*.pem",
    "**/*.key",
]

# Minimal built-in templates (used if conf/snapshot_templates.json is missing).
BUILTIN_TEMPLATES = {
    "core": {
        "desc": "Builtin core template",
        "output": "project_context.txt",
        "redact": True,
        "include_reports": True,
        "max_file_bytes": 200000,
        "max_total_bytes": 1200000,
        "tree": {"max_depth": 8, "max_entries_per_dir": 250},
        "include_globs": [
            "README.md",
            "PROJECT_STATUS.json",
            ".gitignore",
            "conf/**/*.ini",
            "src/**/*.py",
            "devtools/**/*.py",
            "tests/**/*.py",
            "bin/**",
            "data/reports/**/*.md",
            "data/samples/**/*",
        ],
        "ignore_files": sorted(DEFAULT_IGNORE_FILES),
        "ignore_globs": list(DEFAULT_IGNORE_GLOBS),
        "rules": [
            {"match": "src/**/*.py", "mode": "full"},
            {"match": "devtools/**/*.py", "mode": "interface"},
            {"match": "bin/**", "mode": "head", "head_lines": 160},
            {"match": "data/reports/**/*.md", "mode": "head", "head_lines": 260},
            {"match": "**/*", "mode": "skip"},
        ],
    },
    "archive": {
        "desc": "Builtin archive template",
        "output": "data/snapshots/archive_{timestamp}.md",
        "make_zip": True,
        "zip_output": "data/snapshots/archive_{timestamp}.zip",
        "redact": True,
        "include_reports": True,
        "max_file_bytes": 500000,
        "max_total_bytes": 20000000,
        "tree": {"max_depth": 30, "max_entries_per_dir": 1000},
        "include_globs": ["**/*"],
        "ignore_files": sorted(DEFAULT_IGNORE_FILES),
        "ignore_globs": list(DEFAULT_IGNORE_GLOBS),
        "rules": [{"match": "**/*", "mode": "full"}],
    },
}


@dataclass
class FileRecord:
    rel_posix: str
    abs_path: Path
    size_bytes: int
    sha256_12: str
    mode: str
    rendered_bytes: int = 0
    truncated: bool = False
    note: str = ""


def _now_ts() -> str:
    return datetime.now().strftime("%Y%m%d_%H%M%S")


def _run_cmd(cmd: str) -> str:
    try:
        return subprocess.check_output(
            cmd,
            shell=True,
            text=True,
            cwd=str(PROJECT_ROOT),
            stderr=subprocess.DEVNULL,
        ).strip()
    except Exception:
        return "Unknown"


def get_system_fingerprint() -> str:
    info = []
    info.append(f"Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    info.append(f"User: {os.getenv('USER', 'Unknown')}")
    info.append(f"Host: {platform.node()} ({platform.system()} {platform.release()})")
    info.append(f"Python: {platform.python_version()} ({sys.executable})")
    try:
        import rich  # type: ignore

        ver = getattr(rich, "__version__", "Installed (ver unknown)")
        info.append(f"Rich Ver: {ver}")
    except Exception:
        info.append("Rich Ver: Not Installed")
    return "\n".join(info)


def get_git_status() -> str:
    if not (PROJECT_ROOT / ".git").exists():
        return "Git: Not a repository"
    branch = _run_cmd("git rev-parse --abbrev-ref HEAD")
    commit = _run_cmd("git rev-parse --short HEAD")
    last_msg = _run_cmd("git log -1 --pretty=%B")
    is_dirty = _run_cmd("git status --porcelain") != ""
    dirty_mark = " [DIRTY]" if is_dirty else " [CLEAN]"
    return f"Branch: {branch}{dirty_mark}\nCommit: {commit}\nMessage: {last_msg}"


def _is_probably_binary(path: Path) -> bool:
    try:
        with open(path, "rb") as f:
            chunk = f.read(2048)
        if b"\x00" in chunk:
            return True
        # Heuristic: if too many non-text bytes, treat as binary.
        text_chars = bytearray({7, 8, 9, 10, 12, 13, 27} | set(range(0x20, 0x100)))
        nontext = chunk.translate(None, text_chars)
        return len(nontext) / max(len(chunk), 1) > 0.30
    except Exception:
        return True


_SECRET_KV_RE = re.compile(
    r"(?i)\b(password|passphrase|token|secret|api[_-]?key|client[_-]?secret|access[_-]?key)\b\s*[:=]\s*([^\n\r]+)"
)


def _redact(text: str) -> str:
    # Block private keys
    text = re.sub(
        r"-----BEGIN [A-Z ]*PRIVATE KEY-----.*?-----END [A-Z ]*PRIVATE KEY-----",
        "-----BEGIN PRIVATE KEY-----
<REDACTED>
-----END PRIVATE KEY-----",
        text,
        flags=re.DOTALL,
    )

    def _kv_sub(m: re.Match) -> str:
        key = m.group(1)
        return f"{key}=<REDACTED>"

    text = _SECRET_KV_RE.sub(_kv_sub, text)
    return text


def _sha256_12(path: Path) -> str:
    h = hashlib.sha256()
    with open(path, "rb") as f:
        for chunk in iter(lambda: f.read(1024 * 256), b""):
            h.update(chunk)
    return h.hexdigest()[:12]


def _posix_rel(path: Path) -> str:
    return path.relative_to(PROJECT_ROOT).as_posix()


def _match_glob(rel_posix: str, pattern: str) -> bool:
    # Prefer pathlib's match to get ** semantics.
    try:
        return PurePosixPath(rel_posix).match(pattern)
    except Exception:
        return fnmatch.fnmatch(rel_posix, pattern)


def _load_templates(config_path: Path) -> Dict[str, Any]:
    if config_path.exists():
        try:
            data = json.loads(config_path.read_text(encoding="utf-8"))
            if isinstance(data, dict) and isinstance(data.get("templates"), dict):
                return data
        except Exception:
            pass
    # Fallback
    return {
        "version": 1,
        "defaults": {"mode_to_template": {"core": "core", "archive": "archive", "custom": "core"}},
        "templates": BUILTIN_TEMPLATES,
    }


def _resolve_template(templates_doc: Dict[str, Any], mode: str, template_name: Optional[str]) -> Tuple[str, Dict[str, Any]]:
    templates = templates_doc.get("templates", {})
    if template_name:
        if template_name not in templates:
            raise SystemExit(f"Unknown template: {template_name}")
        return template_name, templates[template_name]

    defaults = templates_doc.get("defaults", {}).get("mode_to_template", {})
    picked = defaults.get(mode, mode)
    if picked in templates:
        return picked, templates[picked]

    if mode in templates:
        return mode, templates[mode]

    # Fallback to core
    return "core", templates.get("core", BUILTIN_TEMPLATES["core"])


def _ensure_parent(path: Path) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)


def _iter_candidates(include_globs: List[str]) -> List[Path]:
    files: List[Path] = []
    seen: set[str] = set()
    for pattern in include_globs:
        for p in PROJECT_ROOT.glob(pattern):
            if p.is_dir():
                continue
            try:
                rel = _posix_rel(p)
            except Exception:
                continue
            if rel in seen:
                continue
            seen.add(rel)
            files.append(p)
    files.sort(key=lambda x: _posix_rel(x))
    return files


def _should_ignore(path: Path, ignore_files: set[str], ignore_globs: List[str], ignore_dirs: set[str]) -> bool:
    # Fast dir ignore
    parts = set(path.parts)
    if parts & ignore_dirs:
        return True

    if path.name in ignore_files:
        return True

    rel = _posix_rel(path)
    for pat in ignore_globs:
        if _match_glob(rel, pat):
            return True

    return False


def _pick_rule(rel_posix: str, rules: List[Dict[str, Any]]) -> Dict[str, Any]:
    for r in rules:
        pat = r.get("match")
        if not pat:
            continue
        if _match_glob(rel_posix, pat):
            return r
    return {"mode": "skip"}


def _read_text_limited(path: Path, max_bytes: int) -> Tuple[str, bool]:
    # Returns (text, truncated)
    size = path.stat().st_size
    truncated = size > max_bytes
    with open(path, "rb") as f:
        data = f.read(max_bytes if truncated else size)
    try:
        text = data.decode("utf-8", errors="replace")
    except Exception:
        text = data.decode(errors="replace")
    return text, truncated


def _read_head_lines(path: Path, head_lines: int) -> Tuple[str, bool]:
    lines: List[str] = []
    truncated = False
    try:
        with open(path, "r", encoding="utf-8", errors="replace") as f:
            for i, line in enumerate(f):
                if i >= head_lines:
                    truncated = True
                    break
                lines.append(line.rstrip("\n"))
    except Exception:
        # binary or unreadable
        return "[Unreadable]", True
    return "\n".join(lines), truncated


def _safe_unparse(node: ast.AST) -> str:
    try:
        return ast.unparse(node)  # type: ignore[attr-defined]
    except Exception:
        return "..."


def _format_args(args: ast.arguments) -> str:
    parts: List[str] = []

    def fmt_arg(a: ast.arg, default: Optional[ast.AST]) -> str:
        s = a.arg
        if a.annotation is not None:
            s += f": {_safe_unparse(a.annotation)}"
        if default is not None:
            d = _safe_unparse(default)
            if len(d) > 40:
                d = d[:37] + "..."
            s += f"={d}"
        return s

    # Positional-only
    posonly = getattr(args, "posonlyargs", [])
    if posonly:
        defaults_pad = [None] * (len(posonly) + len(args.args) - len(args.defaults)) + list(args.defaults)
        for a, d in zip(posonly, defaults_pad[: len(posonly)]):
            parts.append(fmt_arg(a, d))
        parts.append("/")

    # Positional or keyword
    all_pos = list(args.args)
    defaults_pad = [None] * (len(posonly) + len(all_pos) - len(args.defaults)) + list(args.defaults)
    # defaults for args start after posonly
    for idx, a in enumerate(all_pos):
        d = defaults_pad[len(posonly) + idx]
        parts.append(fmt_arg(a, d))

    # vararg
    if args.vararg is not None:
        va = "*" + args.vararg.arg
        if args.vararg.annotation is not None:
            va += f": {_safe_unparse(args.vararg.annotation)}"
        parts.append(va)
    elif args.kwonlyargs:
        parts.append("*")

    # kw-only
    for a, d in zip(args.kwonlyargs, args.kw_defaults):
        parts.append(fmt_arg(a, d))

    # kwarg
    if args.kwarg is not None:
        ka = "**" + args.kwarg.arg
        if args.kwarg.annotation is not None:
            ka += f": {_safe_unparse(args.kwarg.annotation)}"
        parts.append(ka)

    return ", ".join(parts)


def _first_doc_line(doc: Optional[str], max_len: int = 120) -> str:
    if not doc:
        return ""
    line = doc.strip().splitlines()[0].strip()
    if len(line) > max_len:
        line = line[: max_len - 3] + "..."
    return line


def _extract_python_interface(path: Path, max_chars: int = 40000) -> str:
    src = path.read_text(encoding="utf-8", errors="replace")
    try:
        tree = ast.parse(src)
    except Exception as e:
        head, _ = _read_head_lines(path, 200)
        return f"# [Interface Extraction Failed]\n# {e}\n\n" + head

    out: List[str] = []
    mod_doc = ast.get_docstring(tree)
    if mod_doc:
        out.append('"""' + _first_doc_line(mod_doc) + '"""')
        out.append("")

    # Constants (simple Assign to ALLCAPS)
    consts: List[str] = []
    for node in tree.body:
        if isinstance(node, ast.Assign):
            for t in node.targets:
                if isinstance(t, ast.Name) and t.id.isupper():
                    try:
                        v = _safe_unparse(node.value)
                        if len(v) > 80:
                            v = v[:77] + "..."
                        consts.append(f"{t.id} = {v}")
                    except Exception:
                        consts.append(f"{t.id} = ...")
    if consts:
        out.append("# Constants")
        out.extend(consts[:40])
        if len(consts) > 40:
            out.append(f"# ... {len(consts)-40} more")
        out.append("")

    # Functions / Classes
    for node in tree.body:
        if isinstance(node, ast.FunctionDef):
            sig = _format_args(node.args)
            ret = f" -> {_safe_unparse(node.returns)}" if node.returns is not None else ""
            doc = _first_doc_line(ast.get_docstring(node))
            out.append(f"def {node.name}({sig}){ret}:")
            out.append(f"    \"\"\"{doc}\"\"\"" if doc else "    ...")
            out.append("")
        elif isinstance(node, ast.ClassDef):
            bases = [
                _safe_unparse(b)
                for b in node.bases
                if not (isinstance(b, ast.Name) and b.id == "object")
            ]
            base_s = f"({', '.join(bases)})" if bases else ""
            doc = _first_doc_line(ast.get_docstring(node))
            out.append(f"class {node.name}{base_s}:")
            out.append(f"    \"\"\"{doc}\"\"\"" if doc else "    ...")

            # Methods
            methods: List[str] = []
            for sub in node.body:
                if isinstance(sub, ast.FunctionDef):
                    if sub.name.startswith("__") and sub.name.endswith("__"):
                        continue
                    msig = _format_args(sub.args)
                    mret = f" -> {_safe_unparse(sub.returns)}" if sub.returns is not None else ""
                    mdoc = _first_doc_line(ast.get_docstring(sub))
                    line = f"    def {sub.name}({msig}){mret}:"
                    if mdoc:
                        line += f"  # {mdoc}"
                    methods.append(line)
            if methods:
                out.extend(methods[:60])
                if len(methods) > 60:
                    out.append(f"    # ... {len(methods)-60} more")
            out.append("")

    text = "\n".join(out).strip() + "\n"
    if len(text) > max_chars:
        return text[: max_chars - 200] + "\n\n# [TRUNCATED: interface too large]\n"
    return text


def _render_tree(root: Path, prefix: str, depth: int, max_depth: int, max_entries: int,
                 ignore_dirs: set[str], ignore_files: set[str], ignore_globs: List[str]) -> str:
    if depth > max_depth:
        return f"{prefix}â””â”€â”€ ... (max depth reached)\n"

    try:
        children = [p for p in sorted(root.iterdir(), key=lambda p: p.name.lower())]
    except PermissionError:
        return f"{prefix}â””â”€â”€ [Permission Denied]\n"

    # Filter ignored
    filtered: List[Path] = []
    for p in children:
        if p.name in ignore_dirs and p.is_dir():
            continue
        if p.name in ignore_files and p.is_file():
            continue
        rel = _posix_rel(p) if p.exists() else p.name
        if any(_match_glob(rel, pat) for pat in ignore_globs):
            continue
        filtered.append(p)

    omitted = 0
    if len(filtered) > max_entries:
        omitted = len(filtered) - max_entries
        filtered = filtered[:max_entries]

    lines: List[str] = []
    for i, p in enumerate(filtered):
        pointer = "â”œâ”€â”€ " if i < len(filtered) - 1 else "â””â”€â”€ "
        lines.append(f"{prefix}{pointer}{p.name}")
        if p.is_dir():
            extension = "â”‚   " if pointer == "â”œâ”€â”€ " else "    "
            sub = _render_tree(
                p,
                prefix=prefix + extension,
                depth=depth + 1,
                max_depth=max_depth,
                max_entries=max_entries,
                ignore_dirs=ignore_dirs,
                ignore_files=ignore_files,
                ignore_globs=ignore_globs,
            )
            lines.append(sub.rstrip("\n"))

    if omitted:
        lines.append(f"{prefix}â””â”€â”€ ... ({omitted} entries omitted)")

    return "\n".join(lines) + "\n"


def _extract_registry_tools() -> Optional[List[Dict[str, Any]]]:
    reg_path = PROJECT_ROOT / "src" / "registry.py"
    if not reg_path.exists():
        return None
    try:
        src = reg_path.read_text(encoding="utf-8", errors="replace")
        tree = ast.parse(src)
        for node in tree.body:
            if isinstance(node, ast.Assign):
                for t in node.targets:
                    if isinstance(t, ast.Name) and t.id == "TOOLS":
                        return ast.literal_eval(node.value)  # type: ignore[arg-type]
    except Exception:
        return None
    return None


def _render_tools_overview(tools: Optional[List[Dict[str, Any]]]) -> str:
    if not tools:
        return "(registry tools not available)"

    # Keep it simple to control size.
    headers = ["alias", "file", "type", "desc", "usage"]
    rows: List[List[str]] = []
    for t in tools:
        rows.append([
            str(t.get("alias") or ""),
            str(t.get("file") or ""),
            str(t.get("type") or ""),
            str(t.get("desc") or ""),
            str(t.get("usage") or ""),
        ])

    # Column widths
    widths = [len(h) for h in headers]
    for r in rows:
        for i, cell in enumerate(r):
            widths[i] = min(48, max(widths[i], len(cell)))

    def fmt_row(r: List[str]) -> str:
        out = []
        for i, cell in enumerate(r):
            s = cell.replace("\n", " ").strip()
            if len(s) > widths[i]:
                s = s[: widths[i] - 3] + "..."
            out.append(s.ljust(widths[i]))
        return " | ".join(out)

    lines = [fmt_row(headers), "-+-".join(["-" * w for w in widths])]
    lines.extend(fmt_row(r) for r in rows)
    return "\n".join(lines)


def _render_project_status() -> str:
    status_path = PROJECT_ROOT / "PROJECT_STATUS.json"
    if not status_path.exists():
        return "No project status file found."

    try:
        data = json.loads(status_path.read_text(encoding="utf-8"))
    except Exception:
        return "Error reading project status."

    lines: List[str] = []
    if data.get("guidelines"):
        lines.append("DEV MANIFESTO:")
        for rule in data["guidelines"]:
            lines.append(f"* {rule}")
        lines.append("-" * 20)

    lines.append(f"OBJECTIVE: {data.get('objective')}")

    tasks = data.get("tasks", [])
    if tasks:
        lines.append("\nTASKS:")
        for i, t in enumerate(tasks):
            mark = "[x]" if t.get("status") == "done" else "[ ]"
            lines.append(f"{i}. {mark} {t.get('desc')}")

    logs = data.get("logs", [])
    if logs:
        lines.append("\nRECENT LOGS:")
        for l in logs[-5:]:
            lines.append(f"- {l}")

    return "\n".join(lines)


def _render_file_inventory(records: List[FileRecord], limit: int = 500) -> str:
    # Inventory is useful for LLM context even if contents are truncated.
    headers = ["mode", "bytes", "sha256_12", "path"]

    rows: List[List[str]] = []
    for r in records[:limit]:
        rows.append([
            r.mode + ("*" if r.truncated else ""),
            str(r.size_bytes),
            r.sha256_12,
            r.rel_posix,
        ])
    if len(records) > limit:
        rows.append(["...", "", "", f"({len(records)-limit} more omitted)"])

    widths = [len(h) for h in headers]
    for row in rows:
        for i, cell in enumerate(row):
            widths[i] = min(80, max(widths[i], len(cell)))

    def fmt_row(row: List[str]) -> str:
        cells: List[str] = []
        for i, cell in enumerate(row):
            s = cell
            if len(s) > widths[i]:
                s = s[: widths[i] - 3] + "..."
            cells.append(s.ljust(widths[i]))
        return " | ".join(cells)

    lines = [fmt_row(headers), "-+-".join(["-" * w for w in widths])]
    lines.extend(fmt_row(r) for r in rows)
    return "\n".join(lines)


def _write_zip(zip_path: Path, records: List[FileRecord]) -> None:
    _ensure_parent(zip_path)
    with zipfile.ZipFile(zip_path, "w", compression=zipfile.ZIP_DEFLATED) as z:
        # Include a manifest
        manifest = {
            "generated": datetime.now().isoformat(timespec="seconds"),
            "project_root": str(PROJECT_ROOT),
            "files": [
                {
                    "path": r.rel_posix,
                    "mode": r.mode,
                    "size_bytes": r.size_bytes,
                    "sha256_12": r.sha256_12,
                }
                for r in records
                if r.mode != "skip"
            ],
        }
        z.writestr("manifest.json", json.dumps(manifest, ensure_ascii=False, indent=2))

        # Add raw files
        for r in records:
            if r.mode == "skip":
                continue
            # Only archive repo files (text), skip binaries defensively.
            if _is_probably_binary(r.abs_path):
                continue
            z.write(r.abs_path, arcname=r.rel_posix)


def main() -> None:
    parser = argparse.ArgumentParser(description="Wagstaff-Lab snapshot generator (core/archive/custom via templates).")
    parser.add_argument("--mode", choices=["core", "archive", "custom"], default="core")
    parser.add_argument("--template", help="Template name from conf/snapshot_templates.json")
    parser.add_argument("--config", default=str(DEFAULT_CONFIG), help="Path to snapshot template config JSON")
    parser.add_argument("--output", help="Override output path")
    parser.add_argument("--list-templates", action="store_true", help="List available templates and exit")
    parser.add_argument("--no-redact", action="store_true", help="Disable secret redaction")
    parser.add_argument("--zip", action="store_true", help="Force creating zip bundle when supported")

    args = parser.parse_args()

    cfg_path = Path(args.config)
    templates_doc = _load_templates(cfg_path)

    if args.list_templates:
        tpls = templates_doc.get("templates", {})
        print("Available templates:")
        for name, t in sorted(tpls.items(), key=lambda x: x[0]):
            print(f"- {name}: {t.get('desc', '')}")
        return

    tpl_name, tpl = _resolve_template(templates_doc, args.mode, args.template)

    ts = _now_ts()

    out_str = args.output or str(tpl.get("output", "project_context.txt"))
    out_str = out_str.replace("{timestamp}", ts)
    output_path = PROJECT_ROOT / out_str

    make_zip = bool(tpl.get("make_zip", False)) or bool(args.zip)
    zip_output = tpl.get("zip_output")
    zip_path: Optional[Path] = None
    if make_zip:
        if isinstance(zip_output, str) and zip_output:
            zip_path = PROJECT_ROOT / zip_output.replace("{timestamp}", ts)
        else:
            zip_path = output_path.with_suffix(".zip")

    # Template controls
    include_globs = list(tpl.get("include_globs") or [])
    ignore_files = set(tpl.get("ignore_files") or list(DEFAULT_IGNORE_FILES))
    ignore_globs = list(tpl.get("ignore_globs") or list(DEFAULT_IGNORE_GLOBS))

    # Optional reports toggle
    if not bool(tpl.get("include_reports", True)):
        ignore_globs.append("data/reports/**")

    redact_enabled = bool(tpl.get("redact", True)) and (not args.no_redact)

    max_file_bytes = int(tpl.get("max_file_bytes", 200000))
    max_total_bytes = int(tpl.get("max_total_bytes", 1200000))

    tree_cfg = tpl.get("tree") or {}
    tree_max_depth = int(tree_cfg.get("max_depth", 8))
    tree_max_entries = int(tree_cfg.get("max_entries_per_dir", 250))

    rules = list(tpl.get("rules") or [])

    print(f"ğŸ“¸ Generating snapshot: mode={args.mode}, template={tpl_name}, output={output_path}")

    # 1) Collect candidates
    candidates = _iter_candidates(include_globs)

    records: List[FileRecord] = []
    for p in candidates:
        if _should_ignore(p, ignore_files, ignore_globs, DEFAULT_IGNORE_DIRS):
            continue
        rel = _posix_rel(p)
        rule = _pick_rule(rel, rules)
        mode = str(rule.get("mode", "skip"))
        try:
            size = p.stat().st_size
        except Exception:
            continue
        sha = "-"
        try:
            # Hashing is useful, but avoid expensive work for skipped files.
            if mode != "skip":
                sha = _sha256_12(p)
        except Exception:
            sha = "Unknown"
        records.append(FileRecord(rel_posix=rel, abs_path=p, size_bytes=size, sha256_12=sha, mode=mode))

    # 2) Build report
    report: List[str] = []
    report.append("# Wagstaff-Lab Project Snapshot")
    report.append("")
    report.append(f"- Generated: {datetime.now().isoformat(timespec='seconds')}")
    report.append(f"- Mode: {args.mode}")
    report.append(f"- Template: {tpl_name}")

    report.append("\n## 1. Environment Diagnostics")
    report.append("```yaml")
    report.append(get_system_fingerprint())
    report.append("-" * 20)
    report.append(get_git_status())
    report.append("```")

    report.append("\n## 2. Project Overview")
    report.append("### 2.1 Toolbox (src/registry.py)")
    report.append("```text")
    report.append(_render_tools_overview(_extract_registry_tools()))
    report.append("```")

    report.append("\n### 2.2 Project Context (PROJECT_STATUS.json)")
    report.append("```text")
    report.append(_render_project_status())
    report.append("```")

    report.append("\n## 3. Project Structure")
    report.append("```text")
    report.append(
        _render_tree(
            PROJECT_ROOT,
            prefix="",
            depth=0,
            max_depth=tree_max_depth,
            max_entries=tree_max_entries,
            ignore_dirs=DEFAULT_IGNORE_DIRS,
            ignore_files=ignore_files,
            ignore_globs=ignore_globs,
        ).rstrip("\n")
    )
    report.append("```")

    report.append("\n## 4. File Inventory")
    report.append("(mode: full/interface/head/skip; '*' means truncated when rendered)\n")
    report.append("```text")
    report.append(_render_file_inventory(records, limit=700))
    report.append("```")

    report.append("\n## 5. File Contents")

    # 3) Emit contents within budget
    budget = max_total_bytes
    embedded_files = 0

    for rec in records:
        if rec.mode == "skip":
            continue

        if _is_probably_binary(rec.abs_path):
            rec.note = "[skipped: binary]"
            continue

        rule = _pick_rule(rec.rel_posix, rules)
        mode = rec.mode
        head_lines = int(rule.get("head_lines", 200))

        content = ""
        truncated = False

        if mode == "head":
            content, truncated = _read_head_lines(rec.abs_path, head_lines=head_lines)
        elif mode == "interface":
            if rec.abs_path.suffix.lower() == ".py":
                content = _extract_python_interface(rec.abs_path)
                truncated = False
            else:
                content, truncated = _read_head_lines(rec.abs_path, head_lines=head_lines)
        elif mode == "full":
            per_file = int(rule.get("max_file_bytes", max_file_bytes))
            content, truncated = _read_text_limited(rec.abs_path, max_bytes=per_file)
        else:
            continue

        if redact_enabled:
            content = _redact(content)

        # Rough byte count for budget
        render_blob = content.encode("utf-8", errors="replace")
        needed = len(render_blob)

        # Keep a small overhead for section headers
        needed += 200

        if budget - needed < 0:
            rec.note = "[omitted: total budget exceeded]"
            continue

        budget -= needed
        rec.rendered_bytes = needed
        rec.truncated = truncated
        embedded_files += 1

        report.append(f"\n### File: {rec.rel_posix}")
        report.append(f"- mode: {mode}")
        report.append(f"- size_bytes: {rec.size_bytes}")
        report.append(f"- sha256_12: {rec.sha256_12}")
        if truncated:
            report.append(f"- note: TRUNCATED")
        report.append("")

        # code fence lang
        lang = rec.abs_path.suffix.lstrip(".")
        if lang == "ini":
            lang = "toml"
        if mode == "interface":
            lang = "py"

        report.append(f"```{lang}")
        report.append(content.rstrip("\n"))
        report.append("```")

    report.append("\n## 6. Snapshot Stats")
    report.append("```yaml")
    report.append(f"total_candidates: {len(candidates)}")
    report.append(f"included_records: {len(records)}")
    report.append(f"embedded_files: {embedded_files}")
    report.append(f"max_total_bytes: {max_total_bytes}")
    report.append(f"bytes_remaining: {budget}")
    report.append("```")

    # 4) Write output
    _ensure_parent(output_path)
    output_path.write_text("\n".join(report) + "\n", encoding="utf-8")
    print(f"âœ… Snapshot written: {output_path}")

    # 5) Optional zip bundle
    if zip_path is not None:
        try:
            _write_zip(zip_path, records)
            print(f"âœ… Zip bundle written: {zip_path}")
        except Exception as e:
            print(f"âš ï¸  Zip bundle failed: {e}")


if __name__ == "__main__":
    main()
```

### File: snapshots/snapshot_full_20260113_091618.md
- mode: full
- size_bytes: 111587
- sha256_12: d0467b752cbe

```md
# Wagstaff-Lab Snapshot (full)

## Snapshot Meta
```yaml
mode: full
profile: full
generated: 2026-01-13T09:16:18+08:00
max_file_bytes: 300000
max_total_bytes: 8000000
redaction: on
```

## Environment
```yaml
Time: 2026-01-13T09:16:18+08:00
User: steam
Host: VM-8-2-ubuntu (Linux 6.8.0-49-generic)
Platform: Linux-6.8.0-49-generic-x86_64-with-glibc2.39
Python: 3.10.19 ($HOME/miniconda3/envs/dst_lab/bin/python3)
Conda Env: dst_lab
```

## Git Status
```yaml
Branch: main [DIRTY]
Commit: 336ed22
Message: Release v2.2: Registry-driven architecture, new SOPs, and documentation
Changes: modified=9, untracked=2
---
PROJECT_STATUS.json   |   21 +-
 bin/dst_tool.sh       |   81 +-
 devtools/installer.py |   18 +-
 devtools/pm.py        |   25 +-
 devtools/snapshot.py  | 1055 ++++++++++++++++++------
 project_context.txt   | 2146 +++++--------------------------------------------
 src/analyzer.py       |    2 +-
 src/registry.py       |   12 +-
 src/wiki.py           |    2 +-
 9 files changed, 1142 insertions(+), 2220 deletions(-)
```

## Project Structure
```text
â”œâ”€â”€ bin
â”‚   â”œâ”€â”€ boot.sh
â”‚   â”œâ”€â”€ dst_tool.sh
â”‚   â”œâ”€â”€ pm
â”‚   â”œâ”€â”€ wagstaff
â”‚   â””â”€â”€ Wagstaff-Lab
â”œâ”€â”€ conf
â”‚   â”œâ”€â”€ settings.ini
â”‚   â””â”€â”€ snapshot_profile.json
â”œâ”€â”€ data
â”‚   â””â”€â”€ reports
â”‚       â”œâ”€â”€ asset_registry.md
â”‚       â””â”€â”€ recipe_distribution.md
â”œâ”€â”€ devtools
â”‚   â”œâ”€â”€ installer.py
â”‚   â”œâ”€â”€ pm.py
â”‚   â”œâ”€â”€ reporter.py
â”‚   â””â”€â”€ snapshot.py
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ analyzer.py
â”‚   â”œâ”€â”€ doctor.py
â”‚   â”œâ”€â”€ engine.py
â”‚   â”œâ”€â”€ explorer.py
â”‚   â”œâ”€â”€ guide.py
â”‚   â”œâ”€â”€ registry.py
â”‚   â”œâ”€â”€ utils.py
â”‚   â””â”€â”€ wiki.py
â”œâ”€â”€ tests
â”‚   â””â”€â”€ test_recipes.py
â”œâ”€â”€ .gitignore
â”œâ”€â”€ PROJECT_STATUS.json
â”œâ”€â”€ README.md
â””â”€â”€ setup.sh
```

## Tool Registry (src/registry.py)
| alias | file | folder | type | usage | desc |
|---|---|---|---|---|---|
| - | guide.py | src | Core | Wagstaff-Lab | Wagstaff-Lab æ§åˆ¶å°ä¸»é¢æ¿ |
| doctor | doctor.py | src | Src | wagstaff doctor | ç¯å¢ƒé…ç½®ä¸ä¾èµ–å¥åº·æ£€æŸ¥ |
| wiki | wiki.py | src | Src | wagstaff wiki <item_code> | ç‰©å“/é…æ–¹/æ•°å€¼æŸ¥è¯¢ç™¾ç§‘ |
| exp | explorer.py | src | Src | wagstaff exp | æºç ç»“æ„æµè§ˆä¸æ·±åº¦åˆ†æ |
| pm | pm.py | devtools | Dev | pm [ui\|obj\|add\|done\|log] | é¡¹ç›®è¿›åº¦ä¸ä»»åŠ¡ç®¡ç† |
| report | reporter.py | devtools | Dev | wagstaff report [assets\|recipes\|all] | ç”Ÿæˆå…¨æœèµ„äº§/é…æ–¹åˆ†å¸ƒæŠ¥å‘Š |
| snap | snapshot.py | devtools | Dev | wagstaff snap [--mode core\|full\|custom] [--config conf/snapshot_profile.json] | ç”Ÿæˆé¡¹ç›®å…¨æ¯ä»£ç å¿«ç…§ |
| install | installer.py | devtools | Dev | python3 devtools/installer.py | ç¯å¢ƒæ³¨å†Œä¸å®‰è£…å‘å¯¼ |

## Internal Dependency Map (python)
- devtools/installer.py  ->  src/registry.py
- devtools/reporter.py  ->  src/engine.py
- src/engine.py  ->  src/analyzer.py
- src/engine.py  ->  src/utils.py
- src/explorer.py  ->  src/analyzer.py
- src/explorer.py  ->  src/engine.py
- src/guide.py  ->  src/registry.py
- src/wiki.py  ->  src/engine.py
- tests/test_recipes.py  ->  src/engine.py

## Project State (PROJECT_STATUS.json)
```text
DEV MANIFESTO:
* æ¶æ„åˆ†å±‚ï¼šEngineè´Ÿè´£åº•å±‚I/Oï¼ŒToolè´Ÿè´£äº¤äº’ï¼Œç¦æ­¢UIæ··å…¥åº•å±‚
* å•æ–‡ä»¶å¯ç”¨ï¼šè„šæœ¬å¿…é¡»åŸå­åŒ–ï¼Œèƒ½ç‹¬ç«‹è¿è¡Œï¼Œæ‹’ç»å¼ºè€¦åˆ
* è·¯å¾„è‡ªé€‚åº”ï¼šç¦æ­¢ç¡¬ç¼–ç ç»å¯¹è·¯å¾„ï¼Œå¿…é¡»é€šè¿‡ __file__ åŠ¨æ€å®šä½
* æ•°æ®æŒä¹…åŒ–ï¼šæ‰«æç»“æœå’Œæ—¥å¿—å¿…é¡»å†™å…¥æ–‡ä»¶ï¼Œä¸ä»…é™äºæ§åˆ¶å°è¾“å‡º
* ç¨³å¥é™çº§ï¼šä¼˜å…ˆZipè¯»å–ï¼Œå¤±è´¥åˆ™é™çº§Folder
--------------------
OBJECTIVE: Wagstaff Lab v2.0 æ¶æ„å‡çº§ä¸æƒ…æŠ¥æŒä¹…åŒ–

TASKS: (8/8 done)
1. [x] é‡æ„ Wiki å’Œ Explorer ä½¿ç”¨ Engine
2. [x] å®ç°æƒ…æŠ¥æ‰«æç»“æœä¿å­˜åˆ° data/reports/
3. [x] åˆ›å»º src/guide.py é¡¹ç›®æ¦‚å†µé¢æ¿
4. [x] åˆ›å»º devtools/installer.py å¹¶å°è£… bin/wagstaff å‘½ä»¤
5. [x] æ–‡æ¡£åŒ–ï¼šåœ¨ README.md ä¸­è®°å½•æ–°å·¥å…·æ¥å…¥ SOP
6. [x] é‡æ„å·¥å…·æ³¨å†Œé€»è¾‘ï¼šå¼•å…¥ src/registry.py å®ç°å•ä¸€æ•°æ®æº
7. [x] Hotfix(pm): ä¿®å¤ STATUS_FILE è·¯å¾„ä¾èµ–å¹¶å®ç°åŸå­åŒ–å†™å…¥ (.tmp -> rename)
8. [x] Hotfix(installer): ä¼˜åŒ– wagstaff åŒ…è£…è„šæœ¬ï¼Œä¿®å¤æ— å‚æŠ¥é”™å¹¶å¼•å…¥ exec è¿›ç¨‹æ›¿æ¢

RECENT LOGS:
* [2026-01-12 23:33] 
* [2026-01-12 23:33] test
* [2026-01-12 23:33] test
* [2026-01-12 23:33] 
* [2026-01-12 23:34] test
```

## Included Full Files

### File: bin/boot.sh
> size=2250B, sha256=524c5d2d4996
```bash
#!/bin/bash
# =========================================================
# Wagstaff-Lab Bootloader (å¯åŠ¨å¼•å¯¼ç¨‹åº)
# èŒè´£: è®¾ç½®ç¯å¢ƒåº“(LD_LIBRARY_PATH)å¹¶å¯åŠ¨ DST äºŒè¿›åˆ¶æ–‡ä»¶
# =========================================================

# --- 1. å®šä½é…ç½® ---
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
CONFIG_FILE="$PROJECT_ROOT/conf/settings.ini"

# --- 2. ç®€æ˜“é…ç½®è¯»å–å™¨ ---
read_config() {
    local section=$1
    local key=$2
    local val=$(awk -F ' = ' -v section="[$section]" -v key="$key" '
        $0 == section { in_section=1; next }
        /^\[/ { in_section=0 }
        in_section && $1 == key { print $2; exit }
    ' "$CONFIG_FILE")
    echo "${val/\~/$HOME}"
}

# --- 3. åŠ è½½æ ¸å¿ƒå˜é‡ ---
INSTALL_DIR=$(read_config "PATHS" "DST_ROOT")
CLUSTER_NAME=$(read_config "SERVER" "CLUSTER_NAME")

# --- 4. ç¯å¢ƒæ£€æŸ¥ ---
if [ -z "$INSTALL_DIR" ] || [ -z "$CLUSTER_NAME" ]; then
    echo "âŒ [Boot] é”™è¯¯: æ— æ³•è¯»å–é…ç½®ï¼Œè¯·æ£€æŸ¥ conf/settings.ini"
    exit 1
fi

BIN_DIR="$INSTALL_DIR/bin"

# --- 5. è®¾ç½®ä¾èµ–åº“ (å…³é”®æ­¥éª¤) ---
# è¿™æ˜¯è®© Linux èƒ½è¿è¡Œ DST çš„æ ¸å¿ƒé­”æ³•
export LD_LIBRARY_PATH="$BIN_DIR/lib32:$BIN_DIR:$LD_LIBRARY_PATH"

# --- 6. è¿›å…¥æ‰§è¡Œç›®å½• ---
# å¿…é¡»è¿›å…¥ bin ç›®å½•ï¼Œå¦åˆ™æ¸¸æˆæ‰¾ä¸åˆ° data
cd "$BIN_DIR" || { echo "âŒ [Boot] æ‰¾ä¸åˆ°ç›®å½•: $BIN_DIR"; exit 1; }

echo "âš¡ [Boot] æ­£åœ¨åˆå§‹åŒ– Wagstaff å¼•æ“..."
echo "   - æ¸¸æˆæ ¹ç›®å½•: $INSTALL_DIR"
echo "   - å­˜æ¡£ç°‡åç§°: $CLUSTER_NAME"

# --- 7. å¯åŠ¨è¿›ç¨‹ (Master) ---
# ä½¿ç”¨ -dmS è®©å®ƒåœ¨åå° Screen è¿è¡Œ
screen -dmS "DST_Master" ./dontstarve_dedicated_server_nullrenderer -console -cluster "$CLUSTER_NAME" -shard Master
echo "âœ… [Boot] åœ°é¢æœåŠ¡å™¨ (Master) å·²å¯åŠ¨"

# --- 8. å¯åŠ¨è¿›ç¨‹ (Caves) ---
# åªæœ‰å½“å­˜æ¡£ä¸­å­˜åœ¨ Caves æ–‡ä»¶å¤¹æ—¶æ‰å¯åŠ¨ï¼Œæˆ–è€…ä½ å¯ä»¥é€‰æ‹©å¼ºåˆ¶å¯åŠ¨
# è¿™é‡Œä¸ºäº†ç¨³å¦¥ï¼Œæˆ‘ä»¬ç›´æ¥å¯åŠ¨ï¼Œå¦‚æœæ²¡æ´ç©´é…ç½®æ¸¸æˆä¼šè‡ªåŠ¨åœæ­¢ Caves è¿›ç¨‹ï¼Œæ— ä¼¤å¤§é›…
screen -dmS "DST_Caves" ./dontstarve_dedicated_server_nullrenderer -console -cluster "$CLUSTER_NAME" -shard Caves
echo "âœ… [Boot] æ´ç©´æœåŠ¡å™¨ (Caves) å·²å¯åŠ¨"

echo "âœ¨ å¯åŠ¨åºåˆ—å®Œæˆã€‚"
```

### File: bin/dst_tool.sh
> size=12532B, sha256=a626b7bec4b0
```bash
#!/bin/bash

# =========================================================
# Wagstaff-Lab Control Center v6.1
# æ¨¡å—åŒ– DST æœåŠ¡å™¨ç®¡ç†è„šæœ¬
# =========================================================

# --- 1. ç¯å¢ƒåˆå§‹åŒ– ---

# è·å–è„šæœ¬æ‰€åœ¨ç›®å½•çš„ç»å¯¹è·¯å¾„ (bin/)
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
# å®šä½é¡¹ç›®æ ¹ç›®å½• (Wagstaff-Lab/)
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
# é…ç½®æ–‡ä»¶è·¯å¾„
CONFIG_FILE="$PROJECT_ROOT/conf/settings.ini"

# --- 2. é…ç½®è¯»å–å‡½æ•° (INI Parser) ---
# ç”¨é€”ï¼šä» settings.ini è¯»å–å˜é‡ï¼Œå¹¶è‡ªåŠ¨å°† ~ æ›¿æ¢ä¸º $HOME
read_config() {
    local section=$1
    local key=$2
    local val=$(awk -F ' = ' -v section="[$section]" -v key="$key" '
        $0 == section { in_section=1; next }
        /^\[/ { in_section=0 }
        in_section && $1 == key { print $2; exit }
    ' "$CONFIG_FILE")
    
    # æ›¿æ¢ ~ ä¸ºå½“å‰ç”¨æˆ· Home ç›®å½•
    echo "${val/\~/$HOME}"
}

# --- 3. åŠ è½½å˜é‡ ---
if [ ! -f "$CONFIG_FILE" ]; then
    echo "âŒ é”™è¯¯: æ‰¾ä¸åˆ°é…ç½®æ–‡ä»¶ $CONFIG_FILE"
    exit 1
fi

DST_DIR=$(read_config "PATHS" "DST_ROOT")
STEAMCMD_DIR=$(read_config "PATHS" "STEAMCMD_DIR")
BACKUP_REPO=$(read_config "PATHS" "BACKUP_DIR")
CLUSTER_NAME=$(read_config "SERVER" "CLUSTER_NAME")
KLEI_HOME=$(read_config "SERVER" "KLEI_HOME")

# [å…³é”®ä¿®æ”¹] å¯åŠ¨è„šæœ¬æŒ‡å‘åŒç›®å½•ä¸‹çš„ boot.sh
START_SCRIPT="$SCRIPT_DIR/boot.sh"

# æ—¥å¿—è·¯å¾„
LOG_MASTER="$KLEI_HOME/$CLUSTER_NAME/Master/server_log.txt"
LOG_CAVES="$KLEI_HOME/$CLUSTER_NAME/Caves/server_log.txt"

# å¯»æ‰¾ Conda Python ç¯å¢ƒ (ä¼˜å…ˆæ‰¾ dst_lab)
PYTHON_EXEC="$HOME/miniconda3/envs/dst_lab/bin/python"
if [ ! -f "$PYTHON_EXEC" ]; then
    # å¤‡ç”¨ï¼šå°è¯•ç³»ç»Ÿ python3
    PYTHON_EXEC=$(which python3)
fi

# ç¡®ä¿å¤‡ä»½ç›®å½•å­˜åœ¨
mkdir -p "$BACKUP_REPO"

# --- é¢œè‰²å®šä¹‰ ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
NC='\033[0m' # No Color

trap 'echo -e "\n${YELLOW}>> è¿”å›ä¸»èœå•...${NC}"; sleep 0.5' SIGINT

# ================= è¾…åŠ©å‡½æ•° =================

print_line() { echo -e "${CYAN}----------------------------------------${NC}"; }
pause() { echo -e "\n${WHITE}æŒ‰å›è½¦é”®ç»§ç»­...${NC}"; read -r; }

# [Security] è§£æç»å¯¹è·¯å¾„ï¼ˆä¼˜å…ˆ realpathï¼Œç¼ºå¤±åˆ™ç”¨ python3ï¼‰
resolve_path() {
    local p="$1"
    if command -v realpath >/dev/null 2>&1; then
        realpath -m "$p"
        return $?
    fi
    python3 - "$p" <<'PY'
import os, sys
try:
    print(os.path.realpath(os.path.expanduser(sys.argv[1])))
except:
    sys.exit(1)
PY
}

# [Security] é«˜å±åˆ é™¤ï¼šä»…å…è®¸åˆ é™¤ KLEI_HOME/CLUSTER_NAME ä¸”åšäºŒæ¬¡ç¡®è®¤
safe_delete_cluster_dir() {
    local base="$KLEI_HOME"
    local cluster="$CLUSTER_NAME"
    local target="$base/$cluster"

    if [ -z "$base" ] || [ -z "$cluster" ]; then
        echo -e "${RED}âŒ KLEI_HOME æˆ– CLUSTER_NAME ä¸ºç©ºï¼Œæ‹’ç»åˆ é™¤${NC}"
        return 1
    fi

    local base_real target_real
    base_real="$(resolve_path "$base")" || return 1
    target_real="$(resolve_path "$target")" || return 1

    # æŠ¤æ 1: ç›®æ ‡ä¸èƒ½æ˜¯ /ã€HOMEã€KLEI_HOME æœ¬èº«
    if [ "$target_real" = "/" ] || [ "$target_real" = "$HOME" ] || [ "$target_real" = "$base_real" ]; then
        echo -e "${RED}âŒ ç›®æ ‡è·¯å¾„å¼‚å¸¸ (ç³»ç»Ÿç›®å½•ä¿æŠ¤)ï¼Œæ‹’ç»åˆ é™¤: $target_real${NC}"
        return 1
    fi

    # æŠ¤æ 2: ç›®æ ‡å¿…é¡»ä¸¥æ ¼ä½äº KLEI_HOME ç›®å½•æ ‘ä¸‹
    case "$target_real" in
        "$base_real"/*) ;;
        *)
            echo -e "${RED}âŒ ç›®æ ‡ä¸åœ¨ KLEI_HOME ä¸‹ (è¶Šæƒä¿æŠ¤)ï¼Œæ‹’ç»åˆ é™¤${NC}"
            echo -e "   KLEI_HOME: $base_real"
            echo -e "   TARGET:    $target_real"
            return 1
            ;;
    esac

    if [ ! -d "$target_real" ]; then
        echo -e "${RED}âŒ å­˜æ¡£ç›®å½•ä¸å­˜åœ¨: $target_real${NC}"
        return 1
    fi

    echo -e "${YELLOW}ğŸ§¹ è­¦å‘Šï¼šå³å°†å½»åº•åˆ é™¤æ—§å­˜æ¡£ç›®å½•:${NC}"
    echo -e "${RED}   $target_real${NC}"
    
    # æŠ¤æ 3: ä¸¥æ ¼æ–‡æœ¬ç¡®è®¤
    read -p "è¯·è¾“å…¥ä»¥ä¸‹å†…å®¹ç¡®è®¤åˆ é™¤: DELETE $target_real : " confirm_del
    if [ "$confirm_del" != "DELETE $target_real" ]; then
        echo -e "${YELLOW}ğŸš« è¾“å…¥ä¸åŒ¹é…ï¼Œå·²å–æ¶ˆåˆ é™¤æ“ä½œ${NC}"
        return 1
    fi

    echo -e "${RED}ğŸ”¥ æ­£åœ¨æ‰§è¡Œé”€æ¯...${NC}"
    rm -rf -- "$target_real"
    return 0
}


check_status() {
    local master_status="${RED}ğŸ”´ æœªè¿è¡Œ${NC}"
    local caves_status="${RED}ğŸ”´ æœªè¿è¡Œ${NC}"
    if screen -ls | grep -q "DST_Master"; then master_status="${GREEN}ğŸŸ¢ è¿è¡Œä¸­${NC}"; fi
    if screen -ls | grep -q "DST_Caves"; then caves_status="${GREEN}ğŸŸ¢ è¿è¡Œä¸­${NC}"; fi
    echo -e "   åœ°é¢: $master_status    æ´ç©´: $caves_status"
}

# æŸ¥çœ‹æ—¥å¿—å‡½æ•°
view_log() {
    local logfile="$1"; local name="$2"
    if [ -f "$logfile" ]; then
        echo -e "${CYAN}ğŸ“º ç›‘è§† $name æ—¥å¿— (Ctrl+C é€€å‡º)${NC}"
        tail -f "$logfile"
    else
        echo -e "${RED}âŒ æ— æ—¥å¿—æ–‡ä»¶: $logfile${NC}"; pause
    fi
}

# å‘é€æŒ‡ä»¤çš„æ ¸å¿ƒå‡½æ•°
send_cmd_to_master() {
    local cmd="$1"
    local desc="$2"
    if ! screen -ls | grep -q "DST_Master"; then
        echo -e "${RED}âŒ åœ°é¢æœæœªè¿è¡Œ${NC}"; pause; return
    fi
    echo -e "${BLUE}ğŸ“¡ $desc${NC}"
    screen -S "DST_Master" -p 0 -X eval "stuff \"$cmd\015\""
    echo -e "${YELLOW}â³ æŒ‡ä»¤å·²å‘é€${NC}"; sleep 1
}

# ================= æ ¸å¿ƒåŠŸèƒ½æ¨¡å— =================

start_server() {
    print_line
    if screen -ls | grep -q "DST_Master"; then
        echo -e "${YELLOW}âš ï¸  æœåŠ¡å™¨å·²åœ¨è¿è¡Œï¼${NC}"; pause; return
    fi
    echo -e "${GREEN}ğŸš€ è°ƒç”¨å¯åŠ¨å¼•å¯¼ç¨‹åº (Bootloader)...${NC}"
    
    # æ£€æŸ¥å¯åŠ¨è„šæœ¬æ˜¯å¦å­˜åœ¨
    if [ -f "$START_SCRIPT" ]; then
        # æ‰§è¡Œ boot.sh
        "$START_SCRIPT"
    else
        echo -e "${RED}âŒ æ‰¾ä¸åˆ°å¯åŠ¨å™¨: $START_SCRIPT${NC}"
        echo "è¯·æ£€æŸ¥ bin/boot.sh æ˜¯å¦å­˜åœ¨ã€‚"
    fi
    pause
}

graceful_stop() {
    print_line
    echo -e "${YELLOW}ğŸ›‘ å‘é€åœæœä¿¡å·...${NC}"
    if ! screen -ls | grep -qE "DST_Master|DST_Caves"; then
        echo -e "${RED}âš ï¸  æœåŠ¡å™¨æœªè¿è¡Œ${NC}"; pause; return
    fi

    # å‘é€å…³é—­æŒ‡ä»¤
    for target in "DST_Master" "DST_Caves"; do
        if screen -list | grep -q "$target"; then
            screen -S "$target" -p 0 -X eval 'stuff "c_shutdown(true)\015"'
        fi
    done

    echo -e "${BLUE}â³ ç­‰å¾…å­˜æ¡£ä¿å­˜ (æœ€å¤š40ç§’)...${NC}"
    for ((i=1; i<=40; i++)); do
        if ! screen -list | grep -qE "DST_Master|DST_Caves"; then
            echo -e "\n${GREEN}âœ… æœåŠ¡å™¨å·²å…³é—­${NC}"; pause; return
        fi
        if tail -n 10 "$LOG_MASTER" 2>/dev/null | grep -q "Shutting down"; then
            echo -e "\n${GREEN}âœ… ç›‘æµ‹åˆ°å…³æœºä¿¡å·${NC}"; break
        fi
        echo -n "."; sleep 0.5
    done
    
    # æ¸…ç†æ®‹ä½™è¿›ç¨‹
    screen -list | grep -E "DST_Master|DST_Caves" | cut -d. -f1 | xargs -r -I{} screen -S {} -X quit
    echo -e "\n${GREEN}âœ… è¿›ç¨‹å·²ç»ˆæ­¢${NC}"; pause
}

restart_server() {
    print_line
    if screen -ls | grep -qE "DST_Master|DST_Caves"; then
        original_pause_def="$(declare -f pause)"; pause() { :; } 
        graceful_stop
        eval "$original_pause_def"
    fi
    read -p "æ˜¯å¦é¡ºä¾¿æ›´æ–°æ¸¸æˆ? (y/n): " up_c
    if [[ "$up_c" == "y" ]]; then update_game; fi
    start_server
}

update_game() {
    print_line
    echo -e "${BLUE}â¬‡ï¸  è°ƒç”¨ SteamCMD æ›´æ–°...${NC}"
    "$STEAMCMD_DIR/steamcmd.sh" +force_install_dir "$DST_DIR" +login anonymous +app_update 343050 validate +quit
    echo -e "${GREEN}âœ… æ›´æ–°å®Œæˆ${NC}"; pause
}

# --- å¤‡ä»½/æ¢å¤ç³»ç»Ÿ ---
create_backup() {
    print_line
    local ts=$(date +"%Y%m%d_%H%M%S")
    if [ ! -d "$KLEI_HOME/$CLUSTER_NAME" ]; then echo -e "${RED}âŒ å­˜æ¡£ä¸å­˜åœ¨: $KLEI_HOME/$CLUSTER_NAME${NC}"; pause; return; fi
    
    echo -e "${CYAN}ğŸ’¾ æ‰“åŒ…å­˜æ¡£: $CLUSTER_NAME ...${NC}"
    tar -zcf "$BACKUP_REPO/backup_${ts}.tar.gz" -C "$KLEI_HOME" "$CLUSTER_NAME"
    echo -e "${GREEN}âœ… å¤‡ä»½å·²åˆ›å»º: backup_${ts}.tar.gz${NC}"; pause
}

restore_backup() {
    print_line
    files=($(ls -1t "$BACKUP_REPO"/*.tar.gz 2>/dev/null))
    if [ ${#files[@]} -eq 0 ]; then echo -e "${RED}âŒ å¤‡ä»½åº“ä¸ºç©º${NC}"; pause; return; fi

    echo -e "${CYAN}ğŸ“‚ æœ€è¿‘å¤‡ä»½:${NC}"
    i=0
    for file in "${files[@]}"; do
        echo -e " [$i] $(basename "$file")"
        ((i++)); if [ $i -ge 10 ]; then break; fi
    done
    
    read -p "é€‰æ‹©åºå· (qé€€å‡º): " c
    if [[ "$c" == "q" ]]; then return; fi
    if ! [[ "$c" =~ ^[0-9]+$ ]] || [ "$c" -ge "$i" ]; then echo "âŒ æ— æ•ˆ"; pause; return; fi

    read -p "âš ï¸  é«˜å±æ“ä½œ: ç¡®è®¤è¦†ç›–å½“å‰å­˜æ¡£? (YES/n): " confirm
    if [[ "$confirm" != "YES" ]]; then return; fi

    # è‡ªåŠ¨åœæœ
    if screen -ls | grep -qE "DST_Master|DST_Caves"; then
        original_pause_def="$(declare -f pause)"; pause() { :; } 
        graceful_stop
        eval "$original_pause_def"
    fi

    echo -e "${YELLOW}ğŸ§¹ å‡†å¤‡æ¸…ç†æ—§å­˜æ¡£...${NC}"
    if ! safe_delete_cluster_dir; then
        echo -e "${RED}âŒ åˆ é™¤æ­¥éª¤å¤±è´¥æˆ–è¢«å–æ¶ˆï¼Œå·²ä¸­æ­¢å›æ¡£æµç¨‹${NC}"
        pause
        return
    fi
    echo -e "${BLUE}ğŸ“¦ è§£å‹å¤‡ä»½...${NC}"
    tar -zxf "${files[$c]}" -C "$KLEI_HOME"
    echo -e "${GREEN}âœ… å›æ¡£æˆåŠŸ${NC}"
    read -p "ç«‹å³å¯åŠ¨? (y/n): " sn
    if [[ "$sn" == "y" ]]; then start_server; else pause; fi
}

# --- Wagstaff å·¥å…·ç®±é›†æˆ ---
run_explorer() {
    local script_path="$PROJECT_ROOT/src/explorer.py"
    if [ -f "$script_path" ]; then
        "$PYTHON_EXEC" "$script_path"
    else
        echo -e "${RED}âŒ æ‰¾ä¸åˆ°å·¥å…·è„šæœ¬: $script_path${NC}"
        pause
    fi
}

run_wiki() {
    local script_path="$PROJECT_ROOT/src/wiki.py"
    if [ ! -f "$script_path" ]; then
        echo -e "${RED}âŒ æ‰¾ä¸åˆ° Wiki è„šæœ¬: $script_path${NC}"; pause; return
    fi

    echo -e "${CYAN}ğŸ“š è¯·è¾“å…¥ç‰©å“ä»£ç è¿›è¡ŒæŸ¥è¯¢ (ä¾‹å¦‚ spear, log, meat)${NC}"
    read -p "ç‰©å“ä»£ç : " item_code
    if [ -n "$item_code" ]; then
        "$PYTHON_EXEC" "$script_path" "$item_code"
    fi
    pause
}
console_menu() {
    while true; do
        clear
        echo -e "   ğŸ® ${CYAN}æ§åˆ¶å°æŒ‡ä»¤ä¸­å¿ƒ${NC} ğŸ®"
        check_status
        echo "--------------------------------"
        echo "1. ğŸ’¾ ç«‹å³ä¿å­˜ (c_save)"
        echo "2. âª å›æ»š1å¤© (c_rollback)"
        echo "3. ğŸ“¢ å‘é€å…¬å‘Š (c_announce)"
        echo "4. â˜ ï¸  é‡ç½®ä¸–ç•Œ (c_regenerateworld)"
        echo "5. ğŸ‘¥ åˆ—å‡ºç©å®¶"
        echo "0. ğŸ”™ è¿”å›"
        echo "--------------------------------"
        read -p "æŒ‡ä»¤: " cc
        case $cc in
            1) send_cmd_to_master "c_save()" "ç«‹å³ä¿å­˜" ;;
            2) send_cmd_to_master "c_rollback(1)" "å›æ»š1å¤©" ;;
            3) read -p "å†…å®¹: " m; send_cmd_to_master "c_announce(\"$m\")" "å…¬å‘Š" ;;
            4) read -p "è¾“å…¥ YES ç¡®è®¤é‡ç½®: " r; [[ "$r" == "YES" ]] && send_cmd_to_master "c_regenerateworld()" "é‡ç½®ä¸–ç•Œ" ;;
            5) send_cmd_to_master "c_listallplayers()" "ç©å®¶åˆ—è¡¨" ;;
            0) return ;;
        esac
    done
}

# ================= ä¸»å¾ªç¯ =================
while true; do
    clear
    echo "==========================================="
    echo -e " ğŸ¦… ${CYAN}Wagstaff-Lab æ§åˆ¶å° v6.1${NC} ğŸ¦…"
    echo "==========================================="
    check_status
    echo -e "${CYAN}--- è¿ç»´ç®¡ç† ---${NC}"
    echo "1. ğŸš€ å¯åŠ¨æœåŠ¡å™¨      2. ğŸ›‘ åœæ­¢æœåŠ¡å™¨"
    echo "3. ğŸ”„ é‡å¯æœåŠ¡å™¨      4. â¬‡ï¸  æ›´æ–°ç‰ˆæœ¬"
    echo -e "${CYAN}--- æ•°æ®ä¸å·¥å…· ---${NC}"
    echo "5. ğŸ’¾ åˆ›å»ºå¤‡ä»½        6. âª æ¢å¤å­˜æ¡£"
    echo "7. ğŸ“œ æŸ¥çœ‹æ—¥å¿—        8. ğŸ® å‘é€æŒ‡ä»¤"
    echo -e "9. ğŸ”¬ ${YELLOW}æºç é€è§†é•œ (Explorer)${NC}"
    echo -e "10.ğŸ“š ${GREEN}Wagstaff ç™¾ç§‘ (Wiki)${NC}"
    echo "0. ğŸšª é€€å‡º"
    echo "==========================================="
    
    read -p "é€‰é¡¹: " choice

    case $choice in
        1) start_server ;;
        2) graceful_stop ;;
        3) restart_server ;;
        4) update_game ;;
        5) create_backup ;;
        6) restore_backup ;;
        7) view_log "$LOG_MASTER" "Master" ;; 
        8) console_menu ;;
        9) run_explorer ;; 
	10) run_wiki ;;
        0) echo -e "${GREEN}å†è§ï¼Œç ”ç©¶å‘˜ã€‚${NC}"; exit 0 ;;
        *) echo "æ— æ•ˆ"; sleep 0.5 ;;
    esac
done
```

### File: conf/snapshot_profile.json
> size=693B, sha256=b57b53db44d5
```json
{
  "name": "llm-pack",
  "default_action": "omit",
  "full": [
    "src/**/*.py",
    "bin/boot.sh",
    "bin/dst_tool.sh",
    "conf/settings.ini",
    "PROJECT_STATUS.json",
    "README.md",
    "tests/**/*.py"
  ],
  "stub": [
    "devtools/**/*.py",
    "data/reports/**/*.md",
    "bin/wagstaff",
    "bin/pm",
    "bin/Wagstaff-Lab"
  ],
  "omit": [
    "snapshots/**",
    "project_context.txt"
  ],
  "options": {
    "max_file_bytes": 120000,
    "max_total_bytes": 900000,
    "inventory_limit": 250,
    "include_tree": true,
    "include_env": true,
    "include_git": true,
    "include_registry_summary": true,
    "include_import_graph": true,
    "include_status": true
  }
}
```

### File: data/reports/asset_registry.md
> size=2096B, sha256=45c762a51673
```markdown
# Wagstaff Asset Registry

| Category | Total Definitions | Top File |
|----------|-------------------|----------|
| Prefabs | 2381 | `scripts/prefabs/meats.lua` |
| Widgets | 2096 | `scripts/widgets/controls.lua` |
| LootTables | 183 | `scripts/prefabs/deciduoustrees.lua` |
| Brains | 103 | `scripts/prefabs/pigman.lua` |
| STRINGS | 45 | `scripts/strings.lua` |

## Detailed Breakdown

### Prefabs
- `scripts/prefabs/meats.lua`: 30
- `scripts/prefabs/boat.lua`: 19
- `scripts/prefabs/rocks.lua`: 13
- `scripts/prefabs/archive_props.lua`: 13
- `scripts/prefabs/explode_small.lua`: 10
- `scripts/prefabs/staff.lua`: 9
- `scripts/prefabs/planted_tree.lua`: 8
- `scripts/prefabs/hound.lua`: 8
- `scripts/prefabs/wagstaff_npc.lua`: 8
- `scripts/prefabs/spider.lua`: 8

### Widgets
- `scripts/widgets/controls.lua`: 35
- `scripts/screens/playerhud.lua`: 32
- `scripts/screens/lobbyscreen.lua`: 16
- `scripts/screens/multiplayermainscreen.lua`: 15
- `scripts/widgets/redux/templates.lua`: 14
- `scripts/widgets/statusdisplays.lua`: 14
- `scripts/screens/serverlistingscreen.lua`: 14
- `scripts/screens/redux/multiplayermainscreen.lua`: 14
- `scripts/screens/servercreationscreen.lua`: 14
- `scripts/screens/modconfigurationscreen.lua`: 13

### LootTables
- `scripts/prefabs/deciduoustrees.lua`: 7
- `scripts/prefabs/evergreens.lua`: 7
- `scripts/prefabs/moon_altar.lua`: 6
- `scripts/prefabs/farm_plants.lua`: 5
- `scripts/prefabs/merm.lua`: 4
- `scripts/prefabs/veggies.lua`: 4
- `scripts/prefabs/perdshrine.lua`: 4
- `scripts/prefabs/pigman.lua`: 4
- `scripts/prefabs/monkey.lua`: 4
- `scripts/prefabs/oceantree.lua`: 4

### Brains
- `scripts/prefabs/pigman.lua`: 4
- `scripts/prefabs/merm.lua`: 2
- `scripts/prefabs/wobster.lua`: 2
- `scripts/brains/wobysmallbrain.lua`: 2
- `scripts/prefabs/ghost.lua`: 2
- `scripts/prefabs/slurtle.lua`: 2
- `scripts/prefabs/spider.lua`: 2
- `scripts/prefabs/monkey.lua`: 2
- `scripts/brains/catcoonbrain.lua`: 1
- `scripts/brains/pigbrain.lua`: 1

### STRINGS
- `scripts/strings.lua`: 37
- `scripts/skin_strings.lua`: 7
- `scripts/strings_pretranslated.lua`: 1
```

### File: data/reports/recipe_distribution.md
> size=1655B, sha256=e177df3496c5
```markdown
# Wagstaff Recipe Distribution

## Function Usage
- **Recipe2**: 881
- **DeconstructRecipe**: 111
- **Recipe**: 56
- **DoRecipeClick**: 11
- **AddCookerRecipe**: 9
- **SetRecipeUnlocked**: 4
- **ClearAllUnlockedRecipes**: 3
- **UpdateRecipes**: 2
- **OnRecipeDirty**: 2
- **SetRecipe**: 2
- **SetupRecipeIngredientDetails**: 1
- **AddRecipeCard**: 1
- **TestRecipes**: 1
- **RemoveAllRecipes**: 1
- **CanBlueprintRandomRecipe**: 1
- **CleanupDupRecipes**: 1
- **IsRecipeValidForFilter**: 1
- **IsRecipeValidForStation**: 1
- **DeclareLimitedCraftingRecipe**: 1
- **ShouldHintRecipe**: 1
- **PickRandomRecipe**: 1

## File Hotspots (Top 20)
- `scripts/recipes.lua`: 997 recipes
- `scripts/prefabs/quagmire.lua`: 52 recipes
- `scripts/cooking.lua`: 10 recipes
- `scripts/prefabs/hermithouse.lua`: 7 recipes
- `scripts/widgets/redux/craftingmenu_widget.lua`: 3 recipes
- `scripts/prefabs/cookingrecipecard.lua`: 3 recipes
- `scripts/prefabs/hermitcrab_teashop.lua`: 2 recipes
- `scripts/widgets/recipepopup.lua`: 2 recipes
- `scripts/widgets/redux/craftingmenu_pinslot.lua`: 2 recipes
- `scripts/widgets/redux/quagmire_recipebook.lua`: 1 recipes
- `scripts/widgets/controllercrafting_singletab.lua`: 1 recipes
- `scripts/components/quagmire_recipeprices.lua`: 1 recipes
- `scripts/modutil.lua`: 1 recipes
- `scripts/widgets/ingredientui.lua`: 1 recipes
- `scripts/components/quagmire_recipebook.lua`: 1 recipes
- `scripts/prefabs/blueprint.lua`: 1 recipes
- `scripts/widgets/controllercrafting.lua`: 1 recipes
- `scripts/widgets/craftslot.lua`: 1 recipes
- `scripts/quagmire_recipebook.lua`: 1 recipes
- `scripts/widgets/quagmire_recipepopup.lua`: 1 recipes
```

### File: devtools/installer.py
> size=3586B, sha256=b1feb4cd296f
```python
#!/usr/bin/env python3
import os
import sys
from pathlib import Path
from rich.console import Console

# å¼•å…¥æ³¨å†Œè¡¨
sys.path.append(os.path.join(os.path.dirname(__file__), "../src"))
from registry import get_tools

console = Console()

CURRENT_FILE = Path(__file__).resolve()
PROJECT_ROOT = CURRENT_FILE.parent.parent
BIN_DIR = PROJECT_ROOT / "bin"
SRC_DIR = PROJECT_ROOT / "src"
DEV_DIR = PROJECT_ROOT / "devtools"

def get_shell_config():
    home = Path.home()
    shell = os.environ.get("SHELL", "")
    if "zsh" in shell: return home / ".zshrc"
    elif "bash" in shell: return home / ".bashrc"
    else: return home / ".profile"

def create_wrappers():
    # 1. åˆ›å»º 'Wagstaff-Lab' ä¸»å…¥å£
    main_wrapper = BIN_DIR / "Wagstaff-Lab"
    with open(main_wrapper, 'w') as f:
        f.write('#!/bin/bash\n')
        f.write(f'python3 "{SRC_DIR}/guide.py" "$@"\n')
    os.chmod(main_wrapper, 0o755)
    
    # 2. åˆ›å»º 'pm' å¿«æ·æŒ‡ä»¤
    pm_wrapper = BIN_DIR / "pm"
    with open(pm_wrapper, 'w') as f:
        f.write('#!/bin/bash\n')
        f.write(f'python3 "{DEV_DIR}/pm.py" "$@"\n')
    os.chmod(pm_wrapper, 0o755)

    # 3. åŠ¨æ€åˆ›å»º 'wagstaff' å·¥å…·ç®± (åŸºäº Registry)
    ws_wrapper = BIN_DIR / "wagstaff"
    with open(ws_wrapper, 'w') as f:
        f.write('#!/bin/bash\n')
        
        # [ä¿®å¤é€»è¾‘] æ›´åŠ ç¨³å¥çš„å‚æ•°å¤„ç†
        # 1. è·å–ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä¸ºç©ºå­—ç¬¦ä¸² (é˜²æ­¢ unbound variable æŠ¥é”™)
        f.write('TOOL="${1:-}"\n')
        
        # 2. å¦‚æœå‚æ•°ä¸ºç©ºï¼Œç›´æ¥è½¬äº¤æ§åˆ¶æƒç»™ä¸»é¢æ¿ (exec æ›¿æ¢è¿›ç¨‹)
        f.write('if [ -z "$TOOL" ]; then\n')
        f.write(f'  exec "{main_wrapper}" "$@"\n')
        f.write('fi\n')
        
        # 3. åªæœ‰åœ¨æœ‰å‚æ•°æ—¶æ‰ shift
        f.write('shift\n')
        
        f.write('case "$TOOL" in\n')
        
        # --- åŠ¨æ€ç”Ÿæˆ Case åˆ†æ”¯ ---
        tools = get_tools()
        registered_aliases = []
        
        for tool in tools:
            alias = tool.get('alias')
            if not alias: continue # è·³è¿‡æ²¡æœ‰åˆ«åçš„å·¥å…·
            
            folder = tool.get('folder', 'src')
            if folder == 'src': abs_path = SRC_DIR
            elif folder == 'devtools': abs_path = DEV_DIR
            else: abs_path = PROJECT_ROOT / folder
            
            f.write(f'  {alias}) python3 "{abs_path}/{tool["file"]}" "$@" ;;\n')
            registered_aliases.append(f"{alias} ({tool['desc']})")
        # ------------------------

        # é»˜è®¤æƒ…å†µä¹Ÿè½¬äº¤ç»™ä¸»é¢æ¿
        f.write(f'  *) exec "{main_wrapper}" "$@" ;;\n') 
        f.write('esac\n')
    os.chmod(ws_wrapper, 0o755)
    
    console.print(f"[green]âœ… æŒ‡ä»¤æ³¨å†ŒæˆåŠŸ (Registry Driven)[/green]")
    console.print(f"   å·²è‡ªåŠ¨æ³¨å†Œ {len(registered_aliases)} ä¸ªå­å‘½ä»¤åˆ° 'wagstaff'")

def register_to_path():
    rc_file = get_shell_config()
    bin_path_str = str(BIN_DIR)
    
    if not rc_file.exists(): return

    content = rc_file.read_text()
    if f'export PATH="{bin_path_str}:$PATH"' in content:
        console.print("[dim]âš¡ ç¯å¢ƒå˜é‡å·²å°±ç»ª[/dim]")
    else:
        try:
            with open(rc_file, 'a') as f:
                f.write(f'\n# Wagstaff-Lab Environment\nexport PATH="{bin_path_str}:$PATH"\n')
            console.print(f"[green]âœ… PATH å·²æ›´æ–°[/green]")
        except Exception:
            pass

def main():
    console.print("[bold blue]ğŸ”§ Wagstaff-Lab è‡ªåŠ¨åŒ–æ³¨å†Œä¸­å¿ƒ[/bold blue]")
    create_wrappers()
    register_to_path()

if __name__ == "__main__":
    main()
```

### File: devtools/pm.py
> size=4956B, sha256=21cc6d8ef466
```python
#!/usr/bin/env python3
import os
import json
import sys
from pathlib import Path
from datetime import datetime
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.prompt import Prompt, IntPrompt

console = Console()

# [ä¿®å¤] é”å®šç»å¯¹è·¯å¾„ï¼Œä¸å†ä¾èµ–å½“å‰å·¥ä½œç›®å½•
PROJECT_ROOT = Path(__file__).resolve().parent.parent
STATUS_FILE = PROJECT_ROOT / "PROJECT_STATUS.json"

class ProjectManager:
    def __init__(self):
        self.data = self._load()

    def _load(self):
        # [ä¼˜åŒ–] ä½¿ç”¨ Path å¯¹è±¡æ£€æŸ¥æ–‡ä»¶
        if STATUS_FILE.exists():
            with open(STATUS_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        return {"objective": "Unset", "tasks": [], "logs": [], "guidelines": []}

    def _save(self):
        # [ä¼˜åŒ–] åŸå­å†™å…¥ï¼šå…ˆå†™ .tmp å†é‡å‘½åï¼Œé˜²æ­¢æ•°æ®æŸå
        tmp = STATUS_FILE.with_name(STATUS_FILE.name + ".tmp")
        with open(tmp, 'w', encoding='utf-8') as f:
            json.dump(self.data, f, indent=2, ensure_ascii=False)
        tmp.replace(STATUS_FILE)

    def set_objective(self, obj):
        self.data["objective"] = obj
        self._save()
        console.print(f"[green]âœ… ç›®æ ‡æ›´æ–°:[/green] {obj}")

    def add_task(self, task):
        self.data["tasks"].append({"desc": task, "status": "todo", "time": str(datetime.now())})
        self._save()
        console.print(f"[green]âœ… ä»»åŠ¡+1:[/green] {task}")
    
    def add_rule(self, rule):
        if "guidelines" not in self.data: self.data["guidelines"] = []
        self.data["guidelines"].append(rule)
        self._save()
        console.print(f"[bold magenta]ğŸ“œ å®—æ—¨å½•å…¥:[/bold magenta] {rule}")

    def complete_task(self, index):
        if 0 <= index < len(self.data["tasks"]):
            self.data["tasks"][index]["status"] = "done"
            self._save()
            console.print(f"[green]ğŸ‰ å®Œæˆ:[/green] {self.data['tasks'][index]['desc']}")
        else:
            console.print("[red]âŒ ç´¢å¼•æ— æ•ˆ[/red]")

    def log_entry(self, msg):
        self.data["logs"].append(f"[{datetime.now().strftime('%Y-%m-%d %H:%M')}] {msg}")
        if len(self.data["logs"]) > 10: self.data["logs"].pop(0)
        self._save()
        console.print("[green]ğŸ“ æ—¥å¿—å·²è®°å½•[/green]")

    def show_status(self):
        console.clear()
        console.print(Panel(f"[bold blue]ğŸ¯ ç›®æ ‡: {self.data.get('objective', 'Unset')}[/bold blue]"))
        
        t_table = Table(title="ä»»åŠ¡æ¸…å•", box=None)
        t_table.add_column("ID", style="dim"); t_table.add_column("çŠ¶æ€"); t_table.add_column("å†…å®¹")
        for i, t in enumerate(self.data["tasks"]):
            status = "âœ…" if t["status"] == "done" else "â¬œ"
            style = "dim strike" if t["status"] == "done" else "bold"
            t_table.add_row(str(i), status, f"[{style}]{t['desc']}[/{style}]")
        console.print(t_table)
        
        if self.data.get("logs"):
            console.print("\n[dim]ğŸ“œ æœ€è¿‘æ—¥å¿—:[/dim]")
            for l in self.data["logs"][-3:]:
                console.print(f"  {l}")

    def interactive_mode(self):
        while True:
            self.show_status()
            console.print("\n[bold cyan]æ“ä½œèœå•:[/bold cyan]")
            console.print("1. [green]âœ… å®Œæˆä»»åŠ¡[/]  2. [blue]â• æ–°å¢ä»»åŠ¡[/]  3. [magenta]ğŸ“ å†™æ—¥å¿—[/]  4. [yellow]ğŸ¯ æ”¹ç›®æ ‡[/]  0. [red]é€€å‡º[/]")
            
            choice = Prompt.ask("é€‰æ‹©æ“ä½œ", choices=["0", "1", "2", "3", "4"], default="0")
            
            if choice == "0": break
            elif choice == "1":
                idx = IntPrompt.ask("è¾“å…¥ä»»åŠ¡ID")
                self.complete_task(idx)
            elif choice == "2":
                desc = Prompt.ask("è¾“å…¥ä»»åŠ¡æè¿°")
                self.add_task(desc)
            elif choice == "3":
                log = Prompt.ask("è¾“å…¥æ—¥å¿—å†…å®¹")
                self.log_entry(log)
            elif choice == "4":
                obj = Prompt.ask("è¾“å…¥æ–°ç›®æ ‡")
                self.set_objective(obj)
            
            if choice != "0":
                input("\næŒ‰å›è½¦ç»§ç»­...")

def main():
    pm = ProjectManager()
    if len(sys.argv) > 1:
        cmd = sys.argv[1]
        content = " ".join(sys.argv[2:])
        
        if cmd == "obj": pm.set_objective(content)
        elif cmd == "add": pm.add_task(content)
        elif cmd == "rule": pm.add_rule(content)
        elif cmd == "done":
            # [ä¿®å¤] å¢åŠ å‚æ•°æ£€æŸ¥
            if len(sys.argv) < 3:
                console.print("[red]ç”¨æ³•: pm done <task_id>[/red]")
                return
            pm.complete_task(int(sys.argv[2]))
        elif cmd == "log": pm.log_entry(content)
        elif cmd == "ui": pm.interactive_mode()
        else: pm.show_status()
    else:
        pm.interactive_mode()

if __name__ == "__main__":
    main()
```

### File: devtools/reporter.py
> size=4763B, sha256=915b1577a0aa
```python
#!/usr/bin/env python3
import os
import sys
import re
from collections import Counter, defaultdict
from rich.console import Console
from rich.progress import track

# æŒ‚è½½ src å¹¶å¼•å…¥å¼•æ“
sys.path.append(os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "src"))
from engine import WagstaffEngine

console = Console()

# === [ä¿®å¤] åŠ¨æ€å®šä½é¡¹ç›®è·¯å¾„ ===
CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.dirname(CURRENT_DIR)
REPORT_DIR = os.path.join(PROJECT_ROOT, "data", "reports")

class WagstaffReporter:
    def __init__(self):
        # å¯åŠ¨å¼•æ“ï¼Œä¸éœ€è¦åŠ è½½æ•°æ®åº“(æˆ‘ä»¬åªåšæ­£åˆ™æ‰«æ)
        self.engine = WagstaffEngine(load_db=False, silent=True)
        self._ensure_report_dir()

    def _ensure_report_dir(self):
        if not os.path.exists(REPORT_DIR):
            os.makedirs(REPORT_DIR)
            console.print(f"[green]ğŸ“ åˆ›å»ºæŠ¥å‘Šç›®å½•: {REPORT_DIR}[/green]")

    def generate_asset_report(self):
        """æ‰«æå…¨æœèµ„äº§åˆ†å¸ƒ"""
        console.print("[bold blue]ğŸ“¡ æ­£åœ¨ç”Ÿæˆèµ„äº§åˆ†å¸ƒæŠ¥å‘Š...[/bold blue]")
        
        TARGETS = {
            "STRINGS": re.compile(r'STRINGS\.[A-Z0-9_]+\s*='),
            "Prefabs": re.compile(r'\bPrefab\s*\('),
            "LootTables": re.compile(r'\bSetLoot\s*\(|\bSetChanceLoot\s*\('),
            "Brains": re.compile(r'require\s*[\("\']brains/'),
            "Widgets": re.compile(r'require\s*[\("\']widgets/'),
        }
        
        stats = defaultdict(Counter)
        lua_files = [f for f in self.engine.file_list if f.endswith(".lua")]
        
        for fname in track(lua_files, description="Scanning Assets..."):
            content = self.engine.read_file(fname)
            if not content: continue
            clean = re.sub(r'--.*$', '', content, flags=re.MULTILINE)
            
            for cat, pattern in TARGETS.items():
                matches = pattern.findall(clean)
                if matches:
                    stats[cat][fname] += len(matches)

        out_path = os.path.join(REPORT_DIR, "asset_registry.md")
        with open(out_path, 'w', encoding='utf-8') as f:
            f.write("# Wagstaff Asset Registry\n\n")
            f.write("| Category | Total Definitions | Top File |\n")
            f.write("|----------|-------------------|----------|\n")
            for cat, file_counts in stats.items():
                total = sum(file_counts.values())
                top_file = file_counts.most_common(1)[0][0]
                f.write(f"| {cat} | {total} | `{top_file}` |\n")
            
            f.write("\n## Detailed Breakdown\n")
            for cat, file_counts in stats.items():
                f.write(f"\n### {cat}\n")
                for fname, count in file_counts.most_common(10):
                    f.write(f"- `{fname}`: {count}\n")
        console.print(f"[green]âœ… æŠ¥å‘Šå·²ä¿å­˜: {out_path}[/green]")

    def generate_recipe_report(self):
        """æ‰«æé…æ–¹åˆ†å¸ƒ"""
        console.print("[bold blue]ğŸ³ æ­£åœ¨ç”Ÿæˆé…æ–¹åˆ†å¸ƒæŠ¥å‘Š...[/bold blue]")
        
        pattern = re.compile(r'^\s*([a-zA-Z0-9_]*Recipe[a-zA-Z0-9_]*)\s*\(', re.MULTILINE)
        stats = Counter()
        file_stats = defaultdict(int)
        
        lua_files = [f for f in self.engine.file_list if f.endswith(".lua")]
        
        for fname in track(lua_files, description="Scanning Recipes..."):
            content = self.engine.read_file(fname)
            if not content: continue
            clean = re.sub(r'--.*$', '', content, flags=re.MULTILINE)
            
            matches = pattern.findall(clean)
            for m in matches:
                if "Get" in m or "Find" in m: continue
                stats[m] += 1
                file_stats[fname] += 1

        out_path = os.path.join(REPORT_DIR, "recipe_distribution.md")
        with open(out_path, 'w', encoding='utf-8') as f:
            f.write("# Wagstaff Recipe Distribution\n\n")
            f.write("## Function Usage\n")
            for func, count in stats.most_common():
                f.write(f"- **{func}**: {count}\n")
            f.write("\n## File Hotspots (Top 20)\n")
            for fname, count in sorted(file_stats.items(), key=lambda x:x[1], reverse=True)[:20]:
                f.write(f"- `{fname}`: {count} recipes\n")

        console.print(f"[green]âœ… æŠ¥å‘Šå·²ä¿å­˜: {out_path}[/green]")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python reporter.py [assets|recipes|all]")
        sys.exit(1)
    reporter = WagstaffReporter()
    cmd = sys.argv[1]
    if cmd == "assets" or cmd == "all": reporter.generate_asset_report()
    if cmd == "recipes" or cmd == "all": reporter.generate_recipe_report()
```

### File: devtools/snapshot.py
> size=35893B, sha256=c7a204308811
```python
#!/usr/bin/env python3
"""
Wagstaff-Lab Snapshot Generator (v4)

Goals:
- Make snapshots practical for LLM collaboration as the repo grows.
- Provide 3 modes:
  1) full   : archive-grade, include everything (bounded by limits)
  2) core   : LLM-grade, include core business code fully + overview + progress; summarize framework
  3) custom : user-defined export rules via JSON config + CLI overrides

Output is a single markdown-ish text file (safe to paste into LLMs).
"""

from __future__ import annotations

import argparse
import ast
import hashlib
import json
import os
import platform
import re
import subprocess
import sys
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path, PurePosixPath
from typing import Dict, Iterable, List, Optional, Sequence, Tuple


PROJECT_ROOT = Path(__file__).resolve().parent.parent
DEFAULT_CORE_OUTPUT = PROJECT_ROOT / "project_context.txt"
DEFAULT_SNAPSHOT_DIR = PROJECT_ROOT / "snapshots"

IGNORE_DIRS = {
    ".git",
    "__pycache__",
    ".pytest_cache",
    ".mypy_cache",
    ".ruff_cache",
    "logs",
    "env",
    "venv",
    ".venv",
    ".idea",
    ".vscode",
    "dist",
    "build",
    ".cache",
    "snapshots",  # prevent recursive growth from previous outputs
}

DEFAULT_IGNORE_FILES = {
    "project_context.txt",
    ".DS_Store",
    "id_rsa",
    "id_ed25519",
    "known_hosts",
}

DEFAULT_IGNORE_GLOBS: List[str] = [
    "**/*.swp",
    "**/*.swo",
    "**/*.tmp",
    "**/*.bak",
    "**/*.log",
    "**/*.zip",
    "**/*.tar",
    "**/*.tar.gz",
    "**/*.gz",
    "**/*.7z",
    "**/*.rar",
    "**/*.png",
    "**/*.jpg",
    "**/*.jpeg",
    "**/*.webp",
    "**/*.pdf",
    "**/*.mp4",
    "**/*.mov",
    "**/*.sqlite",
    "**/*.db",
    "**/.env",
    "**/.env.*",
    "**/*.pem",
    "**/*.key",
]

REDACT_KEYS = (
    "PASSWORD",
    "PASSWD",
    "PWD",
    "SECRET",
    "TOKEN",
    "API_KEY",
    "ACCESS_KEY",
    "PRIVATE_KEY",
    "OPENAI_API_KEY",
)

HOME_STR = str(Path.home())
ROOT_STR = str(PROJECT_ROOT)


@dataclass(frozen=True)
class ReadResult:
    text: str
    truncated: bool
    size_bytes: int
    sha256_12: str


@dataclass
class Profile:
    name: str
    default_action: str  # "full" | "stub" | "omit"
    full_globs: List[str]
    stub_globs: List[str]
    omit_globs: List[str]
    max_file_bytes: int
    max_total_bytes: int
    inventory_limit: int = 200
    include_tree: bool = True
    include_env: bool = True
    include_git: bool = True
    include_registry_summary: bool = True
    include_import_graph: bool = True
    include_status: bool = True


def _run_cmd(args: Sequence[str]) -> Tuple[int, str]:
    try:
        out = subprocess.check_output(list(args), cwd=PROJECT_ROOT, text=True, stderr=subprocess.DEVNULL)
        return 0, out.strip()
    except subprocess.CalledProcessError as e:
        return e.returncode, (e.output or "").strip()
    except Exception:
        return 1, ""


def _is_git_repo() -> bool:
    return (PROJECT_ROOT / ".git").exists()


def _to_rel_posix(p: Path) -> PurePosixPath:
    return PurePosixPath(p.relative_to(PROJECT_ROOT).as_posix())


def _match_any(rel_posix: PurePosixPath, patterns: Iterable[str]) -> bool:
    for pat in patterns:
        if rel_posix.match(pat):
            return True
    return False


def should_ignore(path: Path, ignore_files: set[str], ignore_globs: Sequence[str]) -> bool:
    try:
        rel = _to_rel_posix(path)
    except Exception:
        return True

    if any(part in IGNORE_DIRS for part in rel.parts):
        return True
    if path.name in ignore_files:
        return True
    if _match_any(rel, ignore_globs):
        return True
    return False


def list_candidate_files(ignore_files: set[str], ignore_globs: Sequence[str]) -> List[Path]:
    """
    Prefer git for stable, growth-friendly inventory:
      git ls-files -co --exclude-standard
    Falls back to filesystem walk if not a git repo.
    """
    files: List[Path] = []
    if _is_git_repo():
        rc, out = _run_cmd(["git", "ls-files", "-co", "--exclude-standard"])
        if rc == 0 and out:
            for line in out.splitlines():
                line = line.strip()
                if not line:
                    continue
                p = (PROJECT_ROOT / line).resolve()
                if p.is_file() and not should_ignore(p, ignore_files, ignore_globs):
                    files.append(p)
            files.sort(key=lambda x: _to_rel_posix(x).as_posix())
            return files

    # fallback: filesystem walk
    for p in PROJECT_ROOT.rglob("*"):
        if p.is_file() and not should_ignore(p, ignore_files, ignore_globs):
            files.append(p)
    files.sort(key=lambda x: _to_rel_posix(x).as_posix())
    return files


def _looks_binary(sample: bytes) -> bool:
    if b"\x00" in sample:
        return True
    if not sample:
        return False
    text_chars = b"\t\n\r\b" + bytes(range(32, 127))
    nontext = sum(1 for b in sample if b not in text_chars)
    return (nontext / max(1, len(sample))) > 0.30


def _sha256_12(path: Path) -> str:
    h = hashlib.sha256()
    with path.open("rb") as f:
        for chunk in iter(lambda: f.read(1024 * 1024), b""):
            h.update(chunk)
    return h.hexdigest()[:12]


def _normalize_paths(text: str) -> str:
    # reduce host-specific noise
    if HOME_STR and HOME_STR not in ("/", "\\"):
        text = text.replace(HOME_STR, "$HOME")
    if ROOT_STR:
        text = text.replace(ROOT_STR, "$PROJECT_ROOT")
    return text


def _redact(text: str) -> str:
    out_lines: List[str] = []
    for line in text.splitlines():
        stripped = line.strip()
        upper = stripped.upper()

        # KEY=... or KEY: ... (allow spaces)
        redacted = False
        for k in REDACT_KEYS:
            if upper.startswith(k + "=") or upper.startswith(k + ":") or upper.startswith(k + " =") or upper.startswith(k + " :"):
                # split on first ':' or '=' present
                m = re.search(r"[:=]", stripped)
                if m:
                    idx = m.start()
                    prefix = stripped[:idx].rstrip()
                    sep = stripped[idx]
                    out_lines.append(f"{prefix}{sep} ***REDACTED***")
                else:
                    out_lines.append(f"{k}=***REDACTED***")
                redacted = True
                break
        if redacted:
            continue

***REDACTED PRIVATE KEY BLOCK***
            out_lines.append("***REDACTED PRIVATE KEY BLOCK***")
            continue

        out_lines.append(line)

    return "\n".join(out_lines)


def _postprocess_text(text: str, redact: bool) -> str:
    text = _normalize_paths(text)
    if redact:
        text = _redact(text)
    return text


def read_text_snippet(path: Path, max_file_bytes: int, redact: bool) -> Optional[ReadResult]:
    try:
        size = path.stat().st_size
    except Exception:
        return None

    # quick binary guard
    try:
        with path.open("rb") as f:
            head = f.read(min(4096, size))
            if _looks_binary(head):
                return None
    except Exception:
        return None

    try:
        sha12 = _sha256_12(path)
    except Exception:
        sha12 = "Unknown"

    truncated = False
    try:
        if size <= max_file_bytes:
            raw = path.read_text(encoding="utf-8", errors="replace")
        else:
            truncated = True
            # keep total payload roughly within max_file_bytes (+marker), not 2x
            head_bytes = max(1, max_file_bytes // 2)
            tail_bytes = max(1, max_file_bytes - head_bytes)

            with path.open("rb") as f:
                head_chunk = f.read(head_bytes)
                if size > tail_bytes:
                    f.seek(-tail_bytes, os.SEEK_END)
                tail_chunk = f.read(tail_bytes)
            raw = (
                head_chunk.decode("utf-8", errors="replace")
                + "\n\n... [TRUNCATED: middle omitted] ...\n\n"
                + tail_chunk.decode("utf-8", errors="replace")
            )
    except Exception:
        return None

    text = _postprocess_text(raw, redact=redact)
    return ReadResult(text=text, truncated=truncated, size_bytes=size, sha256_12=sha12)


def detect_lang(path: Path) -> str:
    ext = path.suffix.lower()
    if ext == ".py":
        return "python"
    if ext == ".sh":
        return "bash"
    if ext in (".md", ".markdown"):
        return "markdown"
    if ext == ".ini":
        return "toml"
    if ext == ".json":
        return "json"
    if ext in (".yml", ".yaml"):
        return "yaml"
    if ext in (".txt", ".patch"):
        return "text"
    return ""


def generate_tree(root: Path, ignore_files: set[str], ignore_globs: Sequence[str], limit_lines: int = 5000) -> str:
    lines: List[str] = []

    def walk(dir_path: Path, prefix: str = "") -> None:
        if len(lines) >= limit_lines:
            lines.append(prefix + "... [TREE TRUNCATED]")
            return
        try:
            entries = sorted(dir_path.iterdir(), key=lambda p: (not p.is_dir(), p.name.lower()))
        except PermissionError:
            lines.append(f"{prefix}â””â”€â”€ [Permission Denied]")
            return

        filtered: List[Path] = []
        for p in entries:
            if p.name in IGNORE_DIRS:
                continue
            if should_ignore(p, ignore_files, ignore_globs):
                continue
            filtered.append(p)

        for i, p in enumerate(filtered):
            if len(lines) >= limit_lines:
                lines.append(prefix + "... [TREE TRUNCATED]")
                return
            pointer = "â””â”€â”€ " if i == len(filtered) - 1 else "â”œâ”€â”€ "
            lines.append(f"{prefix}{pointer}{p.name}")
            if p.is_dir():
                extension = "    " if pointer == "â””â”€â”€ " else "â”‚   "
                walk(p, prefix + extension)

    walk(root, "")
    return "\n".join(lines)


def _format_env(minimal: bool) -> str:
    now = datetime.now().astimezone().isoformat(timespec="seconds")
    info: List[str] = []
    info.append(f"Time: {now}")
    if not minimal:
        info.append(f"User: {os.getenv('USER') or os.getenv('USERNAME') or 'Unknown'}")
        info.append(f"Host: {platform.node()} ({platform.system()} {platform.release()})")
    info.append(f"Platform: {platform.platform()}")
    info.append(f"Python: {platform.python_version()} ({sys.executable})")
    info.append(f"Conda Env: {os.getenv('CONDA_DEFAULT_ENV', 'None')}")
    return _postprocess_text("\n".join(info), redact=True)


def _format_git() -> str:
    if not _is_git_repo():
        return "Git: Not a repository"

    def cmd(args: List[str]) -> str:
        rc, out = _run_cmd(args)
        return out if rc == 0 and out else "Unknown"

    branch = cmd(["git", "rev-parse", "--abbrev-ref", "HEAD"])
    commit = cmd(["git", "rev-parse", "--short", "HEAD"])
    msg = cmd(["git", "log", "-1", "--pretty=%B"]).replace("\n", " ").strip()
    porcelain = cmd(["git", "status", "--porcelain"])
    is_dirty = porcelain not in ("", "Unknown")
    dirty_mark = " [DIRTY]" if is_dirty else " [CLEAN]"

    modified = 0
    untracked = 0
    if porcelain not in ("", "Unknown"):
        for line in porcelain.splitlines():
            if line.startswith("??"):
                untracked += 1
            else:
                modified += 1

    out_lines = [
        f"Branch: {branch}{dirty_mark}",
        f"Commit: {commit}",
        f"Message: {msg}",
        f"Changes: modified={modified}, untracked={untracked}",
    ]

    diff_stat = cmd(["git", "diff", "--stat"])
    if diff_stat not in ("", "Unknown"):
        lines = diff_stat.splitlines()
        if len(lines) > 20:
            lines = lines[:20] + ["... (diff --stat truncated)"]
        out_lines.append("---")
        out_lines.extend(lines)

    return _postprocess_text("\n".join(out_lines), redact=True)


# --------- Core-mode helpers: status + registry + deps ---------

def render_project_status(status_path: Path) -> str:
    if not status_path.exists():
        return "No project status file found."

    try:
        data = json.loads(status_path.read_text(encoding="utf-8"))
    except Exception:
        return "Error reading project status."

    out: List[str] = []
    guidelines = data.get("guidelines") or []
    if guidelines:
        out.append("DEV MANIFESTO:")
        for rule in guidelines:
            out.append(f"* {rule}")
        out.append("-" * 20)

    objective = data.get("objective")
    if objective is not None:
        out.append(f"OBJECTIVE: {objective}")

    tasks = data.get("tasks") or []
    if tasks:
        done = sum(1 for t in tasks if t.get("status") == "done")
        out.append(f"\nTASKS: ({done}/{len(tasks)} done)")
        for i, t in enumerate(tasks, start=1):
            status = t.get("status", "todo")
            mark = "[x]" if status == "done" else "[ ]"
            desc = t.get("desc", "")
            out.append(f"{i}. {mark} {desc}")

    logs = data.get("logs") or []
    if logs:
        out.append("\nRECENT LOGS:")
        for l in logs[-5:]:
            out.append(f"* {l}")

    return _postprocess_text("\n".join(out).rstrip(), redact=True)


def try_load_registry_tools() -> List[Dict]:
    reg = PROJECT_ROOT / "src" / "registry.py"
    if not reg.exists():
        return []
    try:
        import importlib.util
        spec = importlib.util.spec_from_file_location("wagstaff_registry", reg)
        if spec is None or spec.loader is None:
            return []
        mod = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(mod)  # type: ignore[attr-defined]
        tools = getattr(mod, "TOOLS", None)
        if isinstance(tools, list):
            return tools
        fn = getattr(mod, "get_tools", None)
        if callable(fn):
            t = fn()
            return t if isinstance(t, list) else []
        return []
    except Exception:
        return []


def render_registry_summary() -> str:
    tools = try_load_registry_tools()
    if not tools:
        return "Registry not found or unreadable."

    lines: List[str] = []
    lines.append("| alias | file | folder | type | usage | desc |")
    lines.append("|---|---|---|---|---|---|")
    for t in tools:
        alias = t.get("alias") or "-"
        file = t.get("file") or "-"
        folder = t.get("folder") or "src"
        typ = t.get("type") or "-"
        usage = (t.get("usage") or "").replace("|", "\\|")
        desc = (t.get("desc") or "").replace("|", "\\|")
        lines.append(f"| {alias} | {file} | {folder} | {typ} | {usage} | {desc} |")

    return _postprocess_text("\n".join(lines), redact=True)


def build_internal_import_graph(py_files: List[Path]) -> List[Tuple[str, str]]:
    """
    Returns edges (src_rel -> dst_rel) for internal imports only.
    """
    module_map: Dict[str, str] = {}
    for p in py_files:
        rel = _to_rel_posix(p).as_posix()
        if rel.startswith("src/") or rel.startswith("devtools/"):
            module_map[p.stem] = rel

    edges: List[Tuple[str, str]] = []
    for p in py_files:
        rel_src = _to_rel_posix(p).as_posix()
        try:
            text = p.read_text(encoding="utf-8", errors="replace")
            tree = ast.parse(text)
        except Exception:
            continue

        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for n in node.names:
                    top = (n.name or "").split(".")[0]
                    if top in module_map and module_map[top] != rel_src:
                        edges.append((rel_src, module_map[top]))
            elif isinstance(node, ast.ImportFrom):
                if not node.module:
                    continue
                top = node.module.split(".")[0]
                if top in module_map and module_map[top] != rel_src:
                    edges.append((rel_src, module_map[top]))

    return sorted(set(edges))


def render_import_graph(edges: List[Tuple[str, str]], limit: int = 200) -> str:
    if not edges:
        return "(no internal imports detected)"
    out: List[str] = []
    for i, (a, b) in enumerate(edges):
        if i >= limit:
            out.append("... (graph truncated)")
            break
        out.append(f"- {a}  ->  {b}")
    return _postprocess_text("\n".join(out), redact=True)


# --------- Stub generation ---------

def _shorten(s: str, max_len: int = 60) -> str:
    s = " ".join(s.split())
    return s if len(s) <= max_len else (s[: max_len - 3] + "...")


def _unparse(node: ast.AST) -> str:
    try:
        return ast.unparse(node)  # py>=3.9
    except Exception:
        return ""


def _fmt_arg(a: ast.arg) -> str:
    s = a.arg
    if a.annotation is not None:
        ann = _unparse(a.annotation)
        if ann:
            s += f": {ann}"
    return s


def _summ_default(expr: ast.AST) -> str:
    s = _unparse(expr) or "..."
    return _shorten(s, 40)


def format_func_signature(fn: ast.AST) -> str:
    name = getattr(fn, "name", "func")
    args: ast.arguments = getattr(
        fn,
        "args",
        ast.arguments(posonlyargs=[], args=[], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]),
    )

    pos = list(args.posonlyargs) + list(args.args)
    defaults = list(args.defaults or [])
    default_offset = len(pos) - len(defaults)

    parts: List[str] = []

    for i, a in enumerate(args.posonlyargs):
        item = _fmt_arg(a)
        if i >= default_offset:
            item += f"={_summ_default(defaults[i - default_offset])}"
        parts.append(item)
    if args.posonlyargs:
        parts.append("/")

    for j, a in enumerate(args.args):
        i = len(args.posonlyargs) + j
        item = _fmt_arg(a)
        if i >= default_offset:
            item += f"={_summ_default(defaults[i - default_offset])}"
        parts.append(item)

    if args.vararg is not None:
        parts.append("*" + _fmt_arg(args.vararg))
    elif args.kwonlyargs:
        parts.append("*")

    for a, d in zip(args.kwonlyargs, args.kw_defaults):
        item = _fmt_arg(a)
        if d is not None:
            item += f"={_summ_default(d)}"
        parts.append(item)

    if args.kwarg is not None:
        parts.append("**" + _fmt_arg(args.kwarg))

    ret = ""
    returns = getattr(fn, "returns", None)
    if returns is not None:
        r = _unparse(returns)
        if r:
            ret = f" -> {r}"

    return f"def {name}({', '.join(parts)}){ret}: ..."


def summarize_python_constants(tree: ast.Module, max_items: int = 20) -> List[str]:
    lines: List[str] = []
    count = 0

    for node in tree.body:
        if isinstance(node, ast.Assign):
            names = [t.id for t in node.targets if isinstance(t, ast.Name)]
            if not names:
                continue
            for n in names:
                if not (n.isupper() or n.endswith("_PATH") or n.endswith("_FILE") or n.endswith("_DIR")):
                    continue
                if count >= max_items:
                    lines.append("... (constants truncated)")
                    return lines
                val = node.value
                if isinstance(val, ast.List):
                    lines.append(f"{n} = list(len={len(val.elts)})")
                elif isinstance(val, ast.Dict):
                    lines.append(f"{n} = dict(len={len(val.keys)})")
                else:
                    v = _unparse(val)
                    lines.append(f"{n} = {_shorten(v or '...', 80)}")
                count += 1
        elif isinstance(node, ast.AnnAssign) and isinstance(node.target, ast.Name):
            n = node.target.id
            if not (n.isupper() or n.endswith("_PATH") or n.endswith("_FILE") or n.endswith("_DIR")):
                continue
            if count >= max_items:
                lines.append("... (constants truncated)")
                return lines
            v = _unparse(node.value) if node.value is not None else "..."
            lines.append(f"{n} = {_shorten(v or '...', 80)}")
            count += 1

    return lines


def python_interface_stub(text: str) -> str:
    """
    Returns a compact interface-oriented representation:
    - module docstring (first line)
    - key constants (bounded)
    - classes/functions signatures
    """
    try:
        tree = ast.parse(text)
    except Exception:
        head = "\n".join(text.splitlines()[:60])
        return head + ("\n... (stub fallback; parse failed)" if len(text.splitlines()) > 60 else "")

    out: List[str] = []

    doc = ast.get_docstring(tree) or ""
    if doc:
        out.append(f'""" {_shorten(doc.splitlines()[0], 120)} """')
        out.append("")

    consts = summarize_python_constants(tree)
    if consts:
        out.append("# Key constants")
        out.extend(consts)
        out.append("")

    out.append("# API (signatures)")
    for node in tree.body:
        if isinstance(node, ast.ClassDef):
            bases = [_unparse(b) for b in node.bases] if node.bases else []
            base_str = f"({', '.join([b for b in bases if b])})" if bases else ""
            cdoc = ast.get_docstring(node) or ""
            cdoc_1 = f"  # {_shorten(cdoc.splitlines()[0], 80)}" if cdoc else ""
            out.append(f"class {node.name}{base_str}: ...{cdoc_1}")

            for item in node.body:
                if isinstance(item, (ast.FunctionDef, ast.AsyncFunctionDef)):
                    sig = format_func_signature(item)
                    mdoc = ast.get_docstring(item) or ""
                    if mdoc:
                        sig += f"  # {_shorten(mdoc.splitlines()[0], 80)}"
                    out.append("    " + sig)
            out.append("")
        elif isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
            sig = format_func_signature(node)
            fdoc = ast.get_docstring(node) or ""
            if fdoc:
                sig += f"  # {_shorten(fdoc.splitlines()[0], 80)}"
            out.append(sig)

    return "\n".join(out).rstrip()


def shell_function_stub(text: str) -> str:
    names = re.findall(r"^\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*\(\)\s*\{", text, flags=re.MULTILINE)
    out: List[str] = []
    if names:
        out.append("# Functions")
        for n in sorted(set(names)):
            out.append(f"- {n}()")
        out.append("")

    head = "\n".join(text.splitlines()[:80])
    out.append("# Head (first 80 lines)")
    out.append(head)
    if len(text.splitlines()) > 80:
        out.append("\n... (shell stub truncated)")
    return "\n".join(out).rstrip()


def markdown_stub(text: str, max_lines: int = 120) -> str:
    lines = text.splitlines()
    head = "\n".join(lines[:max_lines])
    if len(lines) <= max_lines:
        return head
    return head + "\n... (markdown stub truncated)"


def make_stub(path: Path, max_file_bytes: int, redact: bool) -> Optional[ReadResult]:
    rr = read_text_snippet(path, max_file_bytes=max_file_bytes, redact=redact)
    if rr is None:
        return None

    lang = detect_lang(path)
    raw = rr.text

    if lang == "python":
        stub = python_interface_stub(raw)
    elif lang == "bash":
        stub = shell_function_stub(raw)
    elif lang == "markdown":
        stub = markdown_stub(raw)
    else:
        stub = "\n".join(raw.splitlines()[:120])
        if len(raw.splitlines()) > 120:
            stub += "\n... (stub truncated)"

    stub_text = _postprocess_text(stub, redact=redact)
    return ReadResult(text=stub_text, truncated=True, size_bytes=rr.size_bytes, sha256_12=rr.sha256_12)


# --------- Profiles ---------

def builtin_profile(name: str) -> Profile:
    name = name.lower().strip()
    if name == "full":
        return Profile(
            name="full",
            default_action="full",
            full_globs=[],
            stub_globs=[],
            omit_globs=["project_context.txt"],
            max_file_bytes=300_000,
            max_total_bytes=8_000_000,
            inventory_limit=1000,
        )

    # core (default)
    return Profile(
        name="core",
        default_action="omit",
        full_globs=[
            "src/**/*.py",
            "bin/dst_tool.sh",
            "bin/boot.sh",
            "conf/settings.ini",
            "PROJECT_STATUS.json",
            "README.md",
            "setup.sh",
            "tests/**/*.py",
        ],
        stub_globs=[
            "devtools/**/*.py",
            "bin/wagstaff",
            "bin/pm",
            "bin/Wagstaff-Lab",
            "data/reports/**/*.md",
            "*.patch",
            ".gitignore",
        ],
        omit_globs=[
            "project_context.txt",
            "snapshots/**",
        ],
        max_file_bytes=120_000,
        max_total_bytes=900_000,
        inventory_limit=250,
    )


def load_custom_profile(path: Path) -> Optional[Profile]:
    if not path.exists():
        return None
    try:
        data = json.loads(path.read_text(encoding="utf-8"))
    except Exception:
        return None

    name = str(data.get("name") or "custom")
    default_action = str(data.get("default_action") or "omit")
    full_globs = list(data.get("full") or [])
    stub_globs = list(data.get("stub") or [])
    omit_globs = list(data.get("omit") or [])

    opts = data.get("options") or {}
    max_file = int(opts.get("max_file_bytes") or 120_000)
    max_total = int(opts.get("max_total_bytes") or 900_000)
    inv_lim = int(opts.get("inventory_limit") or 250)

    return Profile(
        name=name,
        default_action=default_action,
        full_globs=full_globs,
        stub_globs=stub_globs,
        omit_globs=omit_globs,
        max_file_bytes=max_file,
        max_total_bytes=max_total,
        inventory_limit=inv_lim,
        include_tree=bool(opts.get("include_tree", True)),
        include_env=bool(opts.get("include_env", True)),
        include_git=bool(opts.get("include_git", True)),
        include_registry_summary=bool(opts.get("include_registry_summary", True)),
        include_import_graph=bool(opts.get("include_import_graph", True)),
        include_status=bool(opts.get("include_status", True)),
    )


def classify_file(rel: PurePosixPath, profile: Profile) -> str:
    if _match_any(rel, profile.omit_globs):
        return "omit"
    if _match_any(rel, profile.full_globs):
        return "full"
    if _match_any(rel, profile.stub_globs):
        return "stub"
    return profile.default_action


def estimate_tokens(text: str) -> int:
    return max(1, len(text) // 4)


def main(argv: Optional[Sequence[str]] = None) -> int:
    parser = argparse.ArgumentParser(description="Generate Wagstaff-Lab snapshot (LLM-friendly).")
    parser.add_argument("--mode", choices=["core", "full", "custom"], default="core")
    parser.add_argument("-o", "--output", default="")
    parser.add_argument("--config", default="", help="Custom profile JSON (used in --mode custom).")
    parser.add_argument("--full", dest="full_globs", action="append", default=[], help="Add a FULL glob (custom).")
    parser.add_argument("--stub", dest="stub_globs", action="append", default=[], help="Add a STUB glob (custom).")
    parser.add_argument("--omit", dest="omit_globs", action="append", default=[], help="Add an OMIT glob (custom).")
    parser.add_argument("--max-file-bytes", type=int, default=0)
    parser.add_argument("--max-total-bytes", type=int, default=0)
    parser.add_argument("--no-redact", action="store_true")
    parser.add_argument("--no-tree", action="store_true")
    parser.add_argument("--no-deps", action="store_true")
    parser.add_argument("--no-inventory", action="store_true")
    parser.add_argument("--stdout", action="store_true")
    args = parser.parse_args(list(argv) if argv is not None else None)

    # profile selection
    if args.mode == "custom":
        cfg_path = Path(args.config) if args.config else (PROJECT_ROOT / "conf" / "snapshot_profile.json")
        if not cfg_path.is_absolute():
            cfg_path = (PROJECT_ROOT / cfg_path).resolve()
        prof = load_custom_profile(cfg_path) or builtin_profile("core")
        prof.full_globs.extend([g for g in args.full_globs if g])
        prof.stub_globs.extend([g for g in args.stub_globs if g])
        prof.omit_globs.extend([g for g in args.omit_globs if g])
    else:
        prof = builtin_profile(args.mode)

    if args.max_file_bytes and args.max_file_bytes > 0:
        prof.max_file_bytes = int(args.max_file_bytes)
    if args.max_total_bytes and args.max_total_bytes > 0:
        prof.max_total_bytes = int(args.max_total_bytes)

    if args.no_tree:
        prof.include_tree = False
    if args.no_deps:
        prof.include_import_graph = False

    redact = not args.no_redact

    # output path
    if args.output:
        out_path = Path(args.output)
        if not out_path.is_absolute():
            out_path = (PROJECT_ROOT / out_path).resolve()
    else:
        if args.mode == "full":
            ts = datetime.now().strftime("%Y%m%d_%H%M%S")
            DEFAULT_SNAPSHOT_DIR.mkdir(parents=True, exist_ok=True)
            out_path = DEFAULT_SNAPSHOT_DIR / f"snapshot_full_{ts}.md"
        else:
            out_path = DEFAULT_CORE_OUTPUT

    ignore_files = set(DEFAULT_IGNORE_FILES) | {out_path.name}
    ignore_globs = list(DEFAULT_IGNORE_GLOBS)

    candidates = list_candidate_files(ignore_files=ignore_files, ignore_globs=ignore_globs)

    full_files: List[Path] = []
    stub_files: List[Path] = []
    omit_files: List[Path] = []

    for p in candidates:
        rel = _to_rel_posix(p)
        action = classify_file(rel, prof)
        if action == "full":
            full_files.append(p)
        elif action == "stub":
            stub_files.append(p)
        else:
            omit_files.append(p)

    report: List[str] = []
    report.append(f"# Wagstaff-Lab Snapshot ({args.mode})")
    report.append("")
    report.append("## Snapshot Meta")
    report.append("```yaml")
    report.append(f"mode: {args.mode}")
    report.append(f"profile: {prof.name}")
    report.append(f"generated: {datetime.now().astimezone().isoformat(timespec='seconds')}")
    report.append(f"max_file_bytes: {prof.max_file_bytes}")
    report.append(f"max_total_bytes: {prof.max_total_bytes}")
    report.append(f"redaction: {'on' if redact else 'off'}")
    report.append("```")

    if prof.include_env:
        report.append("")
        report.append("## Environment")
        report.append("```yaml")
        report.append(_format_env(minimal=(args.mode != "full")))
        report.append("```")

    if prof.include_git:
        report.append("")
        report.append("## Git Status")
        report.append("```yaml")
        report.append(_format_git())
        report.append("```")

    if prof.include_tree:
        report.append("")
        report.append("## Project Structure")
        report.append("```text")
        report.append(generate_tree(PROJECT_ROOT, ignore_files=ignore_files, ignore_globs=ignore_globs))
        report.append("```")

    if prof.include_registry_summary:
        report.append("")
        report.append("## Tool Registry (src/registry.py)")
        report.append(render_registry_summary())

    if prof.include_import_graph:
        py_files = [p for p in candidates if p.suffix.lower() == ".py"]
        edges = build_internal_import_graph(py_files)
        report.append("")
        report.append("## Internal Dependency Map (python)")
        report.append(render_import_graph(edges))

    if prof.include_status:
        report.append("")
        report.append("## Project State (PROJECT_STATUS.json)")
        report.append("```text")
        report.append(render_project_status(PROJECT_ROOT / "PROJECT_STATUS.json"))
        report.append("```")

    # content inclusion with budget (counts embedded file text only)
    total_embedded = 0
    included_full = 0
    included_stub = 0
    truncated_files = 0
    skipped_binary = 0
    skipped_budget = 0

    def can_add(payload_bytes: int) -> bool:
        return (total_embedded + payload_bytes) <= prof.max_total_bytes

    if full_files:
        report.append("")
        report.append("## Included Full Files")
    for p in full_files:
        rr = read_text_snippet(p, max_file_bytes=prof.max_file_bytes, redact=redact)
        if rr is None:
            skipped_binary += 1
            continue
        payload_bytes = len(rr.text.encode("utf-8", errors="replace"))
        if not can_add(payload_bytes):
            skipped_budget += 1
            continue

        rel = _to_rel_posix(p).as_posix()
        report.append("")
        report.append(f"### File: {rel}")
        report.append(f"> size={rr.size_bytes}B, sha256={rr.sha256_12}" + (" (TRUNCATED)" if rr.truncated else ""))
        report.append(f"```{detect_lang(p)}".rstrip())
        report.append(rr.text)
        report.append("```")

        included_full += 1
        if rr.truncated:
            truncated_files += 1
        total_embedded += payload_bytes

    if stub_files:
        report.append("")
        report.append("## Stubbed Files (interfaces / summaries)")
    for p in stub_files:
        rr = make_stub(p, max_file_bytes=prof.max_file_bytes, redact=redact)
        if rr is None:
            skipped_binary += 1
            continue
        payload_bytes = len(rr.text.encode("utf-8", errors="replace"))
        if not can_add(payload_bytes):
            skipped_budget += 1
            continue

        rel = _to_rel_posix(p).as_posix()
        report.append("")
        report.append(f"### File: {rel} (STUB)")
        report.append(f"> size={rr.size_bytes}B, sha256={rr.sha256_12} (STUB)")
        report.append(f"```{detect_lang(p)}".rstrip())
        report.append(rr.text)
        report.append("```")

        included_stub += 1
        total_embedded += payload_bytes
        truncated_files += 1

    if (not args.no_inventory) and omit_files:
        report.append("")
        report.append("## Omitted Inventory (for completeness)")
        report.append("```text")
        report.append("path | size(B) | sha256_12")
        report.append("-" * 60)

        shown = 0
        for p in omit_files:
            if shown >= prof.inventory_limit:
                report.append(f"... ({len(omit_files) - shown} more omitted)")
                break
            try:
                size = p.stat().st_size
            except Exception:
                size = -1
            if shown < 50 or args.mode == "full":
                try:
                    sha = _sha256_12(p)
                except Exception:
                    sha = "Unknown"
            else:
                sha = "-"
            rel = _to_rel_posix(p).as_posix()
            report.append(f"{rel} | {size} | {sha}")
            shown += 1

        report.append("```")

    report.append("")
    report.append("## Snapshot Summary")
    report.append("```yaml")
    report.append(f"full_included: {included_full}/{len(full_files)}")
    report.append(f"stub_included: {included_stub}/{len(stub_files)}")
    report.append(f"omitted: {len(omit_files)}")
    report.append(f"skipped_binary: {skipped_binary}")
    report.append(f"skipped_budget: {skipped_budget}")
    report.append(f"files_truncated_or_stubbed: {truncated_files}")
    report.append(f"embedded_bytes: {total_embedded}")
    report.append("```")

    final_text = "\n".join(report)
    report.append("")
    report.append("## Token Estimate (rough)")
    report.append("```text")
    report.append(f"chars: {len(final_text)}")
    report.append(f"estimated_tokens(~chars/4): {estimate_tokens(final_text)}")
    report.append("```")

    final_text = "\n".join(report)

    if args.stdout:
        sys.stdout.write(final_text)
        return 0

    out_path.write_text(final_text, encoding="utf-8")
    print(f"âœ… Snapshot written to: {out_path}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
```

### File: src/analyzer.py
> size=8479B, sha256=770bfc436a2c
```python
#!/usr/bin/env python3
import re

# ==========================================
# 1. å…¨å±€æ•°å€¼è§£æå™¨ (TuningResolver)
# ==========================================
class TuningResolver:
    def __init__(self, content):
        self.raw_map = {}
        if content:
            self._parse_tuning(content)

    def _parse_tuning(self, content):
        clean_content = re.sub(r'\blocal\s+', '', content)
        pattern = re.compile(r'([a-zA-Z0-9_]+)\s*=\s*([^,\r\n]+)')
        for name, raw_val in pattern.findall(clean_content):
            clean_val = raw_val.split('--')[0].strip()
            try:
                self.raw_map[name] = float(clean_val)
            except ValueError:
                self.raw_map[name] = clean_val

    def _trace_value(self, start_key):
        path = []
        current_key = start_key
        visited = set()
        for _ in range(5):
            if current_key in visited: break
            visited.add(current_key)
            val = self.raw_map.get(current_key)
            if val is None: break
            if isinstance(val, float):
                path.append(f"[bold cyan]{val}[/bold cyan]")
                break
            if isinstance(val, str):
                if val in self.raw_map:
                    path.append(f"[yellow]{val}[/yellow]")
                    current_key = val
                else:
                    path.append(f"[white]{val}[/white]")
                    break
        if not path: return None
        return " âœ ".join(path)

    def enrich(self, text):
        if not text or "TUNING." not in text: return text
        def replace_match(match):
            full_key = match.group(1)
            short_key = full_key.replace("TUNING.", "")
            trace_str = self._trace_value(short_key)
            if trace_str:
                return f"{full_key} [dim]({trace_str})[/dim]"
            return full_key
        return re.sub(r'(TUNING\.[A-Z0-9_]+)', replace_match, text)

# ==========================================
# 2. Lua æ–‡ä»¶åˆ†æå™¨ (LuaAnalyzer)
# ==========================================
class LuaAnalyzer:
    def __init__(self, content):
        self.content = content
        self.structure = {
            "assets": [], "components": [], "helpers": [],
            "stategraph": None, "brain": None, "events": [], "tags": []
        }
        self.parse()

    def parse(self):
        self._extract_tables()
        self._extract_components_robust()
        self._extract_standard_helpers()
        self._extract_logic()

    def _clean_value(self, raw_val):
        val = re.sub(r'--.*', '', raw_val)
        return " ".join(val.split())

    def _extract_tables(self):
        asset_pattern = re.compile(r'Asset\s*\(\s*["\'](.*?)["\']\s*,\s*["\'](.*?)["\']\s*\)')
        for match in asset_pattern.findall(self.content):
            self.structure["assets"].append({"type": match[0], "path": match[1]})

    def _extract_standard_helpers(self):
        helper_pattern = re.compile(r'^\s*(Make[a-zA-Z0-9_]+)\s*\(', re.MULTILINE)
        found = set()
        for match in helper_pattern.findall(self.content):
            if match not in found:
                self.structure["helpers"].append(match)
                found.add(match)

    def _extract_components_robust(self):
        added_comps = set()
        add_pattern = re.compile(r'inst:AddComponent\s*\(\s*["\'](.*?)["\']\s*\)')
        for match in add_pattern.findall(self.content):
            added_comps.add(match)
        for comp_name in added_comps:
            comp_data = {"name": comp_name, "methods": [], "properties": []}
            method_pattern = re.compile(r'components\.' + re.escape(comp_name) + r'[:\.]([a-zA-Z0-9_]+)\s*\((.*?)\)', re.DOTALL)
            for m in method_pattern.findall(self.content):
                func_name = m[0]
                clean_args = self._clean_value(m[1])
                if len(clean_args) > 50: clean_args = clean_args[:47] + "..."
                comp_data["methods"].append(f"{func_name}({clean_args})")
            prop_pattern = re.compile(r'components\.' + re.escape(comp_name) + r'\.([a-zA-Z0-9_]+)\s*=\s*(.+)')
            for p in prop_pattern.findall(self.content):
                prop_name = p[0]
                raw_val = p[1].strip()
                if raw_val.startswith("function"):
                    comp_data["properties"].append(f"{prop_name} = [Function]")
                    continue
                clean_val = self._clean_value(raw_val)
                comp_data["properties"].append(f"{prop_name} = {clean_val}")
            self.structure["components"].append(comp_data)

    def _extract_logic(self):
        brain = re.search(r'inst:SetBrain\s*\(\s*require\s*\(\s*["\'](.*?)["\']\s*\)\s*\)', self.content)
        if brain: self.structure["brain"] = brain.group(1)
        sg = re.search(r'inst:SetStateGraph\s*\(\s*["\'](.*?)["\']\s*\)', self.content)
        if sg: self.structure["stategraph"] = sg.group(1)
        tags = re.findall(r'[^--]inst:AddTag\s*\(\s*["\'](.*?)["\']\s*\)', self.content)
        self.structure["tags"] = list(set(tags))
        events = re.findall(r'inst:ListenForEvent\s*\(\s*["\'](.*?)["\']', self.content)
        self.structure["events"] = list(set(events))

    def get_report(self):
        return self.structure

# ==========================================
# 3. é…æ–¹è§£æå™¨ (RecipeAnalyzer) - [FINAL]
# ==========================================
class RecipeAnalyzer:
    def __init__(self, content):
        self.raw_content = content
        self.recipes = {}
        self.aliases = {}
        if content:
            self._parse()

    def _clean_comments(self):
        return re.sub(r'--.*$', '', self.raw_content, flags=re.MULTILINE)

    def _extract_table_block(self, content, start_index):
        # å †æ ˆå¼æå– {...}
        start_brace = content.find('{', start_index)
        if start_brace == -1: return None, start_index

        balance = 1
        for i in range(start_brace + 1, len(content)):
            char = content[i]
            if char == '{':
                balance += 1
            elif char == '}':
                balance -= 1
            if balance == 0:
                return content[start_brace+1 : i], i + 1
        return None, start_index

    def _parse(self):
        clean_content = self._clean_comments()
        
        # [æ ¸å¿ƒä¿®å¤]
        # 1. \bRecipe: ç¡®ä¿åŒ¹é…å•è¯å¼€å¤´ï¼Œæ’é™¤ DeconstructRecipe
        # 2. 2?: å…¼å®¹ Recipe å’Œ Recipe2
        # 3. \(: ç¡®ä¿æ˜¯å‡½æ•°è°ƒç”¨
        iter_pattern = re.compile(r'\bRecipe2?\s*\(\s*["\'](.*?)["\']', re.DOTALL)
        
        for match in iter_pattern.finditer(clean_content):
            name = match.group(1)
            cursor = match.end()
            
            # æå–æˆåˆ†è¡¨
            ing_block, new_cursor = self._extract_table_block(clean_content, cursor)
            
            if ing_block:
                ingredients = []
                # è§£æ Ingredient
                ing_pattern = re.compile(r'Ingredient\s*\(\s*["\'](.*?)["\']\s*,\s*([^,\)]+)')
                for item, amount in ing_pattern.findall(ing_block):
                    ingredients.append({"item": item, "amount": amount.strip()})
                
                # å°è¯•æå–åç»­å‚æ•° (Tab, Tech)
                remainder = clean_content[new_cursor:].split(')')[0]
                parts = [p.strip() for p in remainder.split(',') if p.strip()]
                
                # Recipe å’Œ Recipe2 çš„å‚æ•°ä½ç½®ç•¥æœ‰ä¸åŒï¼Œä½†é€šå¸¸ Tab å’Œ Tech éƒ½åœ¨å‰é¢
                # è¿™é‡Œåšä¸ªç®€å•çš„é˜²å¾¡å¼æå–
                tab = "UNKNOWN"
                tech = "UNKNOWN"
                
                for p in parts:
                    if "TECH." in p: tech = p
                    if "RECIPETABS." in p: tab = p

                self.recipes[name] = {
                    "ingredients": ingredients,
                    "tab": tab,
                    "tech": tech
                }
                
                # å»ºç«‹ç´¢å¼•
                self.aliases[name.lower()] = name
                self.aliases[name.replace("_", "").lower()] = name

    def get(self, query_name):
        q = query_name.lower()
        real_name = self.aliases.get(q)
        if not real_name:
            real_name = self.aliases.get(q.replace("_", ""))
        
        if real_name:
            return real_name, self.recipes[real_name]
        return None, None
```

### File: src/doctor.py
> size=7012B, sha256=69d9d480c023
```python
#!/usr/bin/env python3
import os
import sys
import shutil
import subprocess
import configparser
from pathlib import Path
from rich.console import Console
from rich.table import Table
from rich.panel import Panel

console = Console()
PROJECT_ROOT = Path(__file__).resolve().parent.parent
CONFIG_PATH = PROJECT_ROOT / "conf" / "settings.ini"


def _expand(p: str) -> str:
    return os.path.expanduser(p.strip())


def _cfg_get(cfg: configparser.ConfigParser, section: str, key: str) -> str:
    try:
        v = cfg.get(section, key, fallback="").strip()
    except Exception:
        v = ""
    return _expand(v) if v else ""


def _status(level: str) -> str:
    if level == "PASS":
        return "[green]PASS[/green]"
    if level == "WARN":
        return "[yellow]WARN[/yellow]"
    return "[red]FAIL[/red]"


def _check_path_exists(path: Path, kind: str, fix: str = ""):
    if kind == "file":
        ok = path.is_file()
    elif kind == "dir":
        ok = path.is_dir()
    else:
        ok = path.exists()
    level = "PASS" if ok else "FAIL"
    return ok, level, str(path), fix


def main() -> int:
    console.print(Panel("[bold cyan]Wagstaff Doctor[/bold cyan]\nç¯å¢ƒä¸é…ç½®å¥åº·æ£€æŸ¥", border_style="cyan"))

    table = Table(title="Health Checks", box=None, show_header=True, header_style="bold cyan")
    table.add_column("Check", style="bold")
    table.add_column("Status", justify="center")
    table.add_column("Details", style="dim")
    table.add_column("Fix Hint", style="green")

    fail = 0
    warn = 0

    # 1) config file
    ok, level, details, fix = _check_path_exists(CONFIG_PATH, "file", "ç¡®è®¤ conf/settings.ini å­˜åœ¨å¹¶å¯è¯»")
    table.add_row("conf/settings.ini", _status(level), details, fix)
    if not ok:
        fail += 1
        console.print(table)
        return 1

    cfg = configparser.ConfigParser()
    try:
        cfg.read(CONFIG_PATH)
    except Exception as e:
        table.add_row("parse settings.ini", _status("FAIL"), str(e), "æ£€æŸ¥ ini æ ¼å¼")
        console.print(table)
        return 1

    dst_root = _cfg_get(cfg, "PATHS", "DST_ROOT")
    steamcmd_dir = _cfg_get(cfg, "PATHS", "STEAMCMD_DIR")
    backup_dir = _cfg_get(cfg, "PATHS", "BACKUP_DIR")
    cluster = _cfg_get(cfg, "SERVER", "CLUSTER_NAME")
    klei_home = _cfg_get(cfg, "SERVER", "KLEI_HOME")

    # 2) key fields present
    for k, v, hint in [
        ("DST_ROOT", dst_root, "åœ¨ conf/settings.ini é…ç½® PATHS.DST_ROOT"),
        ("STEAMCMD_DIR", steamcmd_dir, "åœ¨ conf/settings.ini é…ç½® PATHS.STEAMCMD_DIR"),
        ("BACKUP_DIR", backup_dir, "åœ¨ conf/settings.ini é…ç½® PATHS.BACKUP_DIR"),
        ("CLUSTER_NAME", cluster, "åœ¨ conf/settings.ini é…ç½® SERVER.CLUSTER_NAME"),
        ("KLEI_HOME", klei_home, "åœ¨ conf/settings.ini é…ç½® SERVER.KLEI_HOME"),
    ]:
        ok = bool(v)
        level = "PASS" if ok else "FAIL"
        table.add_row(f"config: {k}", _status(level), v or "(empty)", hint if not ok else "")
        if not ok:
            fail += 1

    # 3) DST root + binaries
    if dst_root:
        dst_root_p = Path(dst_root)
        ok, level, details, fix = _check_path_exists(dst_root_p, "dir", "ç¡®è®¤ DST å·²å®‰è£…åˆ°è¯¥ç›®å½•")
        table.add_row("DST_ROOT exists", _status(level), details, fix if level != "PASS" else "")
        if not ok:
            fail += 1

        bin_exe = dst_root_p / "bin" / "dontstarve_dedicated_server_nullrenderer"
        ok, level, details, fix = _check_path_exists(bin_exe, "file", "DST_ROOT/bin ä¸‹åº”å­˜åœ¨ dedicated server å¯æ‰§è¡Œæ–‡ä»¶")
        table.add_row("DST binary", _status(level), details, fix if level != "PASS" else "")
        if not ok:
            fail += 1

        scripts_zip = dst_root_p / "data" / "databundles" / "scripts.zip"
        scripts_dir = dst_root_p / "data" / "scripts"
        ok_zip = scripts_zip.is_file()
        ok_dir = scripts_dir.is_dir()
        level = "PASS" if (ok_zip or ok_dir) else "FAIL"
        details = f"zip={scripts_zip} ({'ok' if ok_zip else 'missing'}), dir={scripts_dir} ({'ok' if ok_dir else 'missing'})"
        table.add_row("scripts source", _status(level), details, "ç¡®ä¿ scripts.zip å­˜åœ¨æˆ– data/scripts å¯ç”¨" if level != "PASS" else "")
        if level != "PASS":
            fail += 1

    # 4) steamcmd
    if steamcmd_dir:
        steamcmd = Path(steamcmd_dir) / "steamcmd.sh"
        ok, level, details, fix = _check_path_exists(steamcmd, "file", "ç¡®è®¤ SteamCMD å·²å®‰è£…ä¸” steamcmd.sh å­˜åœ¨")
        table.add_row("steamcmd.sh", _status(level), details, fix if level != "PASS" else "")
        if not ok:
            fail += 1

    # 5) screen
    screen_path = shutil.which("screen")
    if not screen_path:
        table.add_row("screen installed", _status("FAIL"), "(not found)", "sudo apt-get install screen")
        fail += 1
    else:
        try:
            r = subprocess.run(["screen", "-version"], capture_output=True, text=True)
            ok = (r.returncode == 0)
            level = "PASS" if ok else "WARN"
            table.add_row("screen installed", _status(level), screen_path, "")
            if level == "WARN":
                warn += 1
        except Exception as e:
            table.add_row("screen installed", _status("WARN"), str(e), "ç¡®è®¤ screen å¯æ‰§è¡Œ")
            warn += 1

    # 6) Klei cluster paths
    if klei_home and cluster:
        klei_p = Path(klei_home)
        ok, level, details, fix = _check_path_exists(klei_p, "dir", "ç¡®ä¿ KLEI_HOME å­˜åœ¨ï¼ˆé€šå¸¸æ˜¯ ~/.klei/DoNotStarveTogetherï¼‰")
        table.add_row("KLEI_HOME exists", _status(level), details, fix if level != "PASS" else "")
        if not ok:
            warn += 1

        cluster_dir = klei_p / cluster
        ok, level, details, fix = _check_path_exists(cluster_dir, "dir", "ç¬¬ä¸€æ¬¡å¼€æœå‰ç›®å½•å¯èƒ½ä¸å­˜åœ¨ï¼›å¼€æœä¸€æ¬¡ååº”å‡ºç°")
        table.add_row("Cluster dir", _status("PASS" if ok else "WARN"), details, fix if not ok else "")
        if not ok:
            warn += 1

        master_log = cluster_dir / "Master" / "server_log.txt"
        caves_log = cluster_dir / "Caves" / "server_log.txt"
        # logs may not exist yet -> WARN
        table.add_row("Master log", _status("PASS" if master_log.exists() else "WARN"), str(master_log), "å¼€æœåç”Ÿæˆ" if not master_log.exists() else "")
        table.add_row("Caves log", _status("PASS" if caves_log.exists() else "WARN"), str(caves_log), "å¼€æœåç”Ÿæˆ" if not caves_log.exists() else "")

    # 7) backup dir (do not create; just check)
    if backup_dir:
        bdir = Path(backup_dir)
        if bdir.exists():
            table.add_row("BACKUP_DIR exists", _status("PASS"), str(bdir), "")
        else:
            table.add_row("BACKUP_DIR exists", _status("WARN"), str(bdir), "mkdir -p è¯¥ç›®å½•")
            warn += 1

    console.print(table)
    console.print(f"[dim]Summary: FAIL={fail}, WARN={warn}[/dim]")
    return 0 if fail == 0 else 1


if __name__ == "__main__":
    raise SystemExit(main())
```

### File: src/engine.py
> size=4409B, sha256=3b06776239e6
```python
#!/usr/bin/env python3
import os
import zipfile
from rich.console import Console
from utils import wagstaff_config
from analyzer import TuningResolver, RecipeAnalyzer, LuaAnalyzer

console = Console()

class WagstaffEngine:
    """
    Wagstaff Lab æ ¸å¿ƒå¼•æ“ (v1.0)
    èŒè´£: ç»Ÿä¸€ç®¡ç†æ•°æ®æº (Zip/Folder) å’Œ æ ¸å¿ƒçŸ¥è¯†åº“ (Tuning/Recipes)
    """
    def __init__(self, load_db=True, silent=False):
        self.base_dir = wagstaff_config.get('PATHS', 'DST_ROOT')
        self.zip_path = os.path.join(self.base_dir, "data", "databundles", "scripts.zip")
        self.fallback_dir = os.path.join(self.base_dir, "data", "scripts")
        
        self.mode = None
        self.source = None
        self.file_list = []
        
        self.tuning = None
        self.recipes = None
        
        self._init_source(silent)
        if load_db:
            self._init_databases(silent)

    def _init_source(self, silent):
        if os.path.exists(self.zip_path):
            self.mode = 'zip'
            self.source = zipfile.ZipFile(self.zip_path, 'r')
            self.file_list = self.source.namelist()
            if not silent: console.print(f"[dim]ğŸ“¦ å¼•æ“æŒ‚è½½ Zip æº: {self.zip_path}[/dim]")
        elif os.path.exists(self.fallback_dir):
            self.mode = 'folder'
            self.source = self.fallback_dir
            for root, _, files in os.walk(self.fallback_dir):
                for name in files:
                    rel = os.path.relpath(os.path.join(root, name), self.fallback_dir).replace("\\", "/")
                    self.file_list.append(rel)
            if not silent: console.print(f"[dim]ğŸ“‚ å¼•æ“æŒ‚è½½æ–‡ä»¶å¤¹æº: {self.fallback_dir}[/dim]")
        else:
            raise FileNotFoundError("æ— æ³•æ‰¾åˆ° scripts.zip æˆ– scripts/ ç›®å½•")

    def _init_databases(self, silent):
        if not silent: console.print("[dim]ğŸ”„ åŠ è½½ç¥ç»ä¸­æ¢ (Tuning & Recipes)...[/dim]")
        t_content = self.read_file("scripts/tuning.lua") or self.read_file("tuning.lua")
        self.tuning = TuningResolver(t_content if t_content else "")
        r_content = self.read_file("scripts/recipes.lua") or self.read_file("recipes.lua")
        self.recipes = RecipeAnalyzer(r_content if r_content else "")

    def read_file(self, path):
        """æ™ºèƒ½è¯»å–æ–‡ä»¶ï¼ˆè‡ªåŠ¨å¤„ç† scripts/ å‰ç¼€ï¼‰"""
        candidates = [path]
        if not path.startswith("scripts/"): candidates.append(f"scripts/{path}")
        else: candidates.append(path.replace("scripts/", ""))
        
        try:
            if self.mode == 'zip':
                for p in candidates:
                    if p in self.file_list:
                        return self.source.read(p).decode('utf-8', errors='replace')
            else:
                for p in candidates:
                    real_path = os.path.join(self.source, p.replace("scripts/", ""))
                    if os.path.exists(real_path):
                        with open(real_path, 'r', encoding='utf-8', errors='replace') as f: return f.read()
        except Exception:
            return None
        return None

    def find_file(self, name, fuzzy=True):
        """æ¨¡ç³ŠæŸ¥æ‰¾æ–‡ä»¶ (å¦‚ armorwood -> scripts/prefabs/armor_wood.lua)"""
        candidates = [f"scripts/prefabs/{name}.lua", f"prefabs/{name}.lua", f"scripts/{name}", name]
        for c in candidates:
            if c in self.file_list: return c
            
        if not fuzzy: return None

        target = name.replace("_", "").lower()
        for fname in self.file_list:
            if not fname.endswith(".lua"): continue
            base = os.path.basename(fname).replace(".lua", "")
            if base.replace("_", "").lower() == target:
                return fname
        return None

    def analyze_prefab(self, item_name):
        """ä¸€é”®åˆ†æ Prefab (æ•´åˆäº† wiki.py çš„é€»è¾‘)"""
        path = self.find_file(item_name)
        if not path: return None
        
        content = self.read_file(path)
        if not content: return None
        
        analyzer = LuaAnalyzer(content)
        data = analyzer.get_report()
        
        if self.tuning:
            for comp in data.get('components', []):
                comp['properties'] = [self.tuning.enrich(p) for p in comp['properties']]
                comp['methods'] = [self.tuning.enrich(m) for m in comp['methods']]
        
        return data
```

### File: src/explorer.py
> size=7609B, sha256=97e6d35c205e
```python
#!/usr/bin/env python3
import os
import sys
from rich.console import Console
from rich.table import Table
from rich.tree import Tree
from rich.panel import Panel
from rich.prompt import Prompt, IntPrompt
from rich.syntax import Syntax
from rich import box
from engine import WagstaffEngine

console = Console()

class DSTExplorer:
    def __init__(self):
        # ç›´æ¥ä½¿ç”¨å¼•æ“ï¼Œä¸å†è‡ªå·±å¤„ç† Zip å’Œ Tuning
        try:
            self.engine = WagstaffEngine(load_db=True)
        except Exception as e:
            console.print(f"[red]å¼•æ“å¯åŠ¨å¤±è´¥: {e}[/red]")
            sys.exit(1)
        
        console.print(Panel(f"[bold cyan]Wagstaff æºç é€è§†é•œ v3.0[/bold cyan]\næ ¸å¿ƒ: {self.engine.mode.upper()} æ¨¡å¼", border_style="blue"))
        if self.engine.tuning:
            console.print(f"[dim]âš¡ Tuning è§£æå™¨å°±ç»ª (åŒ…å« {len(self.engine.tuning.raw_map)} æ¡å¸¸æ•°)[/dim]")

    def get_structure_tree(self):
        tree = Tree(f"ğŸ“ [bold yellow]æºç ç»“æ„[/bold yellow]")
        dir_counts = {}
        for f in self.engine.file_list:
            clean_path = f.replace("scripts/", "", 1) if f.startswith("scripts/") else f
            top_dir = clean_path.split('/')[0] if '/' in clean_path else "[Root Files]"
            dir_counts[top_dir] = dir_counts.get(top_dir, 0) + 1

        for d, count in sorted(dir_counts.items(), key=lambda x: x[1], reverse=True):
            if d == "[Root Files]":
                tree.add(f"ğŸ“„ {d} ({count})")
            else:
                style = "bold cyan" if d in ["prefabs", "components", "tuning.lua"] else "white"
                tree.add(f"ğŸ“‚ [{style}]{d}[/{style}] ([dim]{count}[/dim])")
        return tree

    def search_files(self):
        keyword = Prompt.ask("[bold green]ğŸ” æœç´¢å…³é”®è¯[/bold green]")
        if not keyword: return
        matches = [f for f in self.engine.file_list if keyword.lower() in f.lower()]
        
        if not matches:
            console.print("[yellow]æ— ç»“æœ[/yellow]")
            return

        table = Table(title=f"Results: '{keyword}'", box=box.SIMPLE)
        table.add_column("è·¯å¾„", style="dim")
        table.add_column("æ–‡ä»¶", style="bold green")
        for m in matches[:15]:
            d, f = os.path.split(m)
            table.add_row(d, f)
        console.print(table)
        if len(matches) > 15: console.print(f"[dim]...å‰©ä½™ {len(matches)-15} é¡¹éšè—[/dim]")

    def analyze_content(self, filename, content):
        # ä½¿ç”¨å¼•æ“æä¾›çš„åˆ†ææ–¹æ³• (å·²åŒ…å«æ•°å€¼å¢å¼º)
        # æ³¨æ„ï¼šengine.analyze_prefab æ˜¯é’ˆå¯¹ prefab çš„ï¼Œè¿™é‡Œæˆ‘ä»¬å¯èƒ½éœ€è¦é€šç”¨çš„ analyzer
        # ä¸ºäº†å¤ç”¨ engine çš„èƒ½åŠ›ï¼Œæˆ‘ä»¬æ‰‹åŠ¨è°ƒç”¨ analyzer ä½†ä½¿ç”¨ engine çš„ tuning
        from analyzer import LuaAnalyzer
        
        try:
            analyzer = LuaAnalyzer(content)
            data = analyzer.get_report()
        except Exception as e:
            console.print(f"[red]è§£æå¤±è´¥: {e}[/red]")
            return
        
        tree = Tree(f"ğŸ§¬ [bold green]æ·±åº¦è§£æ: {filename}[/bold green]")
        
        # 1. èµ„æº
        if data.get('assets'):
            asset_branch = tree.add(f"ğŸ“¦ èµ„æºå¼•ç”¨ ({len(data['assets'])})")
            for a in data['assets']:
                style = "magenta" if "Anim" in a['type'] else "blue"
                asset_branch.add(f"[{style}]{a['type']}[/{style}]: {a['path']}")

        # 2. é€»è¾‘ (Brain/StateGraph/Tags)
        logic_branch = tree.add("ğŸ§  æ ¸å¿ƒé€»è¾‘")
        has_logic = False
        if data.get('brain'): 
            logic_branch.add(f"AI: [magenta]{data['brain']}[/magenta]")
            has_logic = True
        if data.get('stategraph'): 
            logic_branch.add(f"SG: [magenta]{data['stategraph']}[/magenta]")
            has_logic = True
        if data.get('tags'): 
            tags = data['tags']
            tag_str = ", ".join([f"[dim]{t}[/dim]" for t in tags[:8]])
            if len(tags) > 8: tag_str += "..."
            logic_branch.add(f"Tags: {tag_str}")
            has_logic = True
        if not has_logic: logic_branch.label = "[dim]ğŸ§  æ ¸å¿ƒé€»è¾‘ (æ— )[/dim]"

        # 3. ç»„ä»¶ (ä½¿ç”¨ Engine çš„ Tuning è¿›è¡Œå¢å¼º)
        if data.get('components'):
            comp_branch = tree.add(f"âš™ï¸ åŠŸèƒ½ç»„ä»¶ ({len(data['components'])})")
            for comp in data['components']:
                node = comp_branch.add(f"[bold yellow]{comp['name']}[/bold yellow]")
                
                # å±æ€§
                if comp['properties']:
                    target = node if len(comp['properties']) <=3 else node.add("[dim]å±æ€§é…ç½®[/dim]")
                    for p in comp['properties']:
                        p = self.engine.tuning.enrich(p) if self.engine.tuning else p
                        if "=" in p:
                            k, v = p.split("=", 1)
                            target.add(f"[cyan]{k.strip()}[/cyan] = [white]{v.strip()}[/white]")
                        else:
                            target.add(f"[cyan]{p}[/cyan]")
                
                # æ–¹æ³•
                if comp['methods']:
                    target = node if len(comp['methods']) <=3 else node.add("[dim]å‡½æ•°è°ƒç”¨[/dim]")
                    for m in comp['methods']:
                        m = self.engine.tuning.enrich(m) if self.engine.tuning else m
                        target.add(f"[green]Æ’[/green] {m}")
        else:
            tree.add("[dim]âš™ï¸ åŠŸèƒ½ç»„ä»¶ (æ— )[/dim]")

        console.print(Panel(tree, border_style="green"))
        input("æŒ‰å›è½¦è¿”å›...")

    def preview_file(self):
        target = Prompt.ask("[bold green]ğŸ‘€ æ–‡ä»¶å[/bold green]")
        path = self.engine.find_file(target, fuzzy=True)
        if not path:
            console.print("[red]æœªæ‰¾åˆ°[/red]")
            return
        
        console.print(f"[yellow]æ‰“å¼€: {path}[/yellow]")
        content = self.engine.read_file(path)
        
        if content:
            syntax = Syntax("\n".join(content.splitlines()[:50]), "lua", theme="monokai", line_numbers=True)
            console.print(Panel(syntax, title=f"{path} (Top 50 lines)", border_style="blue"))
            
            action = Prompt.ask("[bold cyan]ä¸‹ä¸€æ­¥[/bold cyan]", choices=["q", "a"], default="q")
            if action == "a":
                self.analyze_content(path, content)

    def show_tuning(self):
        if not self.engine.tuning: 
            return console.print("[red]Tuning æœªåŠ è½½[/red]")
        
        console.print("[bold magenta]ğŸ”¢ Tuning æ•°å€¼é‡‡æ ·[/bold magenta]")
        # ç®€å•å±•ç¤ºå‰ 10 ä¸ª
        count = 0
        for k, v in list(self.engine.tuning.raw_map.items())[:10]:
             console.print(f"  [cyan]{k}[/cyan] = {v}")
             count += 1

def main():
    explorer = DSTExplorer()
    while True:
        console.print("\n[bold white on blue] ğŸ¦ Wagstaff æ¢ç´¢é¢æ¿ v3.0 [/bold white on blue]")
        console.print("1. [bold]ğŸ“ ç»“æ„[/]  2. [bold]ğŸ” æœç´¢[/]  3. [bold]ğŸ‘€ é¢„è§ˆ&åˆ†æ[/]  4. [bold]ğŸ”¢ æ•°å€¼[/]  0. [bold red]é€€å‡º[/]")
        choice = IntPrompt.ask("é€‰æ‹©", choices=["0","1","2","3","4"], default=1)
        if choice == 0: break
        elif choice == 1: console.print(explorer.get_structure_tree())
        elif choice == 2: explorer.search_files()
        elif choice == 3: explorer.preview_file()
        elif choice == 4: explorer.show_tuning()

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        console.print(f"[red]Error: {e}[/red]")
```

### File: src/guide.py
> size=1548B, sha256=b69213e54f5e
```python
#!/usr/bin/env python3
import os
import sys
import json
from rich.console import Console
from rich.panel import Panel
from rich.table import Table
from pathlib import Path

# å¼•å…¥é…ç½®å’Œæ³¨å†Œè¡¨
sys.path.append(os.path.dirname(os.path.abspath(__file__)))
from registry import get_tools

console = Console()
PROJECT_ROOT = Path(__file__).resolve().parent.parent

def load_status():
    status_path = PROJECT_ROOT / "PROJECT_STATUS.json"
    if status_path.exists():
        with open(status_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    return {}

def main():
    data = load_status()
    
    console.print(Panel("[bold white on blue] ğŸ§ª Wagstaff-Lab (v2.2) æ§åˆ¶å° [/bold white on blue]", border_style="blue"))
    
    if "objective" in data:
        console.print(f"[bold green]ğŸ¯ å½“å‰ç›®æ ‡:[/bold green] {data['objective']}")
    
    # å¢åŠ  Usage åˆ—çš„å±•ç¤º
    console.print("\n[bold yellow]ğŸ› ï¸  å·¥å…·ç®±ä½¿ç”¨æŒ‡å—[/bold yellow]")
    table = Table(box=None, show_header=True, header_style="bold cyan")
    table.add_column("å·¥å…·", style="bold")
    table.add_column("æè¿°")
    table.add_column("æ ‡å‡†ç”¨æ³• (Usage)", style="green")
    
    for tool in get_tools():
        table.add_row(
            tool['file'], 
            tool['desc'], 
            tool.get('usage', 'N/A')
        )

    console.print(table)
    console.print("\n[dim]ğŸ’¡ è¾“å…¥ [bold]pm ui[/bold] ç®¡ç†ä»»åŠ¡ï¼Œè¾“å…¥ [bold]wagstaff snap[/bold] æ›´æ–°å¿«ç…§ã€‚[/dim]")

if __name__ == "__main__":
    main()
```

### File: src/registry.py
> size=1845B, sha256=99ac307d7629
```python
#!/usr/bin/env python3
"""
Wagstaff-Lab å·¥å…·æ³¨å†Œä¸­å¿ƒ (v2.3)
"""

TOOLS = [
    # --- æ ¸å¿ƒ/ä¸šåŠ¡å·¥å…· (src/) ---
    {
        "file": "guide.py",
        "alias": None,
        "desc": "Wagstaff-Lab æ§åˆ¶å°ä¸»é¢æ¿",
        "usage": "Wagstaff-Lab",
        "type": "Core"
    },
    {
        "file": "doctor.py",
        "alias": "doctor",
        "desc": "ç¯å¢ƒé…ç½®ä¸ä¾èµ–å¥åº·æ£€æŸ¥",
        "usage": "wagstaff doctor",
        "type": "Src"
    },
    {
        "file": "wiki.py",
        "alias": "wiki",
        "desc": "ç‰©å“/é…æ–¹/æ•°å€¼æŸ¥è¯¢ç™¾ç§‘",
        "usage": "wagstaff wiki <item_code>",
        "type": "Src"
    },
    {
        "file": "explorer.py",
        "alias": "exp",
        "desc": "æºç ç»“æ„æµè§ˆä¸æ·±åº¦åˆ†æ",
        "usage": "wagstaff exp",
        "type": "Src"
    },

    # --- å¼€å‘å·¥å…· (devtools/) ---
    {
        "file": "pm.py",
        "alias": "pm",
        "desc": "é¡¹ç›®è¿›åº¦ä¸ä»»åŠ¡ç®¡ç†",
        "usage": "pm [ui|obj|add|done|log]",
        "type": "Dev",
        "folder": "devtools"
    },
    {
        "file": "reporter.py",
        "alias": "report",
        "desc": "ç”Ÿæˆå…¨æœèµ„äº§/é…æ–¹åˆ†å¸ƒæŠ¥å‘Š",
        "usage": "wagstaff report [assets|recipes|all]",
        "type": "Dev",
        "folder": "devtools"
    },
    {
        "file": "snapshot.py",
        "alias": "snap",
        "desc": "ç”Ÿæˆé¡¹ç›®å…¨æ¯ä»£ç å¿«ç…§",
        "usage":  "wagstaff snap [--mode core|full|custom] [--config conf/snapshot_profile.json]",
        "type": "Dev",
        "folder": "devtools"
    },
    {
        "file": "installer.py",
        "alias": "install",
        "desc": "ç¯å¢ƒæ³¨å†Œä¸å®‰è£…å‘å¯¼",
        "usage": "python3 devtools/installer.py",
        "type": "Dev",
        "folder": "devtools"
    },
]

def get_tools():
    return TOOLS
```

### File: src/utils.py
> size=1040B, sha256=ffc01cb3d8f3
```python
import configparser
import os
from pathlib import Path

class ConfigLoader:
    def __init__(self):
        # è‡ªåŠ¨å®šä½é¡¹ç›®æ ¹ç›®å½• (å‡è®¾ utils.py åœ¨ src/ ä¸‹)
        self.project_root = Path(__file__).resolve().parent.parent
        self.config_path = self.project_root / "conf" / "settings.ini"
        
        self.config = configparser.ConfigParser()
        if not self.config_path.exists():
            raise FileNotFoundError(f"âŒ é…ç½®æ–‡ä»¶ä¸¢å¤±: {self.config_path}")
        
        self.config.read(self.config_path)

    def get(self, section, key):
        """è·å–é…ç½®å€¼å¹¶è‡ªåŠ¨å±•å¼€ç”¨æˆ·è·¯å¾„ (~)"""
        val = self.config.get(section, key, fallback=None)
        if val and "~" in val:
            return os.path.expanduser(val)
        return val

# å•ä¾‹æ¨¡å¼ï¼šç›´æ¥å¯¼å‡ºçš„å®ä¾‹
wagstaff_config = ConfigLoader()

# === æµ‹è¯•ä»£ç  ===
if __name__ == "__main__":
    print(f"Project Root: {wagstaff_config.project_root}")
    print(f"DST Path: {wagstaff_config.get('PATHS', 'DST_ROOT')}")
```

### File: src/wiki.py
> size=3622B, sha256=6a16ed377544
```python
#!/usr/bin/env python3
import sys
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.text import Text
from rich import box
from engine import WagstaffEngine # ç›´æ¥è°ƒç”¨å¼•æ“

console = Console()

def main():
    if len(sys.argv) < 2:
        console.print("[yellow]ç”¨æ³•: python src/wiki.py <ç‰©å“ä»£ç >[/yellow]")
        return
    
    target = sys.argv[1].lower()
    
    # 1. å¯åŠ¨å¼•æ“
    try:
        engine = WagstaffEngine()
    except Exception as e:
        console.print(f"[red]å¼•æ“å¯åŠ¨å¤±è´¥: {e}[/red]")
        return

    # 2. æŸ¥é…æ–¹
    real_name, recipe_data = engine.recipes.get(target)
    if not real_name: real_name = target
    
    # 3. æŸ¥æ•°æ® (ä½¿ç”¨å¼•æ“å°è£…å¥½çš„æ–¹æ³•)
    prefab_data = engine.analyze_prefab(real_name)

    if not recipe_data and not prefab_data:
        console.print(f"[red]âŒ æœªæ‰¾åˆ° '{target}'[/red]")
        return

    # === æ¸²æŸ“å±‚ (ä¿æŒåŸæœ‰ç¾è§‚é€»è¾‘) ===
    console.print(Panel(f"[bold white on blue] ğŸ“š Wagstaff æ¡£æ¡ˆ: {real_name.upper()} [/bold white on blue]"))
    
    grid = Table.grid(expand=True, padding=(0, 2))
    grid.add_column(ratio=1)
    grid.add_column(ratio=2)

    # å·¦ï¼šé…æ–¹
    left_rows = []
    if recipe_data:
        t_name = recipe_data['tab'].replace("RECIPETABS.", "")
        rt = Table(title=f"ğŸ“œ åˆæˆ ({t_name})", border_style="green", box=box.SIMPLE)
        rt.add_column("ææ–™", style="cyan"); rt.add_column("æ•°é‡", style="magenta")
        for ing in recipe_data['ingredients']:
            rt.add_row(ing['item'], engine.tuning.enrich(ing['amount']))
        left_rows.append(rt)
        if recipe_data.get('tech'): 
            left_rows.append(f"\n[dim]ğŸ”¬ {recipe_data['tech'].replace('TECH.', '')}[/dim]")
    else:
        left_rows.append(Panel("[dim]ä¸å¯åˆæˆ[/dim]", border_style="dim"))

    # å³ï¼šç»„ä»¶
    right_rows = []
    if prefab_data:
        # Helpers
        if prefab_data.get('helpers'):
            tags = [f"[reverse cyan]{h.replace('Make','').replace('Inventory','')}[/reverse cyan]" for h in prefab_data['helpers']]
            right_rows.append(Text.from_markup(" ".join(tags) + "\n"))
        
        # Stats
        INTERESTING = ["weapon", "armor", "finiteuses", "edible", "tool", "fuel", "instrument"]
        st = Table(box=box.MINIMAL, show_header=False)
        st.add_column("C", style="dim"); st.add_column("V", style="white")
        
        has_stat = False
        for comp in prefab_data.get('components', []):
            if comp['name'] in INTERESTING:
                # æå–æ–¹æ³•è°ƒç”¨ä½œä¸ºå…³é”®æ•°æ®
                for m in comp['methods']:
                    if any(k in m for k in ["SetDamage", "SetAbsorption", "SetMaxUses", "GetHealth"]):
                        icon = "âš”ï¸" if comp['name']=="weapon" else "âš™ï¸"
                        st.add_row(f"{icon} {comp['name']}", m.split('(', 1)[1][:-1]) # ç®€ç•¥æ˜¾ç¤ºå‚æ•°
                        has_stat = True
                # æå–å±æ€§
                for p in comp['properties']:
                    if "fuelvalue" in p or "armor" in p:
                         st.add_row(f"âš™ï¸ {comp['name']}", p)
                         has_stat = True
        
        if has_stat: right_rows.append(st)
        else: right_rows.append("[dim]æ— æ ¸å¿ƒæˆ˜æ–—/ç”Ÿå­˜æ•°æ®[/dim]")
    else:
        right_rows.append("[red]âš ï¸ æ— æ³•è¯»å–æ–‡ä»¶[/red]")

    from rich.console import Group
    grid.add_row(Group(*left_rows), Group(*right_rows))
    console.print(grid)

if __name__ == "__main__":
    main()
```

### File: tests/test_recipes.py
> size=1479B, sha256=89bad0a5e326
```python
#!/usr/bin/env python3
import sys
import time
from rich.console import Console
from rich.table import Table
from engine import WagstaffEngine

console = Console()

def main():
    console.print("[bold blue]ğŸ§ª é…æ–¹è§£æå™¨éªŒæ”¶æµ‹è¯• (åŸºäº Wagstaff Engine)[/bold blue]")
    
    # 1. å¯åŠ¨å¼•æ“
    try:
        start_t = time.time()
        engine = WagstaffEngine(load_db=True)
        duration = (time.time() - start_t) * 1000
    except Exception as e:
        console.print(f"[red]å¼•æ“å¯åŠ¨å¤±è´¥: {e}[/red]")
        return
    
    # 2. ç»Ÿè®¡
    count = len(engine.recipes.recipes)
    count_style = "green" if count > 500 else "red"
    
    console.print(f"åŠ è½½è€—æ—¶: [bold]{duration:.2f} ms[/bold]")
    console.print(f"å‘ç°é…æ–¹: [{count_style}]{count}[/{count_style}]")

    # 3. æŠ½æŸ¥
    check_list = ["spear", "armorwood", "hambat", "firestaff"]
    table = Table(title="å…³é”®ç‰©å“éªŒè¯", border_style="blue")
    table.add_column("Key", style="cyan")
    table.add_column("Name", style="dim")
    table.add_column("Ingredients", style="white")
    
    for item in check_list:
        real_name, data = engine.recipes.get(item)
        if data:
            ing_str = ", ".join([f"{i['item']}x{i['amount']}" for i in data['ingredients']])
            table.add_row(item, real_name, ing_str)
        else:
            table.add_row(item, "-", "[red]Not Found[/red]")
        
    console.print(table)

if __name__ == "__main__":
    main()
```

## Snapshot Summary
```yaml
full_included: 18/22
stub_included: 0/0
omitted: 0
skipped_binary: 4
skipped_budget: 0
files_truncated_or_stubbed: 0
embedded_bytes: 105426
```

## Token Estimate (rough)
```text
chars: 105953
estimated_tokens(~chars/4): 26488
```
```

### File: src/analyzer.py
- mode: full
- size_bytes: 12469
- sha256_12: 8a4532394b56

```py
#!/usr/bin/env python3
import re

# ==========================================
# 1. å…¨å±€æ•°å€¼è§£æå™¨ (TuningResolver) - [é“¾å¼è¿½è¸ªç‰ˆ]
# ==========================================
class TuningResolver:
    def __init__(self, content):
        self.raw_map = {}
        if content:
            self._parse_tuning(content)

    def _parse_tuning(self, content):
        clean_content = re.sub(r'\blocal\s+', '', content)
        # åŒ¹é… NAME = VALUE
        pattern = re.compile(r'([a-zA-Z0-9_]+)\s*=\s*([^,\r\n]+)')
        for name, raw_val in pattern.findall(clean_content):
            # å»é™¤æ³¨é‡Šå’Œç©ºç™½
            clean_val = raw_val.split('--')[0].strip()
            
            # å°è¯•ç›´æ¥è½¬æ•°å­—
            try:
                self.raw_map[name] = float(clean_val)
            except ValueError:
                # å­˜ä¸ºå­—ç¬¦ä¸²ï¼Œå¯èƒ½æ˜¯å¼•ç”¨å…¶ä»–å˜é‡
                self.raw_map[name] = clean_val

    def enrich(self, text):
        if not text or "TUNING." not in text: return text
        
        def replace_match(match):
            root_key = match.group(1).replace("TUNING.", "")
            
            # === é“¾å¼è¿½è¸ªé€»è¾‘ Start ===
            chain = []
            current_key = root_key
            visited = {root_key}
            
            # æœ€å¤šè¿½è¸ª 5 å±‚ï¼Œé˜²æ­¢æ­»å¾ªç¯
            for _ in range(5):
                val = self.raw_map.get(current_key)
                
                # 1. å¦‚æœæ²¡æ‰¾åˆ°å€¼ï¼Œåœæ­¢
                if val is None:
                    break
                
                # 2. å¦‚æœæ˜¯æ•°å­—ï¼Œè¿™æ˜¯ç»ˆç‚¹
                if isinstance(val, (int, float)):
                    if isinstance(val, float) and val.is_integer():
                        val = int(val)
                    chain.append(f"[bold cyan]{val}[/bold cyan]") # æœ€ç»ˆæ•°å€¼é«˜äº®
                    break
                
                # 3. å¦‚æœæ˜¯å­—ç¬¦ä¸²
                if isinstance(val, str):
                    # 3a. å¦‚æœè¿™ä¸ªå­—ç¬¦ä¸²ä¹Ÿæ˜¯ä¸ªå˜é‡åï¼ˆåœ¨è¡¨ä¸­å­˜åœ¨ï¼‰ï¼Œç»§ç»­è¿½è¸ª
                    if val in self.raw_map and val not in visited:
                        chain.append(f"[dim]{val}[/dim]") # ä¸­é—´å˜é‡å˜æš—
                        current_key = val
                        visited.add(val)
                    # 3b. åªæ˜¯æ™®é€šå­—ç¬¦ä¸²å­—é¢é‡
                    else:
                        chain.append(f"[green]'{val}'[/green]")
                        break
            # === é“¾å¼è¿½è¸ªé€»è¾‘ End ===

            if chain:
                # å°†è·¯å¾„ç”¨ -> è¿æ¥ï¼Œä¾‹å¦‚: (wilson_attack -> 34)
                chain_str = " -> ".join(chain)
                return f"{match.group(1)} ({chain_str})"
            
            return match.group(1)
            
        return re.sub(r'(TUNING\.[A-Z0-9_]+)', replace_match, text)


# ==========================================
# 2. ä¸“ç”¨è§£æå™¨ç­–ç•¥ (Parsers)
# ==========================================

class BaseParser:
    def __init__(self, content):
        self.content = content
        # é¢„å¤„ç†ï¼šç§»é™¤æ³¨é‡Šä»¥ä¾¿æ­£åˆ™åŒ¹é…ï¼ŒåŒæ—¶ä¿ç•™æ¢è¡Œä»¥ç»´æŒç»“æ„æ„Ÿ
        self.clean_content = re.sub(r'--.*$', '', content, flags=re.MULTILINE)
        self.clean_content = re.sub(r'--\[\[.*?\]\]', '', self.clean_content, flags=re.DOTALL)

    def _extract_requires(self):
        return re.findall(r'require\s*[\("\'](.*?)[\)"\']', self.clean_content)

class LootParser(BaseParser):
    """è§£ææ‰è½è¡¨ (LootTables) - v2.0 å¢å¼ºç‰ˆ"""
    def parse(self):
        data = {
            "type": "loot",
            "table_name": None,
            "entries": []
        }
        
        # 1. æå–è¡¨åå®šä¹‰ (SetSharedLootTable)
        table_match = re.search(r'SetSharedLootTable\s*\(\s*[\'"]([^\'"]+)[\'"]', self.clean_content)
        if table_match:
            data["table_name"] = table_match.group(1)

        # 2. [æ–°å¢] æå–å†…è”è¡¨å®šä¹‰ (Inline Table Data)
        # é’ˆå¯¹ Krampus è¿™ç§ç›´æ¥åœ¨ SetSharedLootTable ä¸­ä¼ å…¥åˆ—è¡¨çš„æƒ…å†µ
        if data["table_name"]:
            start_idx = self.clean_content.find("SetSharedLootTable")
            if start_idx != -1:
                snippet = self.clean_content[start_idx:]
                # åŒ¹é…: { 'prefab', number }
                inline_matches = re.findall(r'\{\s*[\'"]([^\'"]+)[\'"]\s*,\s*([\d\.]+)\s*\}', snippet)
                for item, chance in inline_matches:
                    data["entries"].append({"item": item, "chance": float(chance), "method": "TableData"})

        # 3. æå–éšæœºæ‰è½ (AddRandomLoot)
        for p, w in re.findall(r'AddRandom.*?Loot\s*\(\s*[\'"]([^\'"]+)[\'"]\s*,\s*([\d\.]+)', self.clean_content):
            data["entries"].append({"item": p, "weight": float(w), "method": "Random"})

        # 4. æå–æ¦‚ç‡æ‰è½ (AddChanceLoot)
        for p, c in re.findall(r'AddChanceLoot\s*\(\s*[\'"]([^\'"]+)[\'"]\s*,\s*([\d\.]+)', self.clean_content):
            data["entries"].append({"item": p, "chance": float(c), "method": "Chance"})

        return data

class WidgetParser(BaseParser):
    """è§£æ UI ç»„ä»¶ (Widgets/Screens)"""
    def parse(self):
        data = {
            "type": "widget",
            "classes": [],
            "dependencies": self._extract_requires()
        }

        # æå–ç±»ç»§æ‰¿å…³ç³»
        pattern = r'local\s+([a-zA-Z0-9_]+)\s*=\s*Class\s*\(\s*([a-zA-Z0-9_]+)'
        for name, parent in re.findall(pattern, self.clean_content):
            data["classes"].append({"name": name, "parent": parent})

        return data

class StringParser(BaseParser):
    """è§£ææ–‡æœ¬é…ç½® (STRINGS)"""
    def parse(self):
        data = {
            "type": "strings",
            "roots": [],
            "includes": self._extract_requires()
        }

        # æå–é¡¶çº§ Key å®šä¹‰
        for match in re.findall(r'STRINGS\.([A-Z0-9_]+)\s*=\s*\{', self.clean_content):
            data["roots"].append(match)
        
        # æå–ç›´æ¥èµ‹å€¼
        for match in re.findall(r'STRINGS\.([A-Z0-9_]+)\s*=\s*["\']', self.clean_content):
             if match not in data["roots"]:
                 data["roots"].append(match)

        return data

class PrefabParser(BaseParser):
    """è§£æå®ä½“é¢„è®¾ (Standard Prefabs)"""
    def parse(self):
        data = {
            "type": "prefab",
            "assets": [], "components": [], "helpers": [],
            "stategraph": None, "brain": None, "events": [], "tags": []
        }
        
        # Assets
        for t, p in re.findall(r'Asset\s*\(\s*["\'](.*?)["\']\s*,\s*["\'](.*?)["\']\s*\)', self.clean_content):
            data["assets"].append({"type": t, "path": p})

        # Logic (Brain/SG)
        brain = re.search(r'SetBrain\s*\(\s*require\s*\(\s*["\'](.*?)["\']\s*\)\s*\)', self.clean_content)
        if brain: data["brain"] = brain.group(1)
        
        sg = re.search(r'SetStateGraph\s*\(\s*["\'](.*?)["\']\s*\)', self.clean_content)
        if sg: data["stategraph"] = sg.group(1)

        # Helpers & Tags
        data["helpers"] = list(set(re.findall(r'^\s*(Make[a-zA-Z0-9_]+)\s*\(', self.content, re.MULTILINE)))
        data["tags"] = list(set(re.findall(r'inst:AddTag\s*\(\s*["\'](.*?)["\']\s*\)', self.clean_content)))

        # Components
        added_comps = set(re.findall(r'inst:AddComponent\s*\(\s*["\'](.*?)["\']\s*\)', self.clean_content))
        for comp_name in added_comps:
            comp_data = {"name": comp_name, "methods": [], "properties": []}
            
            # æ–¹æ³•è°ƒç”¨
            method_pattern = r'components\.' + re.escape(comp_name) + r'[:\.]([a-zA-Z0-9_]+)\s*\((.*?)\)'
            for m_name, m_args in re.findall(method_pattern, self.clean_content):
                clean_args = re.sub(r'\s+', ' ', m_args).strip()
                if len(clean_args) > 30: clean_args = clean_args[:27] + "..."
                comp_data["methods"].append(f"{m_name}({clean_args})")
            
            # å±æ€§èµ‹å€¼
            prop_pattern = r'components\.' + re.escape(comp_name) + r'\.([a-zA-Z0-9_]+)\s*=\s*([^=\n]+)'
            for p_name, p_val in re.findall(prop_pattern, self.clean_content):
                comp_data["properties"].append(f"{p_name} = {p_val.strip()}")

            data["components"].append(comp_data)
            
        return data

# ==========================================
# 3. ç»Ÿä¸€åˆ†æå…¥å£ (Facade)
# ==========================================
class LuaAnalyzer:
    """
    æ™ºèƒ½åˆ†æå™¨ï¼šæ ¹æ®æ–‡ä»¶ç‰¹å¾è‡ªåŠ¨é€‰æ‹©æœ€ä½³è§£æç­–ç•¥
    """
    def __init__(self, content):
        self.content = content
        self.parser = self._select_strategy()

    def _select_strategy(self):
        # 1. Widget/Screen (UI) - ä¼˜å…ˆçº§æœ€é«˜
        if "Class(Widget" in self.content or "Class(Screen" in self.content or 'require "widgets/' in self.content:
            return WidgetParser(self.content)
        
        # 2. Prefab (å®ä½“) - [å…³é”®ä¿®å¤] ä¼˜å…ˆåˆ¤å®šå®ä½“
        # åªè¦åŒ…å« "return Prefab"ï¼Œå®ƒå°±æ˜¯å®ä½“æ–‡ä»¶ï¼Œæ— è®ºé‡Œé¢æœ‰æ²¡æœ‰æ‰è½è¡¨å®šä¹‰
        if "return Prefab" in self.content:
            return PrefabParser(self.content)
            
        # 3. Strings (æ–‡æœ¬)
        if "STRINGS." in self.content and "STRINGS.CHARACTERS" in self.content:
            return StringParser(self.content)

        # 4. Loot Table (çº¯æ‰è½è¡¨æ–‡ä»¶)
        # åªæœ‰åœ¨ä¸æ˜¯ Prefab çš„æƒ…å†µä¸‹ï¼ŒSetSharedLootTable æ‰æ„å‘³ç€å®ƒæ˜¯çº¯æ•°æ®è¡¨
        if "SetSharedLootTable" in self.content or "AddChanceLoot" in self.content:
            return LootParser(self.content)
        
        # 5. é»˜è®¤å›é€€
        return PrefabParser(self.content)

    def get_report(self):
        return self.parser.parse()

# ==========================================
# 4. é…æ–¹è§£æå™¨ (RecipeAnalyzer)
# ==========================================
class RecipeAnalyzer:
    def __init__(self, content):
        self.raw_content = content
        self.recipes = {}
        self.aliases = {}
        if content:
            self._parse()

    def _clean_comments(self):
        return re.sub(r'--.*$', '', self.raw_content, flags=re.MULTILINE)

    def _extract_table_block(self, content, start_index):
        start_brace = content.find('{', start_index)
        if start_brace == -1: return None, start_index
        balance = 1
        for i in range(start_brace + 1, len(content)):
            if content[i] == '{': balance += 1
            elif content[i] == '}': balance -= 1
            if balance == 0: return content[start_brace+1 : i], i + 1
        return None, start_index

    def _parse(self):
        clean_content = self._clean_comments()
        iter_pattern = re.compile(r'\bRecipe2?\s*\(\s*["\'](.*?)["\']', re.DOTALL)
        
        for match in iter_pattern.finditer(clean_content):
            name = match.group(1)
            cursor = match.end()
            ing_block, new_cursor = self._extract_table_block(clean_content, cursor)
            
            if ing_block:
                ingredients = []
                for item, amount in re.findall(r'Ingredient\s*\(\s*["\'](.*?)["\']\s*,\s*([^,\)]+)', ing_block):
                    ingredients.append({"item": item, "amount": amount.strip()})
                
                # [ä¼˜åŒ–] æå–åç»­å‚æ•° (Tab, Tech)
                # æˆªå–ç›´åˆ°ä¸‹ä¸€ä¸ª Recipe å¼€å§‹ï¼Œæˆ–è€…æ–‡ä»¶ç»“æŸ
                remainder_chunk = clean_content[new_cursor : new_cursor + 300] 
                
                tab = "UNKNOWN"
                tech = "UNKNOWN"
                
                # æå– TECH.XYZ
                tech_match = re.search(r'(TECH\.[A-Z0-9_]+)', remainder_chunk)
                if tech_match:
                    tech = tech_match.group(1)
                
                # æå– RECIPETABS.XYZ
                tab_match = re.search(r'(RECIPETABS\.[A-Z0-9_]+)', remainder_chunk)
                if tab_match:
                    tab = tab_match.group(1)

                self.recipes[name] = {"ingredients": ingredients, "tab": tab, "tech": tech}
                self.aliases[name.lower()] = name
                self.aliases[name.replace("_", "").lower()] = name

    def get(self, query_name):
        q = query_name.lower()
        real_name = self.aliases.get(q) or self.aliases.get(q.replace("_", ""))
        return (real_name, self.recipes[real_name]) if real_name else (None, None)
```

### File: src/doctor.py
- mode: full
- size_bytes: 7012
- sha256_12: 69d9d480c023

```py
#!/usr/bin/env python3
import os
import sys
import shutil
import subprocess
import configparser
from pathlib import Path
from rich.console import Console
from rich.table import Table
from rich.panel import Panel

console = Console()
PROJECT_ROOT = Path(__file__).resolve().parent.parent
CONFIG_PATH = PROJECT_ROOT / "conf" / "settings.ini"


def _expand(p: str) -> str:
    return os.path.expanduser(p.strip())


def _cfg_get(cfg: configparser.ConfigParser, section: str, key: str) -> str:
    try:
        v = cfg.get(section, key, fallback="").strip()
    except Exception:
        v = ""
    return _expand(v) if v else ""


def _status(level: str) -> str:
    if level == "PASS":
        return "[green]PASS[/green]"
    if level == "WARN":
        return "[yellow]WARN[/yellow]"
    return "[red]FAIL[/red]"


def _check_path_exists(path: Path, kind: str, fix: str = ""):
    if kind == "file":
        ok = path.is_file()
    elif kind == "dir":
        ok = path.is_dir()
    else:
        ok = path.exists()
    level = "PASS" if ok else "FAIL"
    return ok, level, str(path), fix


def main() -> int:
    console.print(Panel("[bold cyan]Wagstaff Doctor[/bold cyan]\nç¯å¢ƒä¸é…ç½®å¥åº·æ£€æŸ¥", border_style="cyan"))

    table = Table(title="Health Checks", box=None, show_header=True, header_style="bold cyan")
    table.add_column("Check", style="bold")
    table.add_column("Status", justify="center")
    table.add_column("Details", style="dim")
    table.add_column("Fix Hint", style="green")

    fail = 0
    warn = 0

    # 1) config file
    ok, level, details, fix = _check_path_exists(CONFIG_PATH, "file", "ç¡®è®¤ conf/settings.ini å­˜åœ¨å¹¶å¯è¯»")
    table.add_row("conf/settings.ini", _status(level), details, fix)
    if not ok:
        fail += 1
        console.print(table)
        return 1

    cfg = configparser.ConfigParser()
    try:
        cfg.read(CONFIG_PATH)
    except Exception as e:
        table.add_row("parse settings.ini", _status("FAIL"), str(e), "æ£€æŸ¥ ini æ ¼å¼")
        console.print(table)
        return 1

    dst_root = _cfg_get(cfg, "PATHS", "DST_ROOT")
    steamcmd_dir = _cfg_get(cfg, "PATHS", "STEAMCMD_DIR")
    backup_dir = _cfg_get(cfg, "PATHS", "BACKUP_DIR")
    cluster = _cfg_get(cfg, "SERVER", "CLUSTER_NAME")
    klei_home = _cfg_get(cfg, "SERVER", "KLEI_HOME")

    # 2) key fields present
    for k, v, hint in [
        ("DST_ROOT", dst_root, "åœ¨ conf/settings.ini é…ç½® PATHS.DST_ROOT"),
        ("STEAMCMD_DIR", steamcmd_dir, "åœ¨ conf/settings.ini é…ç½® PATHS.STEAMCMD_DIR"),
        ("BACKUP_DIR", backup_dir, "åœ¨ conf/settings.ini é…ç½® PATHS.BACKUP_DIR"),
        ("CLUSTER_NAME", cluster, "åœ¨ conf/settings.ini é…ç½® SERVER.CLUSTER_NAME"),
        ("KLEI_HOME", klei_home, "åœ¨ conf/settings.ini é…ç½® SERVER.KLEI_HOME"),
    ]:
        ok = bool(v)
        level = "PASS" if ok else "FAIL"
        table.add_row(f"config: {k}", _status(level), v or "(empty)", hint if not ok else "")
        if not ok:
            fail += 1

    # 3) DST root + binaries
    if dst_root:
        dst_root_p = Path(dst_root)
        ok, level, details, fix = _check_path_exists(dst_root_p, "dir", "ç¡®è®¤ DST å·²å®‰è£…åˆ°è¯¥ç›®å½•")
        table.add_row("DST_ROOT exists", _status(level), details, fix if level != "PASS" else "")
        if not ok:
            fail += 1

        bin_exe = dst_root_p / "bin" / "dontstarve_dedicated_server_nullrenderer"
        ok, level, details, fix = _check_path_exists(bin_exe, "file", "DST_ROOT/bin ä¸‹åº”å­˜åœ¨ dedicated server å¯æ‰§è¡Œæ–‡ä»¶")
        table.add_row("DST binary", _status(level), details, fix if level != "PASS" else "")
        if not ok:
            fail += 1

        scripts_zip = dst_root_p / "data" / "databundles" / "scripts.zip"
        scripts_dir = dst_root_p / "data" / "scripts"
        ok_zip = scripts_zip.is_file()
        ok_dir = scripts_dir.is_dir()
        level = "PASS" if (ok_zip or ok_dir) else "FAIL"
        details = f"zip={scripts_zip} ({'ok' if ok_zip else 'missing'}), dir={scripts_dir} ({'ok' if ok_dir else 'missing'})"
        table.add_row("scripts source", _status(level), details, "ç¡®ä¿ scripts.zip å­˜åœ¨æˆ– data/scripts å¯ç”¨" if level != "PASS" else "")
        if level != "PASS":
            fail += 1

    # 4) steamcmd
    if steamcmd_dir:
        steamcmd = Path(steamcmd_dir) / "steamcmd.sh"
        ok, level, details, fix = _check_path_exists(steamcmd, "file", "ç¡®è®¤ SteamCMD å·²å®‰è£…ä¸” steamcmd.sh å­˜åœ¨")
        table.add_row("steamcmd.sh", _status(level), details, fix if level != "PASS" else "")
        if not ok:
            fail += 1

    # 5) screen
    screen_path = shutil.which("screen")
    if not screen_path:
        table.add_row("screen installed", _status("FAIL"), "(not found)", "sudo apt-get install screen")
        fail += 1
    else:
        try:
            r = subprocess.run(["screen", "-version"], capture_output=True, text=True)
            ok = (r.returncode == 0)
            level = "PASS" if ok else "WARN"
            table.add_row("screen installed", _status(level), screen_path, "")
            if level == "WARN":
                warn += 1
        except Exception as e:
            table.add_row("screen installed", _status("WARN"), str(e), "ç¡®è®¤ screen å¯æ‰§è¡Œ")
            warn += 1

    # 6) Klei cluster paths
    if klei_home and cluster:
        klei_p = Path(klei_home)
        ok, level, details, fix = _check_path_exists(klei_p, "dir", "ç¡®ä¿ KLEI_HOME å­˜åœ¨ï¼ˆé€šå¸¸æ˜¯ ~/.klei/DoNotStarveTogetherï¼‰")
        table.add_row("KLEI_HOME exists", _status(level), details, fix if level != "PASS" else "")
        if not ok:
            warn += 1

        cluster_dir = klei_p / cluster
        ok, level, details, fix = _check_path_exists(cluster_dir, "dir", "ç¬¬ä¸€æ¬¡å¼€æœå‰ç›®å½•å¯èƒ½ä¸å­˜åœ¨ï¼›å¼€æœä¸€æ¬¡ååº”å‡ºç°")
        table.add_row("Cluster dir", _status("PASS" if ok else "WARN"), details, fix if not ok else "")
        if not ok:
            warn += 1

        master_log = cluster_dir / "Master" / "server_log.txt"
        caves_log = cluster_dir / "Caves" / "server_log.txt"
        # logs may not exist yet -> WARN
        table.add_row("Master log", _status("PASS" if master_log.exists() else "WARN"), str(master_log), "å¼€æœåç”Ÿæˆ" if not master_log.exists() else "")
        table.add_row("Caves log", _status("PASS" if caves_log.exists() else "WARN"), str(caves_log), "å¼€æœåç”Ÿæˆ" if not caves_log.exists() else "")

    # 7) backup dir (do not create; just check)
    if backup_dir:
        bdir = Path(backup_dir)
        if bdir.exists():
            table.add_row("BACKUP_DIR exists", _status("PASS"), str(bdir), "")
        else:
            table.add_row("BACKUP_DIR exists", _status("WARN"), str(bdir), "mkdir -p è¯¥ç›®å½•")
            warn += 1

    console.print(table)
    console.print(f"[dim]Summary: FAIL={fail}, WARN={warn}[/dim]")
    return 0 if fail == 0 else 1


if __name__ == "__main__":
    raise SystemExit(main())
```

### File: src/engine.py
- mode: full
- size_bytes: 4409
- sha256_12: 3b06776239e6

```py
#!/usr/bin/env python3
import os
import zipfile
from rich.console import Console
from utils import wagstaff_config
from analyzer import TuningResolver, RecipeAnalyzer, LuaAnalyzer

console = Console()

class WagstaffEngine:
    """
    Wagstaff Lab æ ¸å¿ƒå¼•æ“ (v1.0)
    èŒè´£: ç»Ÿä¸€ç®¡ç†æ•°æ®æº (Zip/Folder) å’Œ æ ¸å¿ƒçŸ¥è¯†åº“ (Tuning/Recipes)
    """
    def __init__(self, load_db=True, silent=False):
        self.base_dir = wagstaff_config.get('PATHS', 'DST_ROOT')
        self.zip_path = os.path.join(self.base_dir, "data", "databundles", "scripts.zip")
        self.fallback_dir = os.path.join(self.base_dir, "data", "scripts")
        
        self.mode = None
        self.source = None
        self.file_list = []
        
        self.tuning = None
        self.recipes = None
        
        self._init_source(silent)
        if load_db:
            self._init_databases(silent)

    def _init_source(self, silent):
        if os.path.exists(self.zip_path):
            self.mode = 'zip'
            self.source = zipfile.ZipFile(self.zip_path, 'r')
            self.file_list = self.source.namelist()
            if not silent: console.print(f"[dim]ğŸ“¦ å¼•æ“æŒ‚è½½ Zip æº: {self.zip_path}[/dim]")
        elif os.path.exists(self.fallback_dir):
            self.mode = 'folder'
            self.source = self.fallback_dir
            for root, _, files in os.walk(self.fallback_dir):
                for name in files:
                    rel = os.path.relpath(os.path.join(root, name), self.fallback_dir).replace("\\", "/")
                    self.file_list.append(rel)
            if not silent: console.print(f"[dim]ğŸ“‚ å¼•æ“æŒ‚è½½æ–‡ä»¶å¤¹æº: {self.fallback_dir}[/dim]")
        else:
            raise FileNotFoundError("æ— æ³•æ‰¾åˆ° scripts.zip æˆ– scripts/ ç›®å½•")

    def _init_databases(self, silent):
        if not silent: console.print("[dim]ğŸ”„ åŠ è½½ç¥ç»ä¸­æ¢ (Tuning & Recipes)...[/dim]")
        t_content = self.read_file("scripts/tuning.lua") or self.read_file("tuning.lua")
        self.tuning = TuningResolver(t_content if t_content else "")
        r_content = self.read_file("scripts/recipes.lua") or self.read_file("recipes.lua")
        self.recipes = RecipeAnalyzer(r_content if r_content else "")

    def read_file(self, path):
        """æ™ºèƒ½è¯»å–æ–‡ä»¶ï¼ˆè‡ªåŠ¨å¤„ç† scripts/ å‰ç¼€ï¼‰"""
        candidates = [path]
        if not path.startswith("scripts/"): candidates.append(f"scripts/{path}")
        else: candidates.append(path.replace("scripts/", ""))
        
        try:
            if self.mode == 'zip':
                for p in candidates:
                    if p in self.file_list:
                        return self.source.read(p).decode('utf-8', errors='replace')
            else:
                for p in candidates:
                    real_path = os.path.join(self.source, p.replace("scripts/", ""))
                    if os.path.exists(real_path):
                        with open(real_path, 'r', encoding='utf-8', errors='replace') as f: return f.read()
        except Exception:
            return None
        return None

    def find_file(self, name, fuzzy=True):
        """æ¨¡ç³ŠæŸ¥æ‰¾æ–‡ä»¶ (å¦‚ armorwood -> scripts/prefabs/armor_wood.lua)"""
        candidates = [f"scripts/prefabs/{name}.lua", f"prefabs/{name}.lua", f"scripts/{name}", name]
        for c in candidates:
            if c in self.file_list: return c
            
        if not fuzzy: return None

        target = name.replace("_", "").lower()
        for fname in self.file_list:
            if not fname.endswith(".lua"): continue
            base = os.path.basename(fname).replace(".lua", "")
            if base.replace("_", "").lower() == target:
                return fname
        return None

    def analyze_prefab(self, item_name):
        """ä¸€é”®åˆ†æ Prefab (æ•´åˆäº† wiki.py çš„é€»è¾‘)"""
        path = self.find_file(item_name)
        if not path: return None
        
        content = self.read_file(path)
        if not content: return None
        
        analyzer = LuaAnalyzer(content)
        data = analyzer.get_report()
        
        if self.tuning:
            for comp in data.get('components', []):
                comp['properties'] = [self.tuning.enrich(p) for p in comp['properties']]
                comp['methods'] = [self.tuning.enrich(m) for m in comp['methods']]
        
        return data
```

### File: src/explorer.py
- mode: full
- size_bytes: 9616
- sha256_12: 6f0febfb5667

```py
#!/usr/bin/env python3
import os
import sys
from rich.console import Console
from rich.table import Table
from rich.tree import Tree
from rich.panel import Panel
from rich.prompt import Prompt, IntPrompt
from rich.syntax import Syntax
from rich import box
from engine import WagstaffEngine

console = Console()

class DSTExplorer:
    def __init__(self):
        # åˆå§‹åŒ–å¼•æ“
        try:
            self.engine = WagstaffEngine(load_db=True)
        except Exception as e:
            console.print(f"[red]å¼•æ“å¯åŠ¨å¤±è´¥: {e}[/red]")
            sys.exit(1)
        
        console.print(Panel(f"[bold cyan]Wagstaff æºç é€è§†é•œ v3.1[/bold cyan]\næ¨¡å¼: {self.engine.mode.upper()} | è§£ææ ¸å¿ƒ: Multi-Parser", border_style="blue"))
        if self.engine.tuning:
            console.print(f"[dim]âš¡ Tuning æ•°å€¼åº“å°±ç»ª ({len(self.engine.tuning.raw_map)} æ¡ç›®)[/dim]")

    def get_structure_tree(self):
        """å±•ç¤ºæºç ç›®å½•ç»“æ„"""
        tree = Tree(f"ğŸ“ [bold yellow]æºç ç»“æ„[/bold yellow]")
        dir_counts = {}
        for f in self.engine.file_list:
            clean_path = f.replace("scripts/", "", 1) if f.startswith("scripts/") else f
            top_dir = clean_path.split('/')[0] if '/' in clean_path else "[Root Files]"
            dir_counts[top_dir] = dir_counts.get(top_dir, 0) + 1

        for d, count in sorted(dir_counts.items(), key=lambda x: x[1], reverse=True):
            if d == "[Root Files]":
                tree.add(f"ğŸ“„ {d} ({count})")
            else:
                style = "bold cyan" if d in ["prefabs", "components", "tuning.lua"] else "white"
                tree.add(f"ğŸ“‚ [{style}]{d}[/{style}] ([dim]{count}[/dim])")
        return tree

    def search_files(self):
        """æ–‡ä»¶åæœç´¢"""
        keyword = Prompt.ask("[bold green]ğŸ” æœç´¢å…³é”®è¯[/bold green]")
        if not keyword: return
        
        matches = [f for f in self.engine.file_list if keyword.lower() in f.lower()]
        
        if not matches:
            console.print("[yellow]æ— ç»“æœ[/yellow]")
            return

        table = Table(title=f"Results: '{keyword}'", box=box.SIMPLE)
        table.add_column("è·¯å¾„", style="dim")
        table.add_column("æ–‡ä»¶", style="bold green")
        for m in matches[:15]:
            d, f = os.path.split(m)
            table.add_row(d, f)
        console.print(table)
        if len(matches) > 15: console.print(f"[dim]...å‰©ä½™ {len(matches)-15} é¡¹éšè—[/dim]")

    def analyze_content(self, filename, content):
        """æ ¸å¿ƒåˆ†æé€»è¾‘ï¼šæ ¹æ® analyzer è¿”å›çš„ç±»å‹è¿›è¡Œå¤šæ€æ¸²æŸ“"""
        from analyzer import LuaAnalyzer
        
        try:
            # 1. ç»Ÿä¸€å…¥å£è§£æ (Facade)
            data = LuaAnalyzer(content).get_report()
        except Exception as e:
            console.print(f"[red]è§£æå¤±è´¥: {e}[/red]")
            return
        
        # 2. æ ¹æ®æ•°æ®ç±»å‹åˆ†å‘æ¸²æŸ“
        dtype = data.get("type", "prefab")
        tree = Tree(f"ğŸ§¬ [bold green]æ·±åº¦è§£æ: {dtype.upper()}[/bold green]")
        
        if dtype == "loot":
            self._render_loot(tree, data)
        elif dtype == "widget":
            self._render_widget(tree, data)
        elif dtype == "strings":
            self._render_strings(tree, data)
        else:
            self._render_prefab(tree, data)

        console.print(Panel(tree, border_style="green"))
        input("æŒ‰å›è½¦è¿”å›...")

    # === å­æ¸²æŸ“å™¨ (Renderers) ===

    def _render_loot(self, tree, data):
        """æ¸²æŸ“æ‰è½è¡¨æ•°æ®"""
        if data.get('table_name'):
            tree.add(f"ğŸ“œ è¡¨å: [bold gold1]{data['table_name']}[/bold gold1]")
        
        entries = data.get('entries', [])
        if entries:
            branch = tree.add(f"ğŸ’° æ‰è½é¡¹ ({len(entries)})")
            for item in entries:
                if item.get('method') == 'Random':
                    branch.add(f"[cyan]{item['item']}[/cyan]: æƒé‡ [yellow]{item['weight']}[/yellow]")
                else:
                    chance = item.get('chance', 0)
                    branch.add(f"[cyan]{item['item']}[/cyan]: å‡ ç‡ [magenta]{chance}[/magenta]")

    def _render_widget(self, tree, data):
        """æ¸²æŸ“ UI Widget æ•°æ®"""
        if data.get('classes'):
            c_branch = tree.add("ğŸ§© UI ç±»å®šä¹‰")
            for c in data['classes']:
                c_branch.add(f"[bold white]{c['name']}[/bold white] (extends [dim]{c['parent']}[/dim])")
        
        if data.get('dependencies'):
            d_branch = tree.add("ğŸ”— ä¾èµ–æ¨¡å—")
            for d in data['dependencies']:
                d_branch.add(f"[dim]{d}[/dim]")

    def _render_strings(self, tree, data):
        """æ¸²æŸ“æ–‡æœ¬é…ç½®æ•°æ®"""
        if data.get('includes'):
            tree.add(f"ğŸ“¥ å¼•å…¥æ–‡ä»¶: {', '.join(data['includes'])}")
        
        if data.get('roots'):
            r_branch = tree.add("ğŸ”¤ æ–‡æœ¬æ ¹èŠ‚ç‚¹ (Roots)")
            for root in data['roots']:
                r_branch.add(f"STRINGS.[bold yellow]{root}[/bold yellow]")

    def _render_prefab(self, tree, data):
        """æ¸²æŸ“å®ä½“ Prefab æ•°æ® (åŒ…å« Tuning å¢å¼º)"""
        # 1. èµ„æº
        if data.get('assets'):
            asset_branch = tree.add(f"ğŸ“¦ èµ„æºå¼•ç”¨ ({len(data['assets'])})")
            for a in data['assets']:
                style = "magenta" if "Anim" in a['type'] else "blue"
                asset_branch.add(f"[{style}]{a['type']}[/{style}]: {a['path']}")

        # 2. é€»è¾‘ (Brain/SG/Tags)
        logic_branch = tree.add("ğŸ§  æ ¸å¿ƒé€»è¾‘")
        has_logic = False
        if data.get('brain'): 
            logic_branch.add(f"AI: [magenta]{data['brain']}[/magenta]")
            has_logic = True
        if data.get('stategraph'): 
            logic_branch.add(f"SG: [magenta]{data['stategraph']}[/magenta]")
            has_logic = True
        if data.get('tags'): 
            tags = data['tags']
            tag_str = ", ".join([f"[dim]{t}[/dim]" for t in tags[:8]])
            if len(tags) > 8: tag_str += "..."
            logic_branch.add(f"Tags: {tag_str}")
            has_logic = True
        if not has_logic: logic_branch.label = "[dim]ğŸ§  æ ¸å¿ƒé€»è¾‘ (æ— )[/dim]"

        # 3. ç»„ä»¶ (ä½¿ç”¨ Engine çš„ Tuning è¿›è¡Œå¢å¼º)
        if data.get('components'):
            comp_branch = tree.add(f"âš™ï¸ åŠŸèƒ½ç»„ä»¶ ({len(data['components'])})")
            for comp in data['components']:
                node = comp_branch.add(f"[bold yellow]{comp['name']}[/bold yellow]")
                
                # å±æ€§
                if comp['properties']:
                    target = node if len(comp['properties']) <=3 else node.add("[dim]å±æ€§é…ç½®[/dim]")
                    for p in comp['properties']:
                        # ä½¿ç”¨ Engine ä¼ å…¥çš„ Tuning è¿›è¡Œå¢å¼º
                        p_text = self.engine.tuning.enrich(p) if self.engine.tuning else p
                        target.add(f"[cyan]{p_text}[/cyan]")
                
                # æ–¹æ³•
                if comp['methods']:
                    target = node if len(comp['methods']) <=3 else node.add("[dim]å‡½æ•°è°ƒç”¨[/dim]")
                    for m in comp['methods']:
                        # ä½¿ç”¨ Engine ä¼ å…¥çš„ Tuning è¿›è¡Œå¢å¼º
                        m_text = self.engine.tuning.enrich(m) if self.engine.tuning else m
                        target.add(f"[green]Æ’[/green] {m_text}")
        else:
            tree.add("[dim]âš™ï¸ åŠŸèƒ½ç»„ä»¶ (æ— )[/dim]")

    def preview_file(self):
        """æ–‡ä»¶é¢„è§ˆå…¥å£"""
        target = Prompt.ask("[bold green]ğŸ‘€ æ–‡ä»¶å[/bold green]")
        path = self.engine.find_file(target, fuzzy=True)
        if not path:
            console.print("[red]æœªæ‰¾åˆ°[/red]")
            return
        
        console.print(f"[yellow]æ‰“å¼€: {path}[/yellow]")
        content = self.engine.read_file(path)
        
        if content:
            # åªæ˜¾ç¤ºå‰ 50 è¡Œä»¥ä¾›æ¦‚è§ˆ
            syntax = Syntax("\n".join(content.splitlines()[:50]), "lua", theme="monokai", line_numbers=True)
            console.print(Panel(syntax, title=f"{path} (Top 50 lines)", border_style="blue"))
            
            action = Prompt.ask("[bold cyan]æ“ä½œ[/bold cyan]", choices=["q", "a"], default="q")
            if action == "a":
                self.analyze_content(path, content)

    def show_tuning(self):
        """å±•ç¤º Tuning æ ·æœ¬"""
        if not self.engine.tuning: 
            return console.print("[red]Tuning æœªåŠ è½½[/red]")
        
        console.print("[bold magenta]ğŸ”¢ Tuning æ•°å€¼é‡‡æ ·[/bold magenta]")
        count = 0
        for k, v in list(self.engine.tuning.raw_map.items())[:10]:
             console.print(f"  [cyan]{k}[/cyan] = {v}")
             count += 1

def main():
    explorer = DSTExplorer()
    while True:
        console.print("\n[bold white on blue] ğŸ¦ Wagstaff æ¢ç´¢é¢æ¿ v3.1 [/bold white on blue]")
        console.print("1. [bold]ğŸ“ ç»“æ„[/]  2. [bold]ğŸ” æœç´¢[/]  3. [bold]ğŸ‘€ é¢„è§ˆ&åˆ†æ[/]  4. [bold]ğŸ”¢ æ•°å€¼[/]  0. [bold red]é€€å‡º[/]")
        choice = IntPrompt.ask("é€‰æ‹©", choices=["0","1","2","3","4"], default=1)
        if choice == 0: break
        elif choice == 1: console.print(explorer.get_structure_tree())
        elif choice == 2: explorer.search_files()
        elif choice == 3: explorer.preview_file()
        elif choice == 4: explorer.show_tuning()

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        console.print(f"[red]Error: {e}[/red]")
```

### File: src/guide.py
- mode: full
- size_bytes: 1548
- sha256_12: b69213e54f5e

```py
#!/usr/bin/env python3
import os
import sys
import json
from rich.console import Console
from rich.panel import Panel
from rich.table import Table
from pathlib import Path

# å¼•å…¥é…ç½®å’Œæ³¨å†Œè¡¨
sys.path.append(os.path.dirname(os.path.abspath(__file__)))
from registry import get_tools

console = Console()
PROJECT_ROOT = Path(__file__).resolve().parent.parent

def load_status():
    status_path = PROJECT_ROOT / "PROJECT_STATUS.json"
    if status_path.exists():
        with open(status_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    return {}

def main():
    data = load_status()
    
    console.print(Panel("[bold white on blue] ğŸ§ª Wagstaff-Lab (v2.2) æ§åˆ¶å° [/bold white on blue]", border_style="blue"))
    
    if "objective" in data:
        console.print(f"[bold green]ğŸ¯ å½“å‰ç›®æ ‡:[/bold green] {data['objective']}")
    
    # å¢åŠ  Usage åˆ—çš„å±•ç¤º
    console.print("\n[bold yellow]ğŸ› ï¸  å·¥å…·ç®±ä½¿ç”¨æŒ‡å—[/bold yellow]")
    table = Table(box=None, show_header=True, header_style="bold cyan")
    table.add_column("å·¥å…·", style="bold")
    table.add_column("æè¿°")
    table.add_column("æ ‡å‡†ç”¨æ³• (Usage)", style="green")
    
    for tool in get_tools():
        table.add_row(
            tool['file'], 
            tool['desc'], 
            tool.get('usage', 'N/A')
        )

    console.print(table)
    console.print("\n[dim]ğŸ’¡ è¾“å…¥ [bold]pm ui[/bold] ç®¡ç†ä»»åŠ¡ï¼Œè¾“å…¥ [bold]wagstaff snap[/bold] æ›´æ–°å¿«ç…§ã€‚[/dim]")

if __name__ == "__main__":
    main()
```

### File: src/registry.py
- mode: full
- size_bytes: 2339
- sha256_12: 12dac7d17279

```py
#!/usr/bin/env python3
"""
Wagstaff-Lab å·¥å…·æ³¨å†Œä¸­å¿ƒ (v2.3)
"""

TOOLS = [
    # --- æ ¸å¿ƒ/ä¸šåŠ¡å·¥å…· (src/) ---
    {
        "file": "guide.py",
        "alias": None,
        "desc": "Wagstaff-Lab æ§åˆ¶å°ä¸»é¢æ¿",
        "usage": "Wagstaff-Lab",
        "type": "Core"
    },
    {
        "file": "doctor.py",
        "alias": "doctor",
        "desc": "ç¯å¢ƒé…ç½®ä¸ä¾èµ–å¥åº·æ£€æŸ¥",
        "usage": "wagstaff doctor",
        "type": "Src"
    },
    {
        "file": "wiki.py",
        "alias": "wiki",
        "desc": "ç‰©å“/é…æ–¹/æ•°å€¼æŸ¥è¯¢ç™¾ç§‘",
        "usage": "wagstaff wiki <item_code>",
        "type": "Src"
    },
    {
        "file": "explorer.py",
        "alias": "exp",
        "desc": "æºç ç»“æ„æµè§ˆä¸æ·±åº¦åˆ†æ",
        "usage": "wagstaff exp",
        "type": "Src"
    },

    # --- å¼€å‘å·¥å…· (devtools/) ---
    {
        "file": "pm.py",
        "alias": "pm",
        "desc": "é¡¹ç›®è¿›åº¦ä¸ä»»åŠ¡ç®¡ç†",
        "usage": "pm [ui|obj|add|done|log]",
        "type": "Dev",
        "folder": "devtools"
    },
    {
        "file": "reporter.py",
        "alias": "report",
        "desc": "ç”Ÿæˆå…¨æœèµ„äº§/é…æ–¹åˆ†å¸ƒæŠ¥å‘Š",
        "usage": "wagstaff report [assets|recipes|all]",
        "type": "Dev",
        "folder": "devtools"
    },
    {
        "file": "snapshot.py",
        "alias": "snap",
        "desc": "ç”Ÿæˆé¡¹ç›®å…¨æ¯ä»£ç å¿«ç…§",
        "usage":  "wagstaff snap [--mode core|full|custom] [--config conf/snapshot_profile.json]",
        "type": "Dev",
        "folder": "devtools"
    },
    {
        "file": "installer.py",
        "alias": "install",
        "desc": "ç¯å¢ƒæ³¨å†Œä¸å®‰è£…å‘å¯¼",
        "usage": "python3 devtools/installer.py",
        "type": "Dev",
        "folder": "devtools"
    },
    {
        "file": "sampler.py",
        "alias": "samples",
        "desc": "ç”Ÿæˆ DST Lua æ ·æœ¬åŒ…ï¼ˆç”¨äºæ‰©å±•è§£æå™¨ï¼‰",
        "usage": "wagstaff samples [--categories ...] [--n N] [--head-lines N] ...",
        "type": "Dev",
        "folder": "devtools"
    },
    {
        "file": "codemap.py",
        "alias": "map",
        "desc": "ç”Ÿæˆ DST scripts å®è§‚ç»“æ„åœ°å›¾æŠ¥å‘Š",
        "usage": "wagstaff map",
        "type": "Dev",
        "folder": "devtools"
    },
]

def get_tools():
    return TOOLS
```

### File: src/utils.py
- mode: full
- size_bytes: 1040
- sha256_12: ffc01cb3d8f3

```py
import configparser
import os
from pathlib import Path

class ConfigLoader:
    def __init__(self):
        # è‡ªåŠ¨å®šä½é¡¹ç›®æ ¹ç›®å½• (å‡è®¾ utils.py åœ¨ src/ ä¸‹)
        self.project_root = Path(__file__).resolve().parent.parent
        self.config_path = self.project_root / "conf" / "settings.ini"
        
        self.config = configparser.ConfigParser()
        if not self.config_path.exists():
            raise FileNotFoundError(f"âŒ é…ç½®æ–‡ä»¶ä¸¢å¤±: {self.config_path}")
        
        self.config.read(self.config_path)

    def get(self, section, key):
        """è·å–é…ç½®å€¼å¹¶è‡ªåŠ¨å±•å¼€ç”¨æˆ·è·¯å¾„ (~)"""
        val = self.config.get(section, key, fallback=None)
        if val and "~" in val:
            return os.path.expanduser(val)
        return val

# å•ä¾‹æ¨¡å¼ï¼šç›´æ¥å¯¼å‡ºçš„å®ä¾‹
wagstaff_config = ConfigLoader()

# === æµ‹è¯•ä»£ç  ===
if __name__ == "__main__":
    print(f"Project Root: {wagstaff_config.project_root}")
    print(f"DST Path: {wagstaff_config.get('PATHS', 'DST_ROOT')}")
```

### File: src/wiki.py
- mode: full
- size_bytes: 8796
- sha256_12: d7709d0e1f1b

```py
#!/usr/bin/env python3
import sys
import re
import os
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.tree import Tree
from rich.markdown import Markdown

# æŒ‚è½½ src ç›®å½•ä»¥å¯¼å…¥æ ¸å¿ƒæ¨¡å—
sys.path.append(os.path.dirname(os.path.abspath(__file__)))
from engine import WagstaffEngine
from analyzer import LuaAnalyzer, LootParser, PrefabParser

console = Console()

class WagstaffWiki:
    def __init__(self):
        try:
            self.engine = WagstaffEngine(load_db=True)
            # console.print(f"[dim]Wiki å¼•æ“å·²è¿æ¥ (æ–‡ä»¶æ•°: {len(self.engine.file_list)})[/dim]")
        except Exception as e:
            console.print(f"[red]å¼•æ“åˆå§‹åŒ–å¤±è´¥: {e}[/red]")
            sys.exit(1)

    def run(self, args):
        if not args:
            self._print_help()
            return

        command = args[0].lower()
        query = args[1] if len(args) > 1 else None

        if command == "recipe":
            self._search_recipe(query)
        elif command == "mob" or command == "item":
            self._analyze_prefab(query)
        elif command == "loot":
            self._find_loot_table(query)
        elif command == "find":
            self._global_search(query)
        else:
            self._print_help()

    def _print_help(self):
        console.print(Panel("""
[bold cyan]ğŸ“– Wagstaff Wiki v2.0[/bold cyan]

[green]bin/wagstaff wiki recipe <ç‰©å“å>[/green]   æŸ¥è¯¢é…æ–¹ (æ”¯æŒæ¨¡ç³ŠåŒ¹é…)
[green]bin/wagstaff wiki mob <ç”Ÿç‰©å>[/green]      æŸ¥è¯¢ç”Ÿç‰©/ç‰©å“è¯¦æƒ… (å±æ€§ã€ç»„ä»¶)
[green]bin/wagstaff wiki loot <è¡¨å>[/green]       [bold yellow]ğŸ”¥ æŸ¥è¯¢æ‰è½è¡¨/æ‰è½ç‡[/bold yellow]
[green]bin/wagstaff wiki find <å…³é”®è¯>[/green]     å…¨å±€ä»£ç æœç´¢
""", title="Help", border_style="blue"))

    def _search_recipe(self, query):
        if not query: return console.print("[red]è¯·è¾“å…¥ç‰©å“åç§°[/red]")
        
        real_name, recipe_data = self.engine.recipes.get(query)
        
        if not recipe_data:
            # æ¨¡ç³Šæœç´¢
            candidates = [k for k in self.engine.recipes.recipes.keys() if query in k]
            if not candidates:
                return console.print(f"[red]æœªæ‰¾åˆ°é…æ–¹: {query}[/red]")
            if len(candidates) > 1:
                console.print(f"[yellow]å¯èƒ½çš„åŒ¹é…: {', '.join(candidates[:5])}...[/yellow]")
                return
            real_name, recipe_data = self.engine.recipes.get(candidates[0])

        grid = Table.grid(expand=True)
        grid.add_column()
        grid.add_column(justify="right")
        
        # æ ‡é¢˜è¡Œ
        tab_info = recipe_data.get('tab', 'UNKNOWN').replace("RECIPETABS.", "")
        grid.add_row(f"[bold gold1]{real_name.upper()}[/bold gold1]", f"[dim]{tab_info}[/dim]")
        
        # ç§‘æŠ€éœ€æ±‚
        tech = recipe_data.get('tech', 'UNKNOWN').replace("TECH.", "")
        grid.add_row(f"[bold]ç§‘æŠ€:[/bold] {tech}", "")
        
        # ææ–™åˆ—è¡¨
        grid.add_row("\n[bold]æ‰€éœ€ææ–™:[/bold]")
        for ing in recipe_data.get('ingredients', []):
            grid.add_row(f"  â€¢ [cyan]{ing['item']}[/cyan]", f"[yellow]x{ing['amount']}[/yellow]")
            
        console.print(Panel(grid, title="ğŸ› ï¸  é…æ–¹è¯¦æƒ…", border_style="gold1"))

    def _analyze_prefab(self, query):
        """åˆ†æ Prefab ç»„ä»¶ç»“æ„ (å¢å¼ºç‰ˆ: æ˜¾ç¤ºå±æ€§ä¸æ•°å€¼)"""
        if not query: return console.print("[red]è¯·è¾“å…¥åç§°[/red]")
        
        filepath = self.engine.find_file(query, fuzzy=True)
        if not filepath:
            return console.print(f"[red]æœªæ‰¾åˆ°æ–‡ä»¶: {query}[/red]")

        content = self.engine.read_file(filepath)
        report = LuaAnalyzer(content).get_report()
        
        tree = Tree(f"ğŸ§¬ [bold green]å®ä½“æƒ…æŠ¥: {os.path.basename(filepath)}[/bold green]")
        
        # ä½¿ç”¨ Tuning å¢å¼ºæ•°å€¼æ˜¾ç¤º
        tuning = self.engine.tuning

        if report.get('components'):
            comp_branch = tree.add("âš™ï¸ å…³é”®ç»„ä»¶")
            for comp in report['components']:
                c_name = comp['name']
                # åªæœ‰å½“ç»„ä»¶æœ‰å†…å®¹æ—¶æ‰å±•å¼€ï¼Œæˆ–è€…æ˜¯æ ¸å¿ƒç»„ä»¶
                has_content = comp.get('properties') or comp.get('methods')
                
                style = "bold yellow"
                # é«˜äº®æ ¸å¿ƒæ•°å€¼ç»„ä»¶
                if c_name in ['weapon', 'health', 'hunger', 'sanity', 'armor', 'lootdropper']:
                    style = "bold magenta"
                
                node_text = f"[{style}]{c_name}[/{style}]"
                
                if not has_content:
                    comp_branch.add(node_text)
                    continue
                
                comp_node = comp_branch.add(node_text)
                
                # 1. æ˜¾ç¤ºå±æ€§
                for prop in comp.get('properties', []):
                    val_text = tuning.enrich(prop) if tuning else prop
                    comp_node.add(f"[dim]â€¢[/dim] {val_text}")

                # 2. æ˜¾ç¤ºæ–¹æ³•
                for method in comp.get('methods', []):
                    val_text = tuning.enrich(method) if tuning else method
                    
                    # å…³é”®æ–¹æ³•é«˜äº®
                    if any(k in method for k in ["SetDamage", "SetMaxHealth", "SetArmor"]):
                        comp_node.add(f"[bold green]Æ’ {val_text}[/bold green]")
                    elif "SetChanceLootTable" in method or "SetSharedLootTable" in method:
                        comp_node.add(f"[bold red]Æ’ {val_text}[/bold red]")
                    else:
                        comp_node.add(f"[dim]Æ’[/dim] {val_text}")

        console.print(Panel(tree, border_style="green"))
        console.print(f"\nğŸ’¡ æç¤º: è‹¥å‘ç° [red]SetChanceLootTable('NAME')[/red]ï¼Œ\nè¯·è¿è¡Œ: [bold cyan]bin/wagstaff wiki loot NAME[/bold cyan] æŸ¥çœ‹æ‰è½ç‡")

    def _find_loot_table(self, query):
        """
        å…¨åº“æ‰«æ + LootParser å¼ºåŠ›è§£æ
        """
        if not query: return console.print("[red]è¯·è¾“å…¥æ‰è½è¡¨åç§° (ä¾‹å¦‚: krampus)[/red]")
        
        console.print(f"[dim]æ­£åœ¨å…¨åº“æœç´¢æ‰è½è¡¨: '{query}' ...[/dim]")
        
        # ç‰¹å¾ç : SetSharedLootTable('NAME'
        pattern = re.compile(r'SetSharedLootTable\s*\(\s*[\'"]' + re.escape(query) + r'[\'"]')
        
        found = False
        for filepath in self.engine.file_list:
            if not filepath.endswith(".lua"): continue
            
            content = self.engine.read_file(filepath)
            if not content: continue
            
            if pattern.search(content):
                self._render_loot_table(filepath, query, content)
                found = True
                break 
        
        if not found:
            console.print(f"[red]æœªæ‰¾åˆ°æ‰è½è¡¨å®šä¹‰: '{query}'[/red]")
            console.print("[dim]æç¤ºï¼šæœ‰äº›æ‰è½æ˜¯ä»£ç åŠ¨æ€ç”Ÿæˆçš„ï¼Œæˆ–è€…è¡¨åä¸å®ä½“åä¸ä¸€è‡´ã€‚[/dim]")

    def _render_loot_table(self, filepath, table_name, content):
        console.print(f"[bold green]âœ… æ‰¾åˆ°å®šä¹‰æ–‡ä»¶: {filepath}[/bold green]")
        
        # å¼ºåˆ¶ä½¿ç”¨ LootParser è§£æè¯¥æ–‡ä»¶
        parser = LootParser(content)
        data = parser.parse()
        
        if not data['entries']:
            console.print("[yellow]è§£æå™¨æœªèƒ½æå–åˆ°å…·ä½“ç‰©å“é¡¹ (å¯èƒ½æ˜¯å¤æ‚çš„åŠ¨æ€é€»è¾‘)ã€‚[/yellow]")
            return

        table = Table(title=f"ğŸ’° æ‰è½è¡¨: {table_name}", box=None)
        table.add_column("ç‰©å“ (Prefab)", style="cyan")
        table.add_column("å‡ ç‡ / æƒé‡", style="magenta")
        table.add_column("ç±»å‹", style="dim")

        for entry in data['entries']:
            val_str = ""
            if 'chance' in entry:
                # æ ¼å¼åŒ–ç™¾åˆ†æ¯”
                pct = entry['chance'] * 100
                if pct < 1: val_str = f"{pct:.2f}%"
                else: val_str = f"{pct:.0f}%"
            elif 'weight' in entry:
                val_str = f"æƒé‡ {entry['weight']}"
            
            table.add_row(entry['item'], val_str, entry['method'])

        console.print(Panel(table, border_style="gold1"))

    def _global_search(self, query):
        if not query: return
        count = 0
        console.print(f"[dim]æœç´¢ '{query}'...[/dim]")
        for f in self.engine.file_list:
            content = self.engine.read_file(f)
            if content and query in content:
                console.print(f"ğŸ“„ {f}")
                count += 1
                if count >= 10:
                    console.print("[dim]...ç»“æœè¿‡å¤šï¼Œä»…æ˜¾ç¤ºå‰ 10 ä¸ª[/dim]")
                    break

if __name__ == "__main__":
    WagstaffWiki().run(sys.argv[1:])
```

### File: tests/test_recipes.py
- mode: full
- size_bytes: 1479
- sha256_12: 89bad0a5e326

```py
#!/usr/bin/env python3
import sys
import time
from rich.console import Console
from rich.table import Table
from engine import WagstaffEngine

console = Console()

def main():
    console.print("[bold blue]ğŸ§ª é…æ–¹è§£æå™¨éªŒæ”¶æµ‹è¯• (åŸºäº Wagstaff Engine)[/bold blue]")
    
    # 1. å¯åŠ¨å¼•æ“
    try:
        start_t = time.time()
        engine = WagstaffEngine(load_db=True)
        duration = (time.time() - start_t) * 1000
    except Exception as e:
        console.print(f"[red]å¼•æ“å¯åŠ¨å¤±è´¥: {e}[/red]")
        return
    
    # 2. ç»Ÿè®¡
    count = len(engine.recipes.recipes)
    count_style = "green" if count > 500 else "red"
    
    console.print(f"åŠ è½½è€—æ—¶: [bold]{duration:.2f} ms[/bold]")
    console.print(f"å‘ç°é…æ–¹: [{count_style}]{count}[/{count_style}]")

    # 3. æŠ½æŸ¥
    check_list = ["spear", "armorwood", "hambat", "firestaff"]
    table = Table(title="å…³é”®ç‰©å“éªŒè¯", border_style="blue")
    table.add_column("Key", style="cyan")
    table.add_column("Name", style="dim")
    table.add_column("Ingredients", style="white")
    
    for item in check_list:
        real_name, data = engine.recipes.get(item)
        if data:
            ing_str = ", ".join([f"{i['item']}x{i['amount']}" for i in data['ingredients']])
            table.add_row(item, real_name, ing_str)
        else:
            table.add_row(item, "-", "[red]Not Found[/red]")
        
    console.print(table)

if __name__ == "__main__":
    main()
```

## 6. Snapshot Stats
```yaml
total_candidates: 156
included_records: 38
embedded_files: 33
max_total_bytes: 20000000
bytes_remaining: 19585577
```
