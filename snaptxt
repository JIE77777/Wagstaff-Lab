# Wagstaff-Lab Project Snapshot

- Generated: 2026-01-14T14:22:11
- Mode: custom
- Template: gui

## 0. Effective Template Config
```json
{
  "mode": "custom",
  "template": "gui",
  "config_file": "conf/snapshot_templates.json",
  "output": "snaptxt",
  "zip": {
    "enabled": false,
    "output": null
  },
  "redact_enabled": true,
  "limits": {
    "max_file_bytes": 200000,
    "max_total_bytes": 1200000
  },
  "tree": {
    "max_depth": 8,
    "max_entries_per_dir": 250
  },
  "glob_semantics": {
    "**": "matches 0..N path segments"
  },
  "include_globs": [
    "**/*",
    ".gitignore",
    "conf/samples/**/*",
    "conf/settings.ini",
    "conf/snapshot_templates.json",
    "data/**/*",
    "data/index/**/*",
    "devtools/**/*",
    "docs/**/*",
    "src/**/*",
    "src/doctor.py",
    "src/explorer.py",
    "src/klei_atlas_tex.py",
    "src/registry.py",
    "src/wiki.py"
  ],
  "ignore_dirs": [
    ".git",
    ".idea",
    ".pytest_cache",
    ".vscode",
    "__pycache__",
    "build",
    "dist",
    "env",
    "logs",
    "node_modules",
    "venv"
  ],
  "ignore_files": [
    ".DS_Store",
    "id_ed25519",
    "id_rsa",
    "known_hosts",
    "project_context.txt",
    "snaptxt"
  ],
  "ignore_globs": [
    "data/snapshots/**",
    "**/*.swp",
    "**/*.swo",
    "**/*.tmp",
    "**/*.bak",
    "**/*.log",
    "**/*.zip",
    "**/*.tar",
    "**/*.tar.gz",
    "**/*.gz",
    "**/*.7z",
    "**/*.rar",
    "**/*.png",
    "**/*.jpg",
    "**/*.jpeg",
    "**/*.webp",
    "**/*.pdf",
    "**/*.mp4",
    "**/*.mov",
    "**/*.sqlite",
    "**/*.db",
    "**/.env",
    "**/.env.*",
    "**/*.pem",
    "**/*.key",
    "snaptxt",
    "data/reports/**"
  ],
  "rules": [
    {
      "match": "data/reports/recipe_distribution.md",
      "mode": "skip"
    },
    {
      "match": "data/reports/catalog_summary.md",
      "mode": "skip"
    },
    {
      "match": "data/reports/asset_registry.md",
      "mode": "skip"
    },
    {
      "match": "data/reports/dst_codemap.json",
      "mode": "skip"
    },
    {
      "match": "data/reports/dst_codemap.md",
      "mode": "skip"
    },
    {
      "match": "conf/snapshot_templates.json",
      "mode": "interface"
    },
    {
      "match": "src/klei_atlas_tex.py",
      "mode": "interface"
    },
    {
      "match": "bin/.dst_tool.sh.swp",
      "mode": "skip"
    },
    {
      "match": "conf/settings.ini",
      "mode": "interface"
    },
    {
      "match": "bin/Wagstaff-Lab",
      "mode": "skip"
    },
    {
      "match": "bin/dst_tool.sh",
      "mode": "skip"
    },
    {
      "match": "src/explorer.py",
      "mode": "interface"
    },
    {
      "match": "src/registry.py",
      "mode": "interface"
    },
    {
      "match": "src/doctor.py",
      "mode": "interface"
    },
    {
      "match": "bin/wagstaff",
      "mode": "skip"
    },
    {
      "match": "src/guide.py",
      "mode": "skip"
    },
    {
      "match": "bin/boot.sh",
      "mode": "skip"
    },
    {
      "match": "src/wiki.py",
      "mode": "interface"
    },
    {
      "match": "bin/pm",
      "mode": "skip"
    },
    {
      "match": "PROJECT_STATUS.json",
      "mode": "skip"
    },
    {
      "match": ".gitignore",
      "mode": "interface"
    },
    {
      "match": "README.md",
      "mode": "skip"
    },
    {
      "match": "setup.sh",
      "mode": "skip"
    },
    {
      "match": "data/snapshots/**",
      "mode": "skip"
    },
    {
      "match": "conf/samples/**",
      "mode": "interface"
    },
    {
      "match": "data/reports/**",
      "mode": "skip"
    },
    {
      "match": "data/samples/**",
      "mode": "skip"
    },
    {
      "match": "data/static/**",
      "mode": "skip"
    },
    {
      "match": "data/index/**",
      "mode": "head",
      "head_lines": 200
    },
    {
      "match": "devtools/**",
      "mode": "interface"
    },
    {
      "match": "tests/**",
      "mode": "skip"
    },
    {
      "match": "conf/**",
      "mode": "skip"
    },
    {
      "match": "data/**",
      "mode": "interface"
    },
    {
      "match": "docs/**",
      "mode": "interface"
    },
    {
      "match": "bin/**",
      "mode": "skip"
    },
    {
      "match": "src/**",
      "mode": "full"
    },
    {
      "match": "**/*",
      "mode": "interface"
    }
  ]
}
```

## 1. Environment Diagnostics
```yaml
Time: 2026-01-14 14:22:11
User: steam
Host: VM-8-2-ubuntu (Linux 6.8.0-49-generic)
Python: 3.10.19 (/home/steam/miniconda3/envs/dst_lab/bin/python3)
Rich Ver: Installed (ver unknown)
--------------------
Branch: main [DIRTY]
Commit: 29a8665
Message: feat: Release v2.3 Interactive Wiki, Deep Parsing & Tooling Fixes- Wiki: 新增 'find' 交互式 TUI 翻页模式，优化配方与实体详情展示
- Analyzer: 实现 Tuning 递归数值追踪，支持内联掉落表解析 (LootParser)
- Tooling: pm.py 重写，支持 JSON 结构自动迁移 (v1->v2) 并增强健壮性
- Docs: 更新项目状态与发布日志
```

## 2. Project Overview
### 2.1 Toolbox (src/registry.py)
```text
alias   | file         | type | desc                    | usage                                           
--------+--------------+------+-------------------------+-------------------------------------------------
        | guide.py     | Core | Wagstaff-Lab 控制台主面板     | Wagstaff-Lab                                    
doctor  | doctor.py    | Src  | 环境配置与依赖健康检查             | wagstaff doctor                                 
wiki    | wiki.py      | Src  | 物品/配方/数值查询百科            | wagstaff wiki <item_code>                       
exp     | explorer.py  | Src  | 源码结构浏览与深度分析             | wagstaff exp                                    
pm      | pm.py        | Dev  | 项目进度与任务管理               | pm [ui|obj|add|done|log]                        
report  | reporter.py  | Dev  | 生成全服资产/配方分布报告           | wagstaff report [assets|recipes|all]            
snap    | snapshot.py  | Dev  | 生成项目全息代码快照              | wagstaff snapshot [-h] [--mode {core,archive,...
install | installer.py | Dev  | 环境注册与安装向导               | python3 devtools/installer.py                   
samples | sampler.py   | Dev  | 生成 DST Lua 样本包（用于扩展解析器） | wagstaff samples [--categories ...] [--n N] [...
map     | codemap.py   | Dev  | 生成 DST scripts 宏观结构地图报告 | wagstaff map                                    
```

### 2.2 Project Context (PROJECT_STATUS.json)
```text
OBJECTIVE: None
```

## 3. Project Structure
```text
├── .gitignore
├── bin
│   ├── boot.sh
│   ├── dst_tool.sh
│   ├── pm
│   ├── wagstaff
│   └── Wagstaff-Lab
├── conf
│   ├── samples
│   │   └── parse_other_data.json
│   ├── settings.ini
│   └── snapshot_templates.json
├── data
│   ├── index
│   │   ├── wagstaff_catalog_v1.json
│   │   └── wagstaff_icon_index_v1.json
│   ├── samples
│   │   ├── samples_20260113_105500.manifest.json
│   │   ├── samples_20260113_105500.md
│   │   ├── samples_20260113_112749.manifest.json
│   │   └── samples_20260113_112749.md
│   └── static
│       └── icons
├── devtools
│   ├── build_catalog.py
│   ├── build_icons.py
│   ├── codemap.py
│   ├── hotfix_add_write_png.py
│   ├── installer.py
│   ├── pm.py
│   ├── reporter.py
│   ├── sampler.py
│   ├── serve_webcraft.py
│   ├── snapshot.py
│   └── snapshot_gui.py
├── docs
│   └── WEBCRAFT_NETWORK_STACK.md
├── PROJECT_STATUS.json
├── README.md
├── setup.sh
├── src
│   ├── analyzer.py
│   ├── catalog.py
│   ├── craft_recipes.py
│   ├── doctor.py
│   ├── engine.py
│   ├── explorer.py
│   ├── guide.py
│   ├── klei_atlas_tex.py
│   ├── registry.py
│   ├── utils.py
│   ├── webcraft
│   │   ├── __init__.py
│   │   ├── api.py
│   │   ├── app.py
│   │   ├── catalog_store.py
│   │   ├── cooking_planner.py
│   │   ├── icon_service.py
│   │   ├── planner.py
│   │   ├── settings.py
│   │   └── ui.py
│   └── wiki.py
└── tests
    └── test_recipes.py
```

## 4. File Inventory
(mode: full/interface/head/skip; '*' means truncated; note: binary / omitted reason)

```text
mode       | bytes   | sha256_12    | note | path                                              
-----------+---------+--------------+------+---------------------------------------------------
interface  | 299     | f97f702d84fd |      | .gitignore                                        
skip       | 1939    | -            |      | PROJECT_STATUS.json                               
skip       | 2786    | -            |      | README.md                                         
skip       | 65      | -            |      | bin/Wagstaff-Lab                                  
skip       | 2250    | -            |      | bin/boot.sh                                       
skip       | 12532   | -            |      | bin/dst_tool.sh                                   
skip       | 67      | -            |      | bin/pm                                            
skip       | 824     | -            |      | bin/wagstaff                                      
interface  | 2204    | 6091b29bdccc |      | conf/samples/parse_other_data.json                
interface  | 353     | 15952c921af7 |      | conf/settings.ini                                 
interface* | 12505   | a4eb9316f27b |      | conf/snapshot_templates.json                      
head*      | 1024820 | c6a6a12d29eb |      | data/index/wagstaff_catalog_v1.json               
head*      | 488446  | a85738c72094 |      | data/index/wagstaff_icon_index_v1.json            
skip       | 3455    | -            |      | data/samples/samples_20260113_105500.manifest.json
skip       | 98207   | -            |      | data/samples/samples_20260113_105500.md           
skip       | 2006    | -            |      | data/samples/samples_20260113_112749.manifest.json
skip       | 40900   | -            |      | data/samples/samples_20260113_112749.md           
interface  | 4189    | bbfc33a27ce7 |      | devtools/build_catalog.py                         
interface  | 16405   | 8c2800d90ef3 |      | devtools/build_icons.py                           
interface  | 6311    | 8332f5211c1f |      | devtools/codemap.py                               
interface  | 1994    | d6d6dc118a4b |      | devtools/hotfix_add_write_png.py                  
interface  | 3586    | b1feb4cd296f |      | devtools/installer.py                             
interface  | 6674    | a18caa6ebf79 |      | devtools/pm.py                                    
interface  | 4763    | 915b1577a0aa |      | devtools/reporter.py                              
interface  | 14604   | 2eaf081041e4 |      | devtools/sampler.py                               
interface  | 4062    | 3395631ff1ab |      | devtools/serve_webcraft.py                        
interface  | 35360   | 2d197e4ae5ab |      | devtools/snapshot.py                              
interface  | 39382   | 752390a28683 |      | devtools/snapshot_gui.py                          
interface  | 1583    | ba49b13920f7 |      | docs/WEBCRAFT_NETWORK_STACK.md                    
skip       | 896     | -            |      | setup.sh                                          
full       | 46782   | ab8c988fde24 |      | src/analyzer.py                                   
full       | 13843   | 1f52f9d1d4a7 |      | src/catalog.py                                    
full       | 28228   | 5ff8c02ec0af |      | src/craft_recipes.py                              
interface  | 7012    | 69d9d480c023 |      | src/doctor.py                                     
full       | 13329   | b04e61d84e94 |      | src/engine.py                                     
interface  | 9616    | 6f0febfb5667 |      | src/explorer.py                                   
skip       | 1548    | -            |      | src/guide.py                                      
interface  | 17056   | 9e1cb85f9889 |      | src/klei_atlas_tex.py                             
interface  | 2414    | 49f94a18019d |      | src/registry.py                                   
full       | 1040    | ffc01cb3d8f3 |      | src/utils.py                                      
full       | 252     | f9cfb37ca166 |      | src/webcraft/__init__.py                          
full       | 8945    | 79ceaa2dbc56 |      | src/webcraft/api.py                               
full       | 3182    | 7fbd2457c16e |      | src/webcraft/app.py                               
full       | 18993   | 3ac3aa7e06ab |      | src/webcraft/catalog_store.py                     
full       | 4276    | bd00afb78bbe |      | src/webcraft/cooking_planner.py                   
full       | 8219    | b4af2b1b0d25 |      | src/webcraft/icon_service.py                      
full       | 3808    | a9ac339eaf54 |      | src/webcraft/planner.py                           
full       | 790     | b2f5722e0c36 |      | src/webcraft/settings.py                          
full       | 42263   | 60813cc8836b |      | src/webcraft/ui.py                                
interface  | 22283   | 98e8c40fe7ba |      | src/wiki.py                                       
skip       | 1479    | -            |      | tests/test_recipes.py                             
```

## 5. File Contents

### File: .gitignore
- mode: interface
- size_bytes: 299
- sha256_12: f97f702d84fd

```
# 忽略 Python 缓存
__pycache__/
*.py[cod]

# 忽略日志
logs/*

# 忽略个人配置 (保留模板)
conf/settings.ini
!conf/settings.ini.example

# 忽略虚拟环境 (如果你把 env 建在项目里)
env/
venv/
.conda/

# 忽略系统文件
.DS_Store
/bin/wagstaff
/bin/pm
/bin/Wagstaff-Lab
```

### File: conf/samples/parse_other_data.json
- mode: interface
- size_bytes: 2204
- sha256_12: 6091b29bdccc

```json
{
  "name": "parse_other_data",
  "description": "Samples for expanding analyzer beyond prefab/recipe: STRINGS, Widgets, Brains, Stategraphs, LootTables, Components.",
  "limits": {
    "max_total_chars": 260000,
    "max_chars_per_file": 18000
  },
  "defaults": {
    "head_lines": 120,
    "snippet_blocks": 10,
    "context_lines": 4
  },
  "categories": [
    {
      "name": "STRINGS",
      "pick_n": 2,
      "candidate_globs": ["scripts/strings.lua", "scripts/*strings*.lua", "scripts/strings_pretranslated.lua"],
      "rank_patterns": ["\\bSTRINGS\\s*=", "\\bSTRINGS\\.[A-Z0-9_]+"],
      "snippet_patterns": ["\\bSTRINGS\\.[A-Z0-9_]+\\s*=", "\\bSTRINGS\\.[A-Z0-9_]+"]
    },
    {
      "name": "Widgets",
      "pick_n": 2,
      "candidate_globs": ["scripts/widgets/**/*.lua", "scripts/screens/**/*.lua"],
      "rank_patterns": ["require\\s*\\(?\\s*[\"']widgets/", "Class\\("],
      "snippet_patterns": ["require\\s*\\(?\\s*[\"']widgets/", "Class\\(", "Widget\\("]
    },
    {
      "name": "Brains",
      "pick_n": 2,
      "candidate_globs": ["scripts/prefabs/**/*.lua", "scripts/brains/**/*.lua"],
      "rank_patterns": ["require\\s*\\(?\\s*[\"']brains/", "SetBrain\\s*\\("],
      "snippet_patterns": ["require\\s*\\(?\\s*[\"']brains/", "SetBrain\\s*\\("]
    },
    {
      "name": "Stategraphs",
      "pick_n": 2,
      "candidate_globs": ["scripts/stategraphs/**/*.lua"],
      "rank_patterns": ["StateGraph\\(", "ActionHandler\\("],
      "snippet_patterns": ["StateGraph\\(", "ActionHandler\\(", "EventHandler\\("]
    },
    {
      "name": "LootTables",
      "pick_n": 2,
      "candidate_globs": ["scripts/prefabs/**/*.lua", "scripts/components/lootdropper.lua"],
      "rank_patterns": ["SetLoot\\s*\\(", "SetChanceLoot\\s*\\(", "AddChanceLoot\\s*\\("],
      "snippet_patterns": ["SetLoot\\s*\\(", "SetChanceLoot\\s*\\(", "AddChanceLoot\\s*\\(", "DropLoot\\s*\\("]
    },
    {
      "name": "Components",
      "pick_n": 2,
      "candidate_globs": ["scripts/components/**/*.lua"],
      "rank_patterns": ["\\bClass\\(", "\\bfunction\\s+[A-Za-z0-9_]+:"],
      "snippet_patterns": ["\\bClass\\(", "\\bfunction\\s+[A-Za-z0-9_]+:"],
      "head_lines": 200
    }
  ]
}
```

### File: conf/settings.ini
- mode: interface
- size_bytes: 353
- sha256_12: 15952c921af7

```toml
[PATHS]
# 游戏安装目录
DST_ROOT = ~/dontstarvetogether_dedicated_server
# SteamCMD 目录
STEAMCMD_DIR = ~/steamcmd
# 备份存放目录
BACKUP_DIR = ~/dst_backups

[SERVER]
# 你的存档文件夹名 (Cluster Name)
CLUSTER_NAME = MyDediServer
# Klei 存档根目录 (通常是 ~/.klei/DoNotStarveTogether)
KLEI_HOME = ~/.klei/DoNotStarveTogether
```

### File: conf/snapshot_templates.json
- mode: interface
- size_bytes: 12505
- sha256_12: a4eb9316f27b
- note: TRUNCATED

```json
{
  "version": 1,
  "defaults": {
    "mode_to_template": {
      "core": "core",
      "archive": "archive",
      "custom": "gui"
    },
    "notes": [
      "规则按顺序匹配：第一条命中即生效（first-match-wins）。",
      "match 使用 glob（相对项目根目录），示例：src/**/*.py。",
      "mode 支持：full | interface | head | skip。",
      "head 模式默认导出前 head_lines 行。",
      "interface 仅对 .py 做 AST 接口提取；其他文件降级为 head。",
      "archive 模板默认会额外生成 zip 归档（make_zip=true）。"
    ]
  },
  "templates": {
    "core": {
      "desc": "LLM-friendly snapshot：核心业务代码完整 + 非核心接口/头部，包含项目全貌与进度。",
      "output": "project_context.txt",
      "redact": true,
      "include_reports": true,
      "max_file_bytes": 200000,
      "max_total_bytes": 1500000,
      "tree": {
        "max_depth": 8,
        "max_entries_per_dir": 250
      },
      "include_globs": [
        "README.md",
        "PROJECT_STATUS.json",
        ".gitignore",
        "conf/**/*.ini",
        "src/**/*.py",
        "devtools/**/*.py",
        "tests/**/*.py",
        "bin/**",
        "data/reports/**/*.md",
        "data/samples/**/*"
      ],
      "ignore_files": [
        "project_context.txt",
        ".DS_Store",
        "id_rsa",
        "id_ed25519",
        "known_hosts"
      ],
      "ignore_globs": [
        "data/snapshots/**",
        "**/*.swp",
        "**/*.swo",
        "**/*.tmp",
        "**/*.bak",
        "**/*.log",
        "**/*.zip",
        "**/*.tar",
        "**/*.tar.gz",
        "**/*.gz",
        "**/*.7z",
        "**/*.rar",
        "**/*.png",
        "**/*.jpg",
        "**/*.jpeg",
        "**/*.webp",
        "**/*.pdf",
        "**/*.mp4",
        "**/*.mov",
        "**/*.sqlite",
        "**/*.db",
        "**/.env",
        "**/.env.*",
        "**/*.pem",
        "**/*.key"
      ],
      "rules": [
        {
          "match": "devtools/snapshot.py",
          "mode": "full"
        },
        {
          "match": "src/engine.py",
          "mode": "full"
        },
        {
          "match": "src/analyzer.py",
          "mode": "full"
        },
        {
          "match": "src/explorer.py",
          "mode": "full"
        },
        {
          "match": "src/wiki.py",
          "mode": "full"
        },
        {
          "match": "src/registry.py",
          "mode": "full"
        },
        {
          "match": "src/**/*.py",
          "mode": "full"
        },
        {
          "match": "devtools/**/*.py",
          "mode": "interface"
        },
        {
          "match": "tests/**/*.py",
          "mode": "head",
          "head_lines": 220
        },
        {
          "match": "bin/**",
          "mode": "head",
          "head_lines": 160
        },
        {
          "match": "conf/**",
          "mode": "full"
        },
        {
          "match": "data/reports/**/*.md",
          "mode": "head",
          "head_lines": 260
        },
        {
          "match": "data/samples/**/*.md",
          "mode": "head",
          "head_lines": 340
        },
        {
          "match": "data/samples/**/*.json",
          "mode": "head",
          "head_lines": 160
        },
        {
          "match": "*.md",
          "mode": "head",
          "head_lines": 240
        },
        {
          "match": "*.txt",
          "mode": "head",
          "head_lines": 240
        },
        {
          "match": "**/*",
          "mode": "skip"
        }
      ]
    },
    "archive": {
      "desc": "Archival snapshot：尽量完整导出 + 生成 zip 归档（适合长期留存/回溯）。",
      "output": "data/snapshots/archive_{timestamp}.md",
      "make_zip": true,
      "zip_output": "data/snapshots/archive_{timestamp}.zip",
      "redact": true,
      "include_reports": true,
      "max_file_bytes": 500000,
      "max_total_bytes": 20000000,
      "tree": {
        "max_depth": 30,
        "max_entries_per_dir": 1000
      },
      "include_globs": [
        "**/*"
      ],
      "ignore_files": [
        "project_context.txt",
        ".DS_Store",
        "id_rsa",
        "id_ed25519",
        "known_hosts"
      ],
      "ignore_globs": [
        "data/snapshots/**",
        "**/*.swp",
        "**/*.swo",
        "**/*.tmp",
        "**/*.bak",
        "**/*.log",
        "**/*.zip",
        "**/*.tar",
        "**/*.tar.gz",
        "**/*.gz",
        "**/*.7z",
        "**/*.rar",
        "**/*.png",
        "**/*.jpg",
        "**/*.jpeg",
        "**/*.webp",
        "**/*.pdf",
        "**/*.mp4",
        "**/*.mov",
        "**/*.sqlite",
        "**/*.db",
        "**/.env",
        "**/.env.*",
```

### File: data/index/wagstaff_catalog_v1.json
- mode: head
- size_bytes: 1024820
- sha256_12: c6a6a12d29eb
- note: TRUNCATED

```json
{
  "schema_version": 1,
  "meta": {
    "schema": 1,
    "engine_mode": "zip",
    "scripts_file_count": 3915,
    "scripts_zip": "/home/steam/dontstarvetogether_dedicated_server/data/databundles/scripts.zip",
    "scripts_sha256_12": "b975ad93d5d8",
    "assets_count": 1055
  },
  "craft": {
    "schema": 1,
    "recipes": {
      "lighter": {
        "name": "lighter",
        "product": "lighter",
        "ingredients": [
          {
            "item": "rope",
            "amount": "1",
            "amount_num": 1.0
          },
          {
            "item": "goldnugget",
            "amount": "1",
            "amount_num": 1.0
          },
          {
            "item": "petals",
            "amount": "3",
            "amount_num": 3.0
          }
        ],
        "ingredients_unresolved": [],
        "tech": "TECH.NONE",
        "tab": "LIGHT",
        "filters": [
          "CHARACTER",
          "COOKING",
          "LIGHT"
        ],
        "builder_tag": "pyromaniac",
        "builder_tags": [
          "pyromaniac"
        ],
        "builder_skill": null,
        "station_tag": null,
        "sources": [
          "Recipe2"
        ],
        "image": null,
        "atlas": null,
        "placer": null,
        "nounlock": null,
        "numtogive": null
      },
      "bernie_inactive": {
        "name": "bernie_inactive",
        "product": "bernie_inactive",
        "ingredients": [
          {
            "item": "beardhair",
            "amount": "2",
            "amount_num": 2.0
          },
          {
            "item": "beefalowool",
            "amount": "2",
            "amount_num": 2.0
          },
          {
            "item": "silk",
            "amount": "2",
            "amount_num": 2.0
          }
        ],
        "ingredients_unresolved": [],
        "tech": "TECH.NONE",
        "tab": "CHARACTER",
        "filters": [
          "CHARACTER"
        ],
        "builder_tag": "pyromaniac",
        "builder_tags": [
          "pyromaniac"
        ],
        "builder_skill": null,
        "station_tag": null,
        "sources": [
          "Recipe2"
        ],
        "image": null,
        "atlas": null,
        "placer": null,
        "nounlock": null,
        "numtogive": null
      },
      "portablecookpot_item": {
        "name": "portablecookpot_item",
        "product": "portablecookpot_item",
        "ingredients": [
          {
            "item": "goldnugget",
            "amount": "2",
            "amount_num": 2.0
          },
          {
            "item": "charcoal",
            "amount": "6",
            "amount_num": 6.0
          },
          {
            "item": "twigs",
            "amount": "6",
            "amount_num": 6.0
          }
        ],
        "ingredients_unresolved": [],
        "tech": "TECH.NONE",
        "tab": "COOKING",
        "filters": [
          "CHARACTER",
          "COOKING"
        ],
        "builder_tag": "masterchef",
        "builder_tags": [
          "masterchef"
        ],
        "builder_skill": null,
        "station_tag": null,
        "sources": [
          "Recipe2"
        ],
        "image": null,
        "atlas": null,
        "placer": null,
        "nounlock": null,
        "numtogive": null
      },
      "portableblender_item": {
        "name": "portableblender_item",
        "product": "portableblender_item",
        "ingredients": [
          {
            "item": "goldnugget",
            "amount": "2",
            "amount_num": 2.0
          },
          {
            "item": "transistor",
            "amount": "2",
            "amount_num": 2.0
          },
          {
            "item": "twigs",
            "amount": "4",
            "amount_num": 4.0
          }
        ],
        "ingredients_unresolved": [],
        "tech": "TECH.NONE",
        "tab": "COOKING",
        "filters": [
          "CHARACTER",
          "COOKING"
        ],
        "builder_tag": "masterchef",
        "builder_tags": [
          "masterchef"
        ],
        "builder_skill": null,
        "station_tag": null,
        "sources": [
          "Recipe2"
        ],
        "image": null,
        "atlas": null,
        "placer": null,
        "nounlock": null,
        "numtogive": null
      },
      "portablespicer_item": {
        "name": "portablespicer_item",
        "product": "portablespicer_item",
        "ingredients": [
          {
            "item": "goldnugget",
            "amount": "2",
            "amount_num": 2.0
          },
          {
            "item": "cutstone",
            "amount": "3",
            "amount_num": 3.0
          },
          {
            "item": "twigs",
            "amount": "6",
            "amount_num": 6.0
          }
```

### File: data/index/wagstaff_icon_index_v1.json
- mode: head
- size_bytes: 488446
- sha256_12: a85738c72094
- note: TRUNCATED

```json
{
  "schema": 1,
  "source": {
    "images_zip": "/home/steam/dontstarvetogether_dedicated_server/data/databundles/images.zip"
  },
  "count": 2099,
  "icons": {
    "abigail_flower_ancient": {
      "png": "data/static/icons/abigail_flower_ancient.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_ancient.tex"
    },
    "abigail_flower_ancient_level0": {
      "png": "data/static/icons/abigail_flower_ancient_level0.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_ancient_level0.tex"
    },
    "abigail_flower_ancient_level2": {
      "png": "data/static/icons/abigail_flower_ancient_level2.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_ancient_level2.tex"
    },
    "abigail_flower_ancient_level3": {
      "png": "data/static/icons/abigail_flower_ancient_level3.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_ancient_level3.tex"
    },
    "abigail_flower_creepy": {
      "png": "data/static/icons/abigail_flower_creepy.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_creepy.tex"
    },
    "abigail_flower_creepy_level0": {
      "png": "data/static/icons/abigail_flower_creepy_level0.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_creepy_level0.tex"
    },
    "abigail_flower_creepy_level2": {
      "png": "data/static/icons/abigail_flower_creepy_level2.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_creepy_level2.tex"
    },
    "abigail_flower_creepy_level3": {
      "png": "data/static/icons/abigail_flower_creepy_level3.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_creepy_level3.tex"
    },
    "abigail_flower_formal": {
      "png": "data/static/icons/abigail_flower_formal.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_formal.tex"
    },
    "abigail_flower_formal_level0": {
      "png": "data/static/icons/abigail_flower_formal_level0.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_formal_level0.tex"
    },
    "abigail_flower_formal_level2": {
      "png": "data/static/icons/abigail_flower_formal_level2.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_formal_level2.tex"
    },
    "abigail_flower_formal_level3": {
      "png": "data/static/icons/abigail_flower_formal_level3.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_formal_level3.tex"
    },
    "abigail_flower_funeral": {
      "png": "data/static/icons/abigail_flower_funeral.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_funeral.tex"
    },
    "abigail_flower_funeral_level0": {
      "png": "data/static/icons/abigail_flower_funeral_level0.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_funeral_level0.tex"
    },
    "abigail_flower_funeral_level2": {
      "png": "data/static/icons/abigail_flower_funeral_level2.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_funeral_level2.tex"
    },
    "abigail_flower_funeral_level3": {
      "png": "data/static/icons/abigail_flower_funeral_level3.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_funeral_level3.tex"
    },
    "abigail_flower_gladiator": {
      "png": "data/static/icons/abigail_flower_gladiator.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_gladiator.tex"
    },
    "abigail_flower_gladiator_level0": {
      "png": "data/static/icons/abigail_flower_gladiator_level0.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_gladiator_level0.tex"
    },
    "abigail_flower_gladiator_level2": {
      "png": "data/static/icons/abigail_flower_gladiator_level2.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_gladiator_level2.tex"
    },
    "abigail_flower_gladiator_level3": {
      "png": "data/static/icons/abigail_flower_gladiator_level3.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_gladiator_level3.tex"
    },
    "abigail_flower_handmedown": {
      "png": "data/static/icons/abigail_flower_handmedown.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_handmedown.tex"
    },
    "abigail_flower_handmedown_level0": {
      "png": "data/static/icons/abigail_flower_handmedown_level0.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_handmedown_level0.tex"
    },
    "abigail_flower_handmedown_level2": {
      "png": "data/static/icons/abigail_flower_handmedown_level2.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_handmedown_level2.tex"
    },
    "abigail_flower_handmedown_level3": {
      "png": "data/static/icons/abigail_flower_handmedown_level3.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_handmedown_level3.tex"
    },
    "abigail_flower_ice": {
      "png": "data/static/icons/abigail_flower_ice.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_ice.tex"
    },
    "abigail_flower_ice_level0": {
      "png": "data/static/icons/abigail_flower_ice_level0.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_ice_level0.tex"
    },
    "abigail_flower_ice_level2": {
      "png": "data/static/icons/abigail_flower_ice_level2.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_ice_level2.tex"
    },
    "abigail_flower_ice_level3": {
      "png": "data/static/icons/abigail_flower_ice_level3.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_ice_level3.tex"
    },
    "abigail_flower_level0": {
      "png": "data/static/icons/abigail_flower_level0.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_level0.tex"
    },
    "abigail_flower_level2": {
      "png": "data/static/icons/abigail_flower_level2.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_level2.tex"
    },
    "abigail_flower_level3": {
      "png": "data/static/icons/abigail_flower_level3.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_level3.tex"
    },
    "abigail_flower_lunar": {
      "png": "data/static/icons/abigail_flower_lunar.png",
      "atlas_xml": "images/inventoryimages1.xml",
      "tex": "images/inventoryimages1.tex",
      "element": "abigail_flower_lunar.tex"
    },
    "abigail_flower_lunar_level0": {
```

### File: devtools/build_catalog.py
- mode: interface
- size_bytes: 4189
- sha256_12: bbfc33a27ce7

```py
"""devtools/build_catalog.py"""

# Constants
PROJECT_ROOT = Path(__file__).resolve().parent.parent

def _write_summary(path: Path, catalog: WagstaffCatalog) -> None:
    ...

def cmd_build(args: argparse.Namespace) -> int:
    ...

def build_parser() -> argparse.ArgumentParser:
    ...

def main(argv: list[str] | None=None) -> int:
    ...
```

### File: devtools/build_icons.py
- mode: interface
- size_bytes: 16405
- sha256_12: 8c2800d90ef3

```py
"""Build PNG inventory icons for WebCraft/Wiki."""

# Constants
PROJECT_ROOT = Path(__file__).resolve().parent.parent

class AtlasElement:
    ...

def _expand(p: Optional[str]) -> Optional[str]:
    ...

def _load_ini_dst_root(ini_path: Optional[str]) -> Optional[str]:
    ...

def _infer_images_zip_from_catalog(catalog: Dict) -> Optional[str]:
    ...

def _infer_images_zip(dst_root: Optional[str]) -> Optional[str]:
    ...

def _read_json(path: str) -> Dict:
    ...

def _collect_item_ids_from_catalog(catalog: Dict) -> List[str]:
    ...

def _candidate_element_names(item_id: str) -> List[str]:
    """DST inventory atlas element names commonly include ".tex"."""

def _normalize_elem_key(name: str) -> str:
    ...

def _strip_tex_suffix(name: str) -> str:
    ...

def _build_atlas_index_from_images_zip(z: zipfile.ZipFile, atlas_xml_patterns: Sequence[str]) -> Dict[str, List[AtlasElement]]:
    """Return: element_name_key -> [AtlasElement...]"""

def _crop_from_uv(tex_img, u1: float, v1: float, u2: float, v2: float):
    """Klei atlas v coordinates are bottom-up in practice for DST inventory atlases."""

def _ensure_dir(p: str) -> None:
    ...

def _default_out_dirs() -> Tuple[str, str]:
    ...

def main() -> None:
    ...
```

### File: devtools/codemap.py
- mode: interface
- size_bytes: 6311
- sha256_12: 8332f5211c1f

```py
"""Wagstaff-Lab DST Code Map (Report)"""

# Constants
PROJECT_ROOT = Path(__file__).resolve().parent.parent
REPORT_DIR = PROJECT_ROOT / 'data' / 'reports'

def _now_iso() -> str:
    ...

def _file_size(engine: WagstaffEngine, path: str) -> int:
    ...

def build_codemap(engine: WagstaffEngine) -> Dict[str, object]:
    ...

def render_md(doc: Dict[str, object]) -> str:
    ...

def main() -> None:
    ...
```

### File: devtools/hotfix_add_write_png.py
- mode: interface
- size_bytes: 1994
- sha256_12: d6d6dc118a4b

```py
"""Hotfix: add write_png() to src/klei_atlas_tex.py if missing."""

def main() -> int:
    ...
```

### File: devtools/installer.py
- mode: interface
- size_bytes: 3586
- sha256_12: b1feb4cd296f

```py
# Constants
CURRENT_FILE = Path(__file__).resolve()
PROJECT_ROOT = CURRENT_FILE.parent.parent
BIN_DIR = PROJECT_ROOT / 'bin'
SRC_DIR = PROJECT_ROOT / 'src'
DEV_DIR = PROJECT_ROOT / 'devtools'

def get_shell_config():
    ...

def create_wrappers():
    ...

def register_to_path():
    ...

def main():
    ...
```

### File: devtools/pm.py
- mode: interface
- size_bytes: 6674
- sha256_12: a18caa6ebf79

```py
# Constants
PROJECT_ROOT = Path(__file__).resolve().parent.parent
DATA_FILE = PROJECT_ROOT / 'PROJECT_STATUS.json'

class ProjectManager:
    ...
    def load(self):
    def _init_empty(self):
    def _migrate_schema(self, old_data):  # 自动迁移逻辑：将 v1 (tasks list) 数据转换为 v2 (TODO/DONE lists)
    def save(self):
    def show_status(self):
    def run_command(self, cmd_str):
    def interactive_mode(self):
    def cli_mode(self, args):

def main():
    ...
```

### File: devtools/reporter.py
- mode: interface
- size_bytes: 4763
- sha256_12: 915b1577a0aa

```py
# Constants
CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.dirname(CURRENT_DIR)
REPORT_DIR = os.path.join(PROJECT_ROOT, 'data', 'reports')

class WagstaffReporter:
    ...
    def _ensure_report_dir(self):
    def generate_asset_report(self):  # 扫描全服资产分布
    def generate_recipe_report(self):  # 扫描配方分布
```

### File: devtools/sampler.py
- mode: interface
- size_bytes: 14604
- sha256_12: 2eaf081041e4

```py
"""Wagstaff-Lab Sample Pack Generator"""

# Constants
PROJECT_ROOT = Path(__file__).resolve().parent.parent
OUT_DIR = PROJECT_ROOT / 'data' / 'samples'
REPORT_DIR = PROJECT_ROOT / 'data' / 'reports'
DEFAULT_CATEGORIES = ['STRINGS', 'Widgets', 'Brains', 'Stategraphs', 'LootTables', 'Components']

def _now_iso() -> str:
    ...

def _now_ts() -> str:
    ...

def _sha256_12_text(text: str) -> str:
    ...

def _safe_read_asset_registry(path: Path) -> Dict[str, List[str]]:
    """Parse data/reports/asset_registry.md into {Category: [file1, file2, ...]}."""

def _file_size(engine: WagstaffEngine, path: str) -> int:
    ...

def _choose_files(engine: WagstaffEngine, category: str, n: int, registry_map: Dict[str, List[str]], rng: random.Random) -> List[str]:
    ...

def _pick_snippet_lines(lines: List[str], patterns: Sequence[re.Pattern], snippet_blocks: int, context_lines: int, rng: random.Random) -> List[Tuple[int, int]]:
    """Return a list of (start_idx, end_idx_exclusive) ranges."""

def _render_snippet(lines: List[str], start: int, end: int) -> str:
    ...

def _cap_text(text: str, max_chars: int) -> Tuple[str, bool]:
    ...

class FileSample:
    ...

def build_sample_pack(categories: List[str], n_files_per_category: int, head_lines: int, snippet_blocks: int, context_lines: int, max_chars_per_file: int, max_total_chars: int, seed: int) -> Tuple[str, Dict[str, object]]:
    ...

def main() -> None:
    ...
```

### File: devtools/serve_webcraft.py
- mode: interface
- size_bytes: 4062
- sha256_12: 3395631ff1ab

```py
"""Run WebCraft server (FastAPI + Uvicorn)."""

# Constants
PROJECT_ROOT = Path(__file__).resolve().parent.parent

def _detect_lan_ip() -> str:
    """Best-effort LAN IP discovery (no external network required)."""

def main() -> None:
    ...
```

### File: devtools/snapshot.py
- mode: interface
- size_bytes: 35360
- sha256_12: 2d197e4ae5ab

```py
"""Wagstaff-Lab Snapshot (v4.1)"""

# Constants
PROJECT_ROOT = Path(__file__).resolve().parent.parent
DEFAULT_CONFIG = PROJECT_ROOT / 'conf' / 'snapshot_templates.json'
DEFAULT_IGNORE_DIRS = {'.git', '__pycache__', '.pytest_cache', 'logs', 'env', 'venv', '.idea', '.vs...
DEFAULT_IGNORE_FILES = {'project_context.txt', '.DS_Store', 'id_rsa', 'id_ed25519', 'known_hosts'}
DEFAULT_IGNORE_GLOBS = ['data/snapshots/**', '**/*.swp', '**/*.swo', '**/*.tmp', '**/*.bak', '**/*.l...
BUILTIN_TEMPLATES = {'core': {'desc': 'Builtin core template', 'output': 'project_context.txt', '...
_SECRET_KV_RE = re.compile('(?i)\\b(password|passphrase|token|secret|api[_-]?key|client[_-]?s...

class FileRecord:
    ...

def _now_ts() -> str:
    ...

def _run_cmd(cmd: str) -> str:
    ...

def get_system_fingerprint() -> str:
    ...

def get_git_status() -> str:
    ...

def _is_probably_binary(path: Path) -> bool:
    ...

def _redact(text: str) -> str:
    ...

def _sha256_12(path: Path) -> str:
    ...

def _posix_rel(path: Path) -> str:
    ...

def _match_glob(rel_posix: str, pattern: str) -> bool:
    """Glob match for POSIX relative paths."""

def _load_templates(config_path: Path) -> Dict[str, Any]:
    ...

def _resolve_template(templates_doc: Dict[str, Any], mode: str, template_name: Optional[str]) -> Tuple[str, Dict[str, Any]]:
    ...

def _render_effective_template_config(*, args_mode: str, tpl_name: str, cfg_path: Path, output_path: Path, zip_path: Optional[Path], make_zip: bool, redact_enabled: bool, include_globs: List[str], ignore_files: set[str], ignore_globs: List[str], ignore_dirs: set[str], rules: List[Dict[str, Any]], max_file_bytes: int, max_total_bytes: int, tree_max_depth: int, tree_max_entries: int) -> str:
    """Render the fully-resolved template config for this run (for debug/repro)."""

def _ensure_parent(path: Path) -> None:
    ...

def _iter_candidates(include_globs: List[str]) -> List[Path]:
    ...

def _should_ignore(path: Path, ignore_files: set[str], ignore_globs: List[str], ignore_dirs: set[str]) -> bool:
    ...

def _pick_rule(rel_posix: str, rules: List[Dict[str, Any]]) -> Dict[str, Any]:
    ...

def _read_text_limited(path: Path, max_bytes: int) -> Tuple[str, bool]:
    ...

def _read_head_lines(path: Path, head_lines: int) -> Tuple[str, bool]:
    ...

def _safe_unparse(node: ast.AST) -> str:
    ...

def _format_args(args: ast.arguments) -> str:
    ...

def _first_doc_line(doc: Optional[str], max_len: int=120) -> str:
    ...

def _extract_python_interface(path: Path, max_chars: int=40000) -> str:
    ...

def _render_tree(root: Path, prefix: str, depth: int, max_depth: int, max_entries: int, ignore_dirs: set[str], ignore_files: set[str], ignore_globs: List[str]) -> str:
    ...

def _extract_registry_tools() -> Optional[List[Dict[str, Any]]]:
    ...

def _render_tools_overview(tools: Optional[List[Dict[str, Any]]]) -> str:
    ...

def _render_project_status() -> str:
    ...

def _render_file_inventory(records: List[FileRecord], limit: int=500) -> str:
    ...

def _write_zip(zip_path: Path, records: List[FileRecord]) -> None:
    ...

def main() -> None:
    ...
```

### File: devtools/snapshot_gui.py
- mode: interface
- size_bytes: 39382
- sha256_12: 752390a28683

```py
"""snapshot_gui.py"""

# Constants
MODE_FULL = 'full'
MODE_INTERFACE = 'interface'
MODE_HEAD = 'head'
MODE_SKIP = 'skip'
MODE_LABELS = {MODE_FULL: 'Full', MODE_INTERFACE: 'Interface', MODE_HEAD: 'Head', MODE_SKIP...
MODE_COLOR_TAG = {MODE_FULL: 'mode_full', MODE_INTERFACE: 'mode_interface', MODE_HEAD: 'mode_h...
_WILDCARD_CHARS_RE = re.compile('[*?\\[]')

def _find_project_root(start: Path) -> Path:
    """Best-effort project root discovery."""

def _guess_snapshot_py(project_root: Path) -> Optional[Path]:
    """Locate snapshot.py inside the project."""

def _load_snapshot_defaults(project_root: Path, snapshot_py: Optional[Path]) -> Tuple[set[str], set[str], List[str], Dict[str, Any]]:
    """Try to import snapshot.py to reuse DEFAULT_IGNORE_* and BUILTIN_TEMPLATES."""

class ModeSpec:
    ...
    def to_rule(self) -> Dict[str, Any]:

def _is_glob_like(pat: str) -> bool:
    ...

def _as_posix_rel(project_root: Path, abs_path: Path) -> str:
    ...

def _specificity_key(match_pat: str) -> Tuple[int, int, int]:
    """Sorting key for rules: more specific first."""

def _safe_int(s: str, default: int) -> int:
    ...

class SnapshotGUI(tk.Tk):
    ...
    def _build_styles(self) -> None:
    def _build_ui(self) -> None:
    def _status_text(self) -> str:
    def _rebuild_tree(self) -> None:
    def _on_open_node(self, event: tk.Event) -> None:
    def _populate_children_if_needed(self, item: str) -> None:
    def _populate_children(self, parent_item: str) -> None:
    def _effective_spec(self, rel: str) -> ModeSpec:  # Inheritance:
    def _update_item_display(self, item: str) -> None:
    def _update_loaded_subtree(self, item: str) -> None:
    def _on_select(self, event: tk.Event) -> None:
    def _selected_rels(self) -> List[str]:
    def _apply_mode(self, mode: str) -> None:
    def _clear_override(self) -> None:
    def _on_right_click(self, event: tk.Event) -> None:
    def _build_template_dict(self) -> Dict[str, Any]:  # Convert current GUI state into snapshot.py template dict.
    def _load_config_doc(self) -> Dict[str, Any]:
    def _merge_and_write_config(self, tpl_name: str, tpl_dict: Dict[str, Any]) -> None:
    def _save_config(self) -> None:
    def _preview_json(self) -> None:
    def _run_snapshot(self) -> None:
    def _try_load_existing_gui_template(self) -> None:  # Best-effort load:

def main() -> None:
    ...
```

### File: docs/WEBCRAFT_NETWORK_STACK.md
- mode: interface
- size_bytes: 1583
- sha256_12: ba49b13920f7

```md
# WebCraft 网络基建（FastAPI/ASGI）

目标：把 Web/GUI Craft 从“临时 stdlib server”升级为可扩展的系统级服务基座。

## 选型
- ASGI 框架：FastAPI
- 服务器：Uvicorn
- 中间件：GZip、可选 CORS
- 数据源：data/index/wagstaff_catalog_v1.json（M2 索引产物）

## 目录结构
- src/webcraft/
  - app.py          FastAPI app factory
  - api.py          REST API 路由（/api/v1）
  - catalog_store.py  catalog 装载 + 内存索引
  - planner.py      craft planner（inventory -> craftable/missing）
  - ui.py           单页 UI（零构建）
  - settings.py     配置结构

- devtools/serve_webcraft.py  开发/部署启动器

## 启动
```bash
python3 devtools/serve_webcraft.py --host 0.0.0.0 --port 20000 --no-open
```

## 反向代理挂载（root_path）
若挂载在 /webcraft：
```bash
python3 devtools/serve_webcraft.py --root-path /webcraft --host 0.0.0.0 --port 20000
```

UI 与 API 都使用相同 root_path 前缀，前端以相对路径访问 `/api/v1/...`，避免 0.0.0.0 导致的跨机器交互失败。

## API
- GET /api/v1/meta
- GET /api/v1/craft/filters
- GET /api/v1/craft/tabs
- GET /api/v1/craft/tags
- GET /api/v1/craft/recipes/search?q=...
- GET /api/v1/craft/recipes/{name}
- POST /api/v1/craft/plan
- POST /api/v1/craft/missing

## 后续扩展建议
- 引入 “station/tech/skill tree” 规则：只扩展 planner + API，不改 UI 架构
- catalog 改为 SQLite：CatalogStore 层替换为 SQLiteStore（API/UI 无需变化）
- 加 websocket/SSE：用于索引重建、长任务进度推送
```

### File: src/analyzer.py
- mode: full
- size_bytes: 46782
- sha256_12: ab8c988fde24

```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Lua parsing primitives + domain analyzers for Wagstaff-Lab.

Core goals
- Robust scanning: skip comments/strings/long-brackets.
- Balanced parsing: brackets + Lua block keywords (function/if/for/while/repeat/do/end/until).
- Practical AST-lite: parse Lua table constructors into (array, map) for data-driven extraction.
- Extract function calls with balanced parentheses (supports member calls obj:Method()).

Public API (intended stable)
- strip_lua_comments(text) -> str
- split_top_level(text, sep=',') -> List[str]
- find_matching(text, open_idx, open_ch, close_ch) -> Optional[int]
- parse_lua_string(expr) -> Optional[str]
- parse_lua_expr(expr) -> Any
- parse_lua_table(inner) -> LuaTableValue
- LuaCallExtractor(content).iter_calls(...)
- TuningResolver(content)
- LuaAnalyzer(content, path=None).get_report()
- CookingRecipeAnalyzer(content).recipes
"""

from __future__ import annotations

import bisect
import re
from dataclasses import dataclass
from typing import Any, Dict, Iterator, List, Optional, Sequence, Tuple, Union

__all__ = [
    # scanning helpers
    "strip_lua_comments",
    "split_top_level",
    "find_matching",
    # expr parsing
    "parse_lua_string",
    "parse_lua_expr",
    "parse_lua_table",
    "LuaRaw",
    "LuaTableValue",
    "lua_to_python",
    # call extraction
    "LuaCall",
    "LuaCallExtractor",
    # tuning
    "TuningResolver",
    # domain parsers
    "LootParser",
    "WidgetParser",
    "StringParser",
    "PrefabParser",
    "LuaAnalyzer",
    # cooking
    "CookingRecipeAnalyzer",
]


# ============================================================
# 0) Low-level Lua scanning helpers
# ============================================================

_LUA_KEYWORDS = {
    "and", "break", "do", "else", "elseif", "end", "false", "for", "function", "goto",
    "if", "in", "local", "nil", "not", "or", "repeat", "return", "then", "true", "until", "while",
}


def _is_ident_start(ch: str) -> bool:
    return ch == "_" or ("A" <= ch <= "Z") or ("a" <= ch <= "z")


def _is_ident_char(ch: str) -> bool:
    return _is_ident_start(ch) or ("0" <= ch <= "9")


def _long_bracket_level(text: str, i: int) -> Optional[int]:
    """
    If text[i:] starts a Lua long-bracket opener: [=*[ , return '=' count; else None.
    Examples: [[ -> 0, [=[ -> 1, [==[ -> 2
    """
    n = len(text)
    if i >= n or text[i] != "[":
        return None
    j = i + 1
    while j < n and text[j] == "=":
        j += 1
    if j < n and text[j] == "[":
        return j - i - 1
    return None


def _skip_long_bracket(text: str, i: int, level: int) -> int:
    """Skip Lua long-bracket string/comment starting at i. Return next index."""
    n = len(text)
    opener_len = 2 + level
    start = i + opener_len
    close_pat = "]" + ("=" * level) + "]"
    end = text.find(close_pat, start)
    if end == -1:
        return n
    return end + len(close_pat)


def _skip_short_string(text: str, i: int, quote: str) -> int:
    """Skip '...' or "...", supporting backslash escapes. Return next index."""
    n = len(text)
    i += 1
    while i < n:
        ch = text[i]
        if ch == "\\":
            i += 2
            continue
        if ch == quote:
            return i + 1
        i += 1
    return n


def _skip_comment(text: str, i: int) -> int:
    """i points at '-' and text[i:i+2]=='--'. Skip a line or block comment. Return next index."""
    n = len(text)
    if not text.startswith("--", i):
        return i

    # Block comment: --[=*[ ... ]=*]
    if i + 2 < n and text[i + 2] == "[":
        level = _long_bracket_level(text, i + 2)
        if level is not None:
            return _skip_long_bracket(text, i + 2, level)

    # Line comment
    nl = text.find("\n", i + 2)
    return n if nl == -1 else nl + 1


def _skip_string_or_long_string(text: str, i: int) -> Optional[int]:
    """If position i starts a string/long-string, return next index; else None."""
    if i >= len(text):
        return None
    ch = text[i]
    if ch in ("'", '"'):
        return _skip_short_string(text, i, ch)
    if ch == "[":
        level = _long_bracket_level(text, i)
        if level is not None:
            return _skip_long_bracket(text, i, level)
    return None


def strip_lua_comments(text: str) -> str:
    """
    Remove Lua comments while preserving line breaks (keeps line numbers stable).
    Strings/long-strings are preserved.
    """
    if not text:
        return ""
    n = len(text)
    out: List[str] = []
    i = 0
    while i < n:
        if text.startswith("--", i):
            j = _skip_comment(text, i)
            out.append("\n" * text[i:j].count("\n"))
            i = j
            continue
        nxt = _skip_string_or_long_string(text, i)
        if nxt is not None:
            out.append(text[i:nxt])
            i = nxt
            continue
        out.append(text[i])
        i += 1
    return "".join(out)


# ============================================================
# 1) Balanced splitting (commas at top-level), with Lua block awareness
# ============================================================

def _split_top_level(text: str, sep: str = ",") -> List[str]:
    """
    Split by sep at top level.

    Top level means:
    - not in (), {}, []
    - not in strings/comments/long-strings
    - not inside Lua blocks (function/if/for/while/repeat/do ... end/until)

    This is critical for safely splitting function call arguments in DST scripts.
    """
    if not text:
        return []

    n = len(text)
    parts: List[str] = []
    start = 0
    i = 0

    bracket_stack: List[str] = []
    block_stack: List[Tuple[str, bool]] = []  # (kind, awaiting_do)

    def _push_block(kind: str) -> None:
        block_stack.append((kind, False))

    def _push_loop(kind: str) -> None:
        block_stack.append((kind, True))

    def _on_do() -> None:
        if block_stack and block_stack[-1][0] in ("for", "while") and block_stack[-1][1]:
            kind, _ = block_stack[-1]
            block_stack[-1] = (kind, False)
        else:
            _push_block("do")

    def _on_end() -> None:
        if block_stack:
            block_stack.pop()

    def _on_until() -> None:
        # close the nearest repeat
        for idx in range(len(block_stack) - 1, -1, -1):
            if block_stack[idx][0] == "repeat":
                del block_stack[idx:]
                return

    while i < n:
        if text.startswith("--", i):
            i = _skip_comment(text, i)
            continue

        nxt = _skip_string_or_long_string(text, i)
        if nxt is not None:
            i = nxt
            continue

        ch = text[i]

        if ch in "({[":
            if ch == "[":
                level = _long_bracket_level(text, i)
                if level is not None:
                    i = _skip_long_bracket(text, i, level)
                    continue
            bracket_stack.append(ch)
            i += 1
            continue

        if ch in ")}]":
            want = {")": "(", "}": "{", "]": "["}[ch]
            if bracket_stack and bracket_stack[-1] == want:
                bracket_stack.pop()
            i += 1
            continue

        # block keywords
        if _is_ident_start(ch):
            j = i + 1
            while j < n and _is_ident_char(text[j]):
                j += 1
            word = text[i:j]
            if word == "function":
                _push_block("function")
            elif word == "if":
                _push_block("if")
            elif word == "for":
                _push_loop("for")
            elif word == "while":
                _push_loop("while")
            elif word == "repeat":
                _push_block("repeat")
            elif word == "do":
                _on_do()
            elif word == "end":
                _on_end()
            elif word == "until":
                _on_until()
            i = j
            continue

        if ch == sep and not bracket_stack and not block_stack:
            parts.append(text[start:i].strip())
            start = i + 1
            i += 1
            continue

        i += 1

    tail = text[start:].strip()
    if tail:
        parts.append(tail)
    return parts


def split_top_level(text: str, sep: str = ",") -> List[str]:
    """Public wrapper for _split_top_level."""
    return _split_top_level(text, sep)


def _find_matching(text: str, open_idx: int, open_ch: str, close_ch: str) -> Optional[int]:
    """Find the matching closing bracket for open_ch at open_idx. Skip strings/comments/long brackets."""
    n = len(text)
    if open_idx >= n or text[open_idx] != open_ch:
        return None

    stack: List[str] = [open_ch]
    i = open_idx + 1
    while i < n and stack:
        if text.startswith("--", i):
            i = _skip_comment(text, i)
            continue
        nxt = _skip_string_or_long_string(text, i)
        if nxt is not None:
            i = nxt
            continue

        ch = text[i]
        if ch in "({[":
            if ch == "[":
                level = _long_bracket_level(text, i)
                if level is not None:
                    i = _skip_long_bracket(text, i, level)
                    continue
            stack.append(ch)
            i += 1
            continue

        if ch in ")}]":
            want = {")": "(", "}": "{", "]": "["}[ch]
            if stack and stack[-1] == want:
                stack.pop()
            i += 1
            continue

        i += 1

    if stack:
        return None
    return i - 1


def find_matching(text: str, open_idx: int, open_ch: str, close_ch: str) -> Optional[int]:
    """Public wrapper for _find_matching."""
    return _find_matching(text, open_idx, open_ch, close_ch)


# ============================================================
# 2) Expression parser (subset; practical for DST data tables)
# ============================================================

@dataclass
class LuaRaw:
    """Opaque expression (kept as raw text)."""
    text: str


@dataclass
class LuaTableValue:
    """Lua table constructor parsed into (array, map)."""
    array: List[Any]
    map: Dict[Any, Any]


def lua_to_python(v: Any) -> Any:
    """Recursively convert LuaTableValue/LuaRaw into plain Python types."""
    if isinstance(v, LuaRaw):
        return v.text
    if isinstance(v, LuaTableValue):
        arr = [lua_to_python(x) for x in v.array]
        mp = {lua_to_python(k): lua_to_python(val) for k, val in v.map.items()}
        if mp and arr:
            return {"__array__": arr, **mp}
        if mp:
            return mp
        return arr
    if isinstance(v, list):
        return [lua_to_python(x) for x in v]
    if isinstance(v, dict):
        return {lua_to_python(k): lua_to_python(val) for k, val in v.items()}
    return v


_NUM_RE = re.compile(r"^[+-]?(?:\d+\.\d*|\d*\.\d+|\d+)(?:[eE][+-]?\d+)?$")


def _parse_lua_string(expr: str) -> Optional[str]:
    expr = (expr or "").strip()
    if len(expr) >= 2 and expr[0] == expr[-1] and expr[0] in ("'", '"'):
        body = expr[1:-1]
        body = body.replace(r"\\", "\\").replace(r"\'", "'").replace(r"\"", '"')
        return body
    if expr.startswith("["):
        level = _long_bracket_level(expr, 0)
        if level is not None:
            opener_len = 2 + level
            close_pat = "]" + ("=" * level) + "]"
            end = expr.find(close_pat, opener_len)
            if end != -1:
                return expr[opener_len:end]
    return None


def parse_lua_string(expr: str) -> Optional[str]:
    """Public wrapper: parse a Lua string literal (short or long bracket)."""
    return _parse_lua_string(expr)


def parse_lua_expr(expr: str) -> Any:
    """
    Parse a subset of Lua expressions into Python types:
    - string/long-string -> str
    - number -> int/float
    - true/false/nil -> bool/None
    - table constructor -> LuaTableValue
    - function (...) ... end -> LuaRaw("<function>")
    - identifier/dotted path / everything else -> LuaRaw(expr)
    """
    expr = (expr or "").strip()
    if not expr:
        return LuaRaw("")

    if expr.startswith("function"):
        sig_end = expr.find(")")
        if sig_end != -1 and sig_end < 160:
            return LuaRaw(expr[: sig_end + 1] + " ... end")
        return LuaRaw("<function>")

    if expr == "nil":
        return None
    if expr in ("true", "false"):
        return expr == "true"

    s = _parse_lua_string(expr)
    if s is not None:
        return s

    if _NUM_RE.match(expr):
        try:
            f = float(expr)
            return int(f) if f.is_integer() else f
        except Exception:
            return LuaRaw(expr)

    if expr.startswith("{"):
        close = _find_matching(expr, 0, "{", "}")
        if close is None:
            return LuaRaw(expr)
        inner = expr[1:close]
        return parse_lua_table(inner)

    if re.match(r"^[A-Za-z_][A-Za-z0-9_\.]*$", expr):
        return LuaRaw(expr)

    return LuaRaw(expr)


def parse_lua_table(inner: str) -> LuaTableValue:
    """
    Parse the inside of { ... } (without outer braces).
    Returns LuaTableValue(array, map).
    """
    inner = strip_lua_comments(inner)

    array: List[Any] = []
    mp: Dict[Any, Any] = {}

    for item in _split_top_level(inner, ","):
        item = (item or "").strip()
        if not item:
            continue

        # key = value
        m = re.match(r"^([A-Za-z_][A-Za-z0-9_]*)\s*=\s*(.+)$", item, flags=re.DOTALL)
        if m:
            key = m.group(1)
            mp[key] = parse_lua_expr(m.group(2))
            continue

        # ["key"] = value (also long bracket keys)
        m = re.match(r'^\[\s*([\'"].*?[\'"]|\[=*\[.*?\]=*\])\s*\]\s*=\s*(.+)$', item, flags=re.DOTALL)
        if m:
            key_raw = m.group(1)
            key = _parse_lua_string(key_raw) or LuaRaw(key_raw)
            mp[key] = parse_lua_expr(m.group(2))
            continue

        # [expr] = value
        m = re.match(r"^\[\s*(.+?)\s*\]\s*=\s*(.+)$", item, flags=re.DOTALL)
        if m:
            mp[LuaRaw(m.group(1).strip())] = parse_lua_expr(m.group(2))
            continue

        # array entry
        array.append(parse_lua_expr(item))

    return LuaTableValue(array=array, map=mp)


# ============================================================
# 3) Lua call extractor (NAME(...) and obj:Method(...))
# ============================================================

@dataclass(frozen=True)
class LuaCall:
    name: str
    full_name: str
    start: int
    end: int
    open_paren: int
    close_paren: int
    args: str
    arg_list: List[str]
    line: int
    col: int


class LuaCallExtractor:
    """
    Extract Lua function calls with balanced parentheses, skipping comments/strings/long strings.

    Supports:
    - NAME(...)
    - obj.NAME(...)
    - obj:NAME(...)
    """

    def __init__(self, content: str):
        self.content = content or ""
        self._line_starts: Optional[List[int]] = None

    def iter_calls(
        self,
        names: Union[str, Sequence[str]],
        *,
        include_member_calls: bool = True,
        match_full_name: bool = False,
    ) -> Iterator[LuaCall]:
        if isinstance(names, str):
            targets = {names}
        else:
            targets = set(names)

        text = self.content
        n = len(text)
        i = 0

        while i < n:
            if text.startswith("--", i):
                i = _skip_comment(text, i)
                continue

            nxt = _skip_string_or_long_string(text, i)
            if nxt is not None:
                i = nxt
                continue

            ch = text[i]
            if _is_ident_start(ch):
                # first ident
                j = i + 1
                while j < n and _is_ident_char(text[j]):
                    j += 1
                first = text[i:j]
                if first in _LUA_KEYWORDS:
                    i = j
                    continue

                full = first
                last = first
                k = j

                if include_member_calls:
                    # ".ident" / ":ident" chain
                    while True:
                        kk = k
                        while kk < n and text[kk].isspace():
                            kk += 1
                        if kk < n and text[kk] in ".:":
                            sep = text[kk]
                            kk += 1
                            while kk < n and text[kk].isspace():
                                kk += 1
                            if kk < n and _is_ident_start(text[kk]):
                                jj = kk + 1
                                while jj < n and _is_ident_char(text[jj]):
                                    jj += 1
                                seg = text[kk:jj]
                                full = full + sep + seg
                                last = seg
                                k = jj
                                continue
                        break

                hit = (full in targets) if match_full_name else (last in targets)
                if hit:
                    kk = k
                    while kk < n and text[kk].isspace():
                        kk += 1
                    if kk < n and text[kk] == "(":
                        close = _find_matching(text, kk, "(", ")")
                        if close is not None:
                            args = text[kk + 1: close]
                            arg_list = self.split_args(args)
                            line, col = self._line_col(i)
                            yield LuaCall(
                                name=last,
                                full_name=full,
                                start=i,
                                end=close + 1,
                                open_paren=kk,
                                close_paren=close,
                                args=args,
                                arg_list=arg_list,
                                line=line,
                                col=col,
                            )
                            i = close + 1
                            continue

                i = k
                continue

            i += 1

    def extract_calls(self, names: Union[str, Sequence[str]], **kwargs: Any) -> List[LuaCall]:
        return list(self.iter_calls(names, **kwargs))

    def split_args(self, args: str) -> List[str]:
        return [p for p in _split_top_level(args, ",") if p]

    def _ensure_line_starts(self) -> None:
        if self._line_starts is not None:
            return
        self._line_starts = [0]
        for m in re.finditer("\n", self.content):
            self._line_starts.append(m.end())

    def _line_col(self, pos: int) -> Tuple[int, int]:
        self._ensure_line_starts()
        assert self._line_starts is not None
        idx = bisect.bisect_right(self._line_starts, pos) - 1
        line_start = self._line_starts[idx]
        return idx + 1, (pos - line_start) + 1


# ============================================================
# 4) TuningResolver (chain + simple arithmetic evaluation)
# ============================================================

_ARITH_TOKEN_RE = re.compile(r"\s*(\d+\.\d+|\d+|[A-Za-z_][A-Za-z0-9_\.]*|\*\*|\^|[+\-*/()])\s*")


class TuningResolver:
    """
    Lightweight resolver for DST `scripts/tuning.lua`.

    Goals
    - Parse common constant assignments:
        - `local NAME = <rhs>`  (UPPER_CASE only)
        - `TUNING.NAME = <rhs>`
    - Resolve numeric chains and simple arithmetic expressions.
    - Provide *traceable* resolution (for UI/wiki), not only final numbers.

    Notes
    - This is intentionally conservative: if an expression can't be proven safe and numeric,
      resolution returns None rather than guessing.
    """

    _REF_PAT = re.compile(
        r"TUNING\.([A-Za-z0-9_]+)|TUNING\[\s*([\'\"])([A-Za-z0-9_]+)\2\s*\]"
    )

    def __init__(self, content: str):
        self.raw_map: Dict[str, Any] = {}
        self.local_map: Dict[str, Any] = {}
        if content:
            self._parse_tuning(content)

    # --------------------------
    # Parsing
    # --------------------------

    def _parse_tuning(self, content: str) -> None:
        clean = strip_lua_comments(content)

        # locals (UPPER_CASE only: avoid locals inside functions)
        for m in re.finditer(r"^\s*local\s+([A-Z0-9_]+)\s*=\s*(.+?)\s*$", clean, flags=re.MULTILINE):
            name, rhs = m.group(1), m.group(2)
            rhs = rhs.strip().rstrip(",")
            val = self._parse_rhs(rhs)
            if val is not None:
                self.local_map[name] = val

        # TUNING.KEY = rhs
        for m in re.finditer(r"^\s*TUNING\.([A-Z0-9_]+)\s*=\s*(.+?)\s*$", clean, flags=re.MULTILINE):
            key, rhs = m.group(1), m.group(2)
            rhs = rhs.strip().rstrip(",")
            val = self._parse_rhs(rhs)
            self.raw_map[key] = val if val is not None else rhs

    def _parse_rhs(self, rhs: str) -> Optional[Any]:
        rhs = (rhs or "").strip().rstrip(",")
        if not rhs:
            return None
        if rhs in ("true", "false"):
            return rhs == "true"
        if rhs == "nil":
            return None

        s = _parse_lua_string(rhs)
        if s is not None:
            return s

        if _NUM_RE.match(rhs):
            try:
                f = float(rhs)
                return int(f) if f.is_integer() else f
            except Exception:
                return None

        # keep as raw string expression / symbol
        return rhs

    # --------------------------
    # Resolution (internal)
    # --------------------------

    @staticmethod
    def _norm_key(ref: str) -> str:
        ref = (ref or "").strip()
        return ref[7:] if ref.startswith("TUNING.") else ref

    def _resolve_ref(self, ref: str, depth: int = 8) -> Optional[Union[int, float]]:
        """Resolve a ref/expression to a number (or None)."""
        if depth <= 0:
            return None
        ref = (ref or "").strip()
        if not ref:
            return None

        # numeric literal
        if _NUM_RE.match(ref):
            try:
                f = float(ref)
                return int(f) if f.is_integer() else f
            except Exception:
                return None

        # direct symbol (TUNING.X / local X)
        if re.match(r"^[A-Za-z_][A-Za-z0-9_\.]*$", ref):
            key = self._norm_key(ref)
            v = self.raw_map.get(key, self.local_map.get(key))
            if isinstance(v, (int, float)):
                return v
            if isinstance(v, str) and v and v != ref:
                # symbol chain (A -> B) or expression
                if re.match(r"^[A-Za-z_][A-Za-z0-9_\.]*$", v):
                    return self._resolve_ref(v, depth - 1)
                return self._resolve_ref(v, depth - 1)
            return None

        # arithmetic expression (conservative tokenizer)
        py_parts: List[str] = []
        for tok in _ARITH_TOKEN_RE.findall(ref):
            tok = tok.strip()
            if not tok:
                continue

            # Lua exponent
            if tok == "^":
                py_parts.append("**")
                continue
            if tok in {"+", "-", "*", "/", "(", ")", "**"}:
                py_parts.append(tok)
                continue
            if _NUM_RE.match(tok):
                py_parts.append(tok)
                continue

            val = self._resolve_ref(tok, depth - 1)
            if val is None:
                return None
            py_parts.append(str(val))

        expr_py = "".join(py_parts)
        # Safety: only numbers + operators
        if re.search(r"[^0-9\.\+\-\*\/\(\)eE]", expr_py):
            return None
        try:
            out = eval(expr_py, {"__builtins__": {}}, {})
            if isinstance(out, (int, float)):
                if isinstance(out, float) and out.is_integer():
                    return int(out)
                return out
        except Exception:
            return None
        return None

    # --------------------------
    # Public APIs
    # --------------------------

    def explain(self, key: str, max_hops: int = 10) -> Tuple[str, Optional[Union[int, float]]]:
        """Return (chain_text, resolved_value)."""
        key = self._norm_key(key)
        if not key:
            return "", None

        chain: List[str] = []
        visited = set()
        cur = key

        for _ in range(max_hops):
            if cur in visited:
                chain.append(f"{cur} (loop)")
                break
            visited.add(cur)

            v = self.raw_map.get(cur, self.local_map.get(cur))
            if v is None:
                chain.append(cur)
                break

            chain.append(cur)

            if isinstance(v, (int, float)):
                chain.append(str(v))
                return " -> ".join(chain), v

            if isinstance(v, str):
                chain.append(v)
                if re.match(r"^[A-Za-z_][A-Za-z0-9_\.]*$", v):
                    cur = self._norm_key(v)
                    continue
                val = self._resolve_ref(v)
                if val is not None:
                    chain.append(str(val))
                    return " -> ".join(chain), val
                break

            chain.append(str(v))
            break

        # fallback try resolve the symbol itself (handles local->expr cases)
        val = self._resolve_ref(key)
        return " -> ".join(chain) if chain else key, val

    def trace_key(self, key: str, max_hops: int = 16) -> Dict[str, Any]:
        """Structured trace for a single TUNING key."""
        key0 = key
        key = self._norm_key(key)
        steps: List[Dict[str, Any]] = []
        visited = set()
        cur = key

        for _ in range(max_hops):
            if not cur:
                break
            if cur in visited:
                steps.append({"key": cur, "raw": None, "note": "loop"})
                break
            visited.add(cur)

            v = self.raw_map.get(cur, self.local_map.get(cur))
            steps.append({"key": cur, "raw": v})

            if isinstance(v, (int, float)):
                return {"key": key0, "normalized": key, "value": v, "steps": steps}

            if isinstance(v, str) and re.match(r"^[A-Za-z_][A-Za-z0-9_\.]*$", v):
                cur = self._norm_key(v)
                continue

            # expression or unknown
            if isinstance(v, str):
                val = self._resolve_ref(v)
                return {
                    "key": key0,
                    "normalized": key,
                    "value": val,
                    "steps": steps + [{"key": "<expr>", "raw": v, "value": val}],
                }
            break

        # fallback
        val = self._resolve_ref(key)
        return {"key": key0, "normalized": key, "value": val, "steps": steps}

    def trace_expr(self, expr: str) -> Dict[str, Any]:
        """Trace an arbitrary expression containing TUNING refs."""
        expr = (expr or "").strip()
        refs = []
        for m in self._REF_PAT.finditer(expr):
            k = m.group(1) or m.group(3)
            if k and k not in refs:
                refs.append(k)

        ref_traces: Dict[str, Any] = {}
        for k in refs:
            ref_traces[k] = self.trace_key(k)

        value = self._resolve_ref(expr)

        # best-effort normalized expression (TUNING.X -> number)
        expr_resolved = expr
        for k in refs:
            v = ref_traces.get(k, {}).get("value")
            if isinstance(v, (int, float)):
                expr_resolved = re.sub(
                    rf"\bTUNING\.{re.escape(k)}\b",
                    str(v),
                    expr_resolved,
                )
                expr_resolved = re.sub(
                    rf"TUNING\[\s*([\'\"])\s*{re.escape(k)}\s*\1\s*\]",
                    str(v),
                    expr_resolved,
                )

        return {
            "expr": expr,
            "value": value,
            "expr_resolved": expr_resolved,
            "refs": ref_traces,
        }

    def enrich(self, text: str) -> str:
        """Inline enrichment: replace `TUNING.X` in text with `TUNING.X (chain)` when resolvable."""
        if not text or "TUNING" not in text:
            return text

        def repl(m: re.Match) -> str:
            key = m.group(1) or m.group(3)
            if not key:
                return m.group(0)
            chain, val = self.explain(key)
            if val is None:
                return f"TUNING.{key}"
            return f"TUNING.{key} ({chain})"

        return self._REF_PAT.sub(repl, text)


# ============================================================
# 5) Domain parsers (Prefab / Loot / Widgets / Strings)
# ============================================================

class BaseParser:
    def __init__(self, content: str, path: Optional[str] = None):
        self.path = path
        self.content = content or ""
        self.clean = strip_lua_comments(self.content)

    def _extract_requires(self) -> List[str]:
        return re.findall(r'require\s*\(?\s*["\'](.*?)["\']\s*\)?', self.clean)


class LootParser(BaseParser):
    """Parse shared loot tables + simple loot helpers."""
    def parse(self) -> Dict[str, Any]:
        data: Dict[str, Any] = {"type": "loot", "table_name": None, "entries": []}
        extractor = LuaCallExtractor(self.content)

        for call in extractor.iter_calls("SetSharedLootTable"):
            if not call.arg_list:
                continue
            name = parse_lua_string(call.arg_list[0]) or None
            if name:
                data["table_name"] = name
            if len(call.arg_list) >= 2:
                tbl = parse_lua_expr(call.arg_list[1])
                if isinstance(tbl, LuaTableValue):
                    for row in tbl.array:
                        if isinstance(row, LuaTableValue) and len(row.array) >= 2:
                            item = row.array[0]
                            chance = row.array[1]
                            if isinstance(item, str) and isinstance(chance, (int, float)):
                                data["entries"].append({"item": item, "chance": float(chance), "method": "TableData"})

        for call in extractor.iter_calls(["AddRandomLoot", "AddRandomLootTable"]):
            if len(call.arg_list) >= 2:
                item = parse_lua_string(call.arg_list[0])
                w = parse_lua_expr(call.arg_list[1])
                if isinstance(item, str) and isinstance(w, (int, float)):
                    data["entries"].append({"item": item, "weight": float(w), "method": "Random"})

        for call in extractor.iter_calls("AddChanceLoot"):
            if len(call.arg_list) >= 2:
                item = parse_lua_string(call.arg_list[0])
                c = parse_lua_expr(call.arg_list[1])
                if isinstance(item, str) and isinstance(c, (int, float)):
                    data["entries"].append({"item": item, "chance": float(c), "method": "Chance"})

        return data


class WidgetParser(BaseParser):
    def parse(self) -> Dict[str, Any]:
        data: Dict[str, Any] = {"type": "widget", "classes": [], "dependencies": self._extract_requires()}
        for name, parent in re.findall(r"local\s+([A-Za-z0-9_]+)\s*=\s*Class\s*\(\s*([A-Za-z0-9_]+)", self.clean):
            data["classes"].append({"name": name, "parent": parent})
        return data


class StringParser(BaseParser):
    def parse(self) -> Dict[str, Any]:
        data: Dict[str, Any] = {"type": "strings", "roots": [], "includes": self._extract_requires()}
        roots = set()
        roots.update(re.findall(r"STRINGS\.([A-Z0-9_]+)\s*=\s*\{", self.clean))
        roots.update(re.findall(r"STRINGS\.([A-Z0-9_]+)\s*=\s*['\"]", self.clean))
        data["roots"] = sorted(roots)
        return data


class PrefabParser(BaseParser):
    def parse(self) -> Dict[str, Any]:
        data: Dict[str, Any] = {
            "type": "prefab",
            "assets": [],
            "components": [],
            "helpers": [],
            "stategraph": None,
            "brain": None,
            "events": [],
            "tags": [],
            "prefab_name": None,
        }

        extractor = LuaCallExtractor(self.content)

        for call in extractor.iter_calls("Prefab"):
            if call.arg_list:
                nm = parse_lua_string(call.arg_list[0])
                if nm:
                    data["prefab_name"] = nm
                    break

        for call in extractor.iter_calls("Asset"):
            if len(call.arg_list) >= 2:
                t = parse_lua_string(call.arg_list[0])
                p = parse_lua_string(call.arg_list[1])
                if isinstance(t, str) and isinstance(p, str):
                    data["assets"].append({"type": t, "path": p})

        m = re.search(r"SetBrain\s*\(\s*require\s*\(\s*['\"](.*?)['\"]\s*\)\s*\)", self.clean)
        if m:
            data["brain"] = m.group(1)
        m = re.search(r"SetStateGraph\s*\(\s*['\"](.*?)['\"]\s*\)", self.clean)
        if m:
            data["stategraph"] = m.group(1)

        data["events"] = re.findall(r'EventHandler\s*\(\s*["\']([^"\']+)["\']\s*,', self.clean)
        data["helpers"] = sorted(set(re.findall(r"^\s*(Make[A-Za-z0-9_]+)\s*\(", self.content, flags=re.MULTILINE)))

        tags: List[str] = []
        for call in extractor.iter_calls("AddTag"):
            if call.arg_list:
                tg = parse_lua_string(call.arg_list[0])
                if tg:
                    tags.append(tg)
        data["tags"] = sorted(set(tags))

        comps = set()
        for call in extractor.iter_calls("AddComponent"):
            if call.arg_list:
                cn = parse_lua_string(call.arg_list[0])
                if cn:
                    comps.add(cn)

        for comp_name in sorted(comps):
            comp_data = {"name": comp_name, "methods": [], "properties": []}

            method_pat = re.compile(r"components\." + re.escape(comp_name) + r"[:\.]([A-Za-z0-9_]+)\s*\((.*?)\)", re.DOTALL)
            for m_name, m_args in method_pat.findall(self.clean):
                clean_args = re.sub(r"\s+", " ", m_args).strip()
                if len(clean_args) > 60:
                    clean_args = clean_args[:57] + "..."
                comp_data["methods"].append(f"{m_name}({clean_args})")

            prop_pat = re.compile(r"components\." + re.escape(comp_name) + r"\.([A-Za-z0-9_]+)\s*=\s*([^=\n]+)")
            for p_name, p_val in prop_pat.findall(self.clean):
                comp_data["properties"].append(f"{p_name} = {p_val.strip()}")

            data["components"].append(comp_data)

        return data


class LuaAnalyzer:
    """Facade: choose best strategy based on content + optional path."""
    def __init__(self, content: str, path: Optional[str] = None):
        self.content = content or ""
        self.path = path
        self.parser = self._select_strategy()

    def _select_strategy(self) -> BaseParser:
        p = (self.path or "").replace("\\", "/")
        c = self.content

        if p.startswith("scripts/widgets/") or p.startswith("scripts/screens/"):
            return WidgetParser(c, p)
        if p.startswith("scripts/strings"):
            return StringParser(c, p)
        if p.startswith("scripts/prefabs/"):
            return PrefabParser(c, p)

        if "Class(Widget" in c or "Class(Screen" in c or 'require "widgets/' in c or "require('widgets/" in c:
            return WidgetParser(c, p)
        if "return Prefab" in c or "Prefab(" in c:
            return PrefabParser(c, p)
        if "STRINGS." in c and "STRINGS.CHARACTERS" in c:
            return StringParser(c, p)
        if "SetSharedLootTable" in c or "AddChanceLoot" in c:
            return LootParser(c, p)
        return PrefabParser(c, p)

    def get_report(self) -> Dict[str, Any]:
        return self.parser.parse()


# ============================================================
# 6) Cooking recipe analyzer (preparedfoods*.lua)
# ============================================================

# ============================================================
# 6) Cooking recipe analyzer (preparedfoods*.lua)
# ============================================================

def _iter_named_table_blocks(parent_table_body: str) -> Iterable[Tuple[str, str]]:
    """
    Iterate top-level `name = { ... }` blocks inside a parent table body (WITHOUT outer braces).

    This is stricter than a regex: it skips strings/comments and respects nested braces.
    """
    text = parent_table_body or ""
    n = len(text)
    i = 0
    depth = 0

    while i < n:
        if text.startswith("--", i):
            i = _skip_comment(text, i)
            continue

        nxt = _skip_string_or_long_string(text, i)
        if nxt is not None:
            i = nxt
            continue

        ch = text[i]

        if ch == "{":
            depth += 1
            i += 1
            continue
        if ch == "}":
            depth = max(0, depth - 1)
            i += 1
            continue

        if depth == 0:
            # skip whitespace/commas between entries
            if ch.isspace() or ch == ",":
                i += 1
                continue

            if _is_ident_start(ch):
                j = i + 1
                while j < n and _is_ident_char(text[j]):
                    j += 1
                name = text[i:j]

                k = j
                while k < n and text[k].isspace():
                    k += 1
                if k < n and text[k] == "=":
                    k += 1
                    while k < n and text[k].isspace():
                        k += 1
                    if k < n and text[k] == "{":
                        open_idx = k
                        close_idx = _find_matching(text, open_idx, "{", "}")
                        if close_idx is None:
                            i = j
                            continue
                        body = text[open_idx + 1: close_idx]
                        yield name, body
                        i = close_idx + 1
                        continue

                i = j
                continue

        i += 1


def _find_lua_function_end(text: str, fn_start: int) -> Optional[int]:
    """Return index right after the `end` that closes the function started at fn_start."""
    if fn_start < 0 or fn_start >= len(text):
        return None
    if not text.startswith("function", fn_start):
        return None

    n = len(text)
    i = fn_start

    bracket_stack: List[str] = []
    block_stack: List[Tuple[str, bool]] = []  # (kind, awaiting_do)

    def _push_block(kind: str) -> None:
        block_stack.append((kind, False))

    def _push_loop(kind: str) -> None:
        block_stack.append((kind, True))

    def _on_do() -> None:
        if block_stack and block_stack[-1][0] in ("for", "while") and block_stack[-1][1]:
            kind, _ = block_stack[-1]
            block_stack[-1] = (kind, False)
        else:
            _push_block("do")

    def _on_end() -> None:
        if block_stack:
            block_stack.pop()

    def _on_until() -> None:
        # close the nearest repeat
        for idx in range(len(block_stack) - 1, -1, -1):
            if block_stack[idx][0] == "repeat":
                del block_stack[idx:]
                return

    # consume the initial 'function'
    _push_block("function")
    i += len("function")

    while i < n and block_stack:
        if text.startswith("--", i):
            i = _skip_comment(text, i)
            continue
        nxt = _skip_string_or_long_string(text, i)
        if nxt is not None:
            i = nxt
            continue

        ch = text[i]

        # bracket stack (keep keywords inside parentheses from confusing us less; still scan keywords)
        if ch in "({[":
            if ch == "[":
                level = _long_bracket_level(text, i)
                if level is not None:
                    i = _skip_long_bracket(text, i, level)
                    continue
            bracket_stack.append(ch)
            i += 1
            continue

        if ch in ")}]":
            want = {")": "(", "}": "{", "]": "["}[ch]
            if bracket_stack and bracket_stack[-1] == want:
                bracket_stack.pop()
            i += 1
            continue

        if _is_ident_start(ch):
            j = i + 1
            while j < n and _is_ident_char(text[j]):
                j += 1
            word = text[i:j]

            if word == "function":
                _push_block("function")
            elif word == "if":
                _push_block("if")
            elif word == "for":
                _push_loop("for")
            elif word == "while":
                _push_loop("while")
            elif word == "repeat":
                _push_block("repeat")
            elif word == "do":
                _on_do()
            elif word == "end":
                _on_end()
                if not block_stack:
                    return j
            elif word == "until":
                _on_until()
                if not block_stack:
                    return j

            i = j
            continue

        i += 1

    return None


def _extract_test_return_expr(entry_body: str) -> Optional[str]:
    """Extract the boolean return expression from `test = function(...) return <expr> end`."""
    if not entry_body:
        return None

    m = re.search(r"\btest\s*=\s*function\b", entry_body)
    if not m:
        return None

    fn_start = m.end() - len("function")
    fn_end = _find_lua_function_end(entry_body, fn_start)
    if fn_end is None:
        return None

    fn_src = entry_body[fn_start:fn_end]
    clean = strip_lua_comments(fn_src)

    mret = re.search(r"\breturn\b\s*([\s\S]*?)\bend\b", clean)
    if not mret:
        return None

    expr = mret.group(1).strip()
    expr = re.sub(r"\s+", " ", expr)
    return expr or None


def _parse_rule_constraints(expr: str) -> Dict[str, Any]:
    """Best-effort extraction of common `names.*` / `tags.*` constraints from test-return expr."""
    expr = (expr or "").strip()
    out: Dict[str, Any] = {"raw": expr, "tags": [], "names": [], "unparsed": []}
    if not expr:
        return out

    # Normalize spaces to reduce corner cases
    e = re.sub(r"\s+", " ", expr)

    seen = set()

    # comparisons: tags.X <op> (number|nil|identifier)
    cmp_pat = re.compile(
        r"\b(?P<scope>tags|names)\.(?P<key>[A-Za-z0-9_]+)\s*(?P<op>==|~=|<=|>=|<|>)\s*(?P<rhs>[^\s\)\]]+)"
    )
    for m in cmp_pat.finditer(e):
        scope = m.group("scope")
        key = m.group("key")
        op = m.group("op")
        rhs = m.group("rhs").rstrip(",")
        rhs_norm: Any
        if rhs == "nil":
            rhs_norm = None
        elif _NUM_RE.match(rhs):
            try:
                rhs_norm = float(rhs)
                if isinstance(rhs_norm, float) and rhs_norm.is_integer():
                    rhs_norm = int(rhs_norm)
            except Exception:
                rhs_norm = rhs
        else:
            rhs_norm = rhs

        rec = (scope, key, op, str(rhs_norm))
        if rec in seen:
            continue
        seen.add(rec)
        out[scope].append({"key": key, "op": op, "value": rhs_norm, "text": m.group(0)})

    # presence (truthy): tags.X / names.X
    pres_pat = re.compile(r"\b(?P<scope>tags|names)\.(?P<key>[A-Za-z0-9_]+)\b(?!\s*(==|~=|<=|>=|<|>))")
    for m in pres_pat.finditer(e):
        scope = m.group("scope")
        key = m.group("key")
        rec = (scope, key, ">", 0)
        if rec in seen:
            continue
        seen.add(rec)
        out[scope].append({"key": key, "op": ">", "value": 0, "text": m.group(0)})

    # negated presence: not tags.X / not names.X
    neg_pat = re.compile(r"\bnot\s+(?P<scope>tags|names)\.(?P<key>[A-Za-z0-9_]+)\b")
    for m in neg_pat.finditer(e):
        scope = m.group("scope")
        key = m.group("key")
        rec = (scope, key, "==", 0)
        if rec in seen:
            continue
        seen.add(rec)
        out[scope].append({"key": key, "op": "==", "value": 0, "text": m.group(0)})

    return out


class CookingRecipeAnalyzer:
    """
    Parse preparedfoods*.lua (data-driven part).

    Extract stable fields for wiki/web:
    - priority/weight/foodtype/hunger/health/sanity/perishtime/cooktime/tags
    - card_def.ingredients -> card_ingredients: list[[item, count], ...]
    - rule constraints (best-effort): `test = function(...) return ... end`
    """

    STABLE_KEYS = (
        "priority",
        "weight",
        "foodtype",
        "hunger",
        "health",
        "sanity",
        "perishtime",
        "cooktime",
        "tags",
    )

    def __init__(self, content: str):
        self.content = content or ""
        self.recipes: Dict[str, Dict[str, Any]] = {}
        if content:
            self._parse()

    def _parse(self) -> None:
        # most files: local foods = { ... }
        m = re.search(r"local\s+foods\s*=\s*\{", self.content)
        if not m:
            return
        open_idx = m.end() - 1
        close_idx = _find_matching(self.content, open_idx, "{", "}")
        if close_idx is None:
            return

        inner = self.content[open_idx + 1: close_idx]

        for name, body in _iter_named_table_blocks(inner):
            tbl = parse_lua_table(body)
            if not isinstance(tbl, LuaTableValue):
                continue

            mp = tbl.map
            out: Dict[str, Any] = {}

            for key in self.STABLE_KEYS:
                if key in mp:
                    out[key] = lua_to_python(mp[key])

            # card_def.ingredients -> card_ingredients
            card = mp.get("card_def")
            if isinstance(card, LuaTableValue):
                ing = card.map.get("ingredients")
                if isinstance(ing, LuaTableValue):
                    rows: List[List[Any]] = []
                    for r in ing.array:
                        if isinstance(r, LuaTableValue) and len(r.array) >= 2:
                            rows.append([lua_to_python(r.array[0]), lua_to_python(r.array[1])])
                    if rows:
                        out["card_ingredients"] = rows

            # rule constraints (test-return expr)
            test_expr = _extract_test_return_expr(body)
            if test_expr:
                out["rule"] = {
                    "kind": "test_return",
                    "expr": test_expr,
                    "constraints": _parse_rule_constraints(test_expr),
                }

            if out:
                self.recipes[name] = out
```

### File: src/catalog.py
- mode: full
- size_bytes: 13843
- sha256_12: 1f52f9d1d4a7

```py
# -*- coding: utf-8 -*-
"""src/catalog.py

Catalog = stable, UI-agnostic, versioned index for downstream apps.

Motivation (M2)
- Parsing Lua on every query is wasteful for GUI/Web.
- A persisted, versioned catalog becomes the contract between...

Contents (v1)
- Crafting recipes: derived from `CraftRecipeDB`.
- Cooking recipes: extracted by `CookingRecipeAnalyzer`.
- Presentation assets mapping (optional):
  - Display names from `STRINGS.NAMES` (scripts/strings.lua)
  - Icon references from `Asset("ATLAS", ...)` / `Asset("IMAGE", ...)` (scripts/prefabs/*.lua)

The `assets` section is a *presentation-layer mapping*:
- key: internal id (e.g. "armor_wood")
- value: { name?, atlas?, image? }

This module intentionally only depends on core modules.
"""

from __future__ import annotations

from dataclasses import dataclass
import hashlib
import json
import re
from pathlib import Path
from typing import Any, Dict, Iterable, Optional, Set, Tuple

from analyzer import LuaCallExtractor, find_matching, parse_lua_string, parse_lua_table
from craft_recipes import CraftRecipeDB


SCHEMA_VERSION = 1


_ID_RE = re.compile(r"^[a-z0-9_]+$")
_PREFAB_PREFIX = "scripts/prefabs/"



def _sha256_12_file(path: Path, chunk_size: int = 1024 * 1024) -> Optional[str]:
    try:
        h = hashlib.sha256()
        with path.open("rb") as f:
            while True:
                chunk = f.read(chunk_size)
                if not chunk:
                    break
                h.update(chunk)
        return h.hexdigest()[:12]
    except Exception:
        return None


def _is_simple_id(s: str) -> bool:
    return bool(s) and bool(_ID_RE.match(s))

def _alt_id(iid: str) -> Optional[str]:
    """Best-effort alternative id for mapping.

    Many game ids have both forms in the wild (with/without underscores).
    This helper enables "armor_wood" -> "armorwood" fallback.
    """
    if not iid:
        return None
    if "_" not in iid:
        return None
    alt = iid.replace("_", "")
    return alt if alt and alt != iid else None



def _iter_craft_ids(craft: CraftRecipeDB) -> Iterable[str]:
    # recipe id itself
    for name, rec in (getattr(craft, "recipes", {}) or {}).items():
        if isinstance(name, str) and _is_simple_id(name):
            yield name

        if not isinstance(rec, dict):
            continue

        prod = rec.get("product")
        if isinstance(prod, str) and _is_simple_id(prod):
            yield prod

        for ing in rec.get("ingredients", []) or []:
            if not isinstance(ing, dict):
                continue
            item = ing.get("item")
            if isinstance(item, str) and _is_simple_id(item):
                yield item


def _iter_cooking_ids(cooking: Dict[str, Any]) -> Iterable[str]:
    for name, raw in (cooking or {}).items():
        if isinstance(name, str) and _is_simple_id(name):
            yield name
        if not isinstance(raw, dict):
            continue

        ci = raw.get("card_ingredients") or []
        if isinstance(ci, list):
            for row in ci:
                if not isinstance(row, (list, tuple)) or not row:
                    continue
                item = row[0]
                if isinstance(item, str) and _is_simple_id(item):
                    yield item


def _extract_strings_names(engine: Any) -> Dict[str, str]:
    """Extract STRINGS.NAMES mapping from scripts/strings.lua.

    Notes
    - `scripts/strings.lua` contains a giant `STRINGS = {...}` table.
    - Parsing the entire STRINGS table is expensive and can hit edge-cases.
      We instead locate and parse the `NAMES = { ... }` subtable directly.

    Output keys are normalized to lowercase ids.
    """
    src = (
        engine.read_file("scripts/strings.lua")
        or engine.read_file("strings.lua")
        or ""
    )
    if not src:
        return {}

    # Locate STRINGS = { ... }
    m = re.search(r"\bSTRINGS\s*=\s*\{", src)
    if not m:
        return {}
    strings_open = src.find("{", m.end() - 1)
    if strings_open < 0:
        return {}
    strings_close = find_matching(src, strings_open, "{", "}")
    if strings_close is None:
        return {}

    # Inside STRINGS block, locate the first top-level `NAMES = { ... }`
    block = src[strings_open: strings_close + 1]
    m2 = re.search(r"(?<![A-Za-z0-9_])NAMES\s*=\s*\{", block)
    if not m2:
        return {}

    names_open = strings_open + m2.end() - 1
    names_close = find_matching(src, names_open, "{", "}")
    if names_close is None:
        return {}

    inner = src[names_open + 1 : names_close]
    try:
        names_tbl = parse_lua_table(inner)
    except Exception:
        return {}

    out: Dict[str, str] = {}
    for k, v in (names_tbl.map or {}).items():
        if not isinstance(k, str):
            continue
        if not isinstance(v, str):
            continue
        kid = k.strip().lower()
        if not _is_simple_id(kid):
            continue
        out[kid] = v
    return out


def _score_asset_path(path: str, *, kind: str) -> Tuple[int, int, int]:
    """Scoring heuristic for selecting the 'best' atlas/image path.

    Higher tuple is better.
    """
    p = (path or "").lower()
    inv = 1 if "inventory" in p else 0
    # Kind-specific extension preference
    if kind == "ATLAS":
        ext = 2 if p.endswith(".xml") else 0
    else:
        ext = 2 if p.endswith(".tex") else 0
    # Prefer shorter paths (less specific penalty)
    short = max(0, 300 - len(p))
    return (inv, ext, short)


def _select_best(paths: Iterable[str], *, kind: str) -> Optional[str]:
    cand = [str(x) for x in paths if x]
    if not cand:
        return None
    cand.sort(key=lambda p: _score_asset_path(p, kind=kind), reverse=True)
    return cand[0]


def _extract_prefab_assets(engine: Any) -> Dict[str, Dict[str, str]]:
    """Extract prefab -> (atlas/image) mapping from prefab lua files.

    Strategy
    - For each scripts/prefabs/*.lua:
      - collect all Prefab("name", ...) calls => prefab names in this file
      - collect Asset("ATLAS", path) / Asset("IMAGE", path) calls
      - assign selected atlas/image to each prefab name

    Output keys are prefab ids (as-is in Prefab call), typically lowercase.
    """
    out: Dict[str, Dict[str, str]] = {}

    files = getattr(engine, "file_list", []) or []
    for path in files:
        if not isinstance(path, str):
            continue
        if not path.startswith(_PREFAB_PREFIX) or not path.endswith(".lua"):
            continue

        content = engine.read_file(path) or ""
        if not content:
            continue

        # Fast prefilter
        if "Asset" not in content:
            continue

        extractor = LuaCallExtractor(content)

        prefab_names: Set[str] = set()
        for call in extractor.iter_calls("Prefab", include_member_calls=False):
            if not call.arg_list:
                continue
            nm = parse_lua_string(call.arg_list[0])
            if isinstance(nm, str) and nm:
                prefab_names.add(nm)

        atlas_paths = []
        image_paths = []
        for call in extractor.iter_calls("Asset", include_member_calls=False):
            if len(call.arg_list) < 2:
                continue
            t = parse_lua_string(call.arg_list[0])
            p = parse_lua_string(call.arg_list[1])
            if not isinstance(t, str) or not isinstance(p, str):
                continue
            if t == "ATLAS":
                atlas_paths.append(p)
            elif t == "IMAGE":
                image_paths.append(p)

        if not atlas_paths and not image_paths:
            continue

        atlas = _select_best(atlas_paths, kind="ATLAS")
        image = _select_best(image_paths, kind="IMAGE")
        if not atlas and not image:
            continue

        # If Prefab(...) is not present, fall back to basename as a best-effort key.
        if not prefab_names:
            base = path.split("/")[-1].rsplit(".lua", 1)[0]
            if base:
                prefab_names.add(base)

        for nm in prefab_names:
            entry: Dict[str, str] = {}
            if atlas:
                entry["atlas"] = atlas
            if image:
                entry["image"] = image
            # Keep a light provenance for debugging (not used by UI).
            entry["prefab_file"] = path

            out[nm] = entry

    return out


def build_presentation_assets(engine: Any, craft: CraftRecipeDB, cooking: Dict[str, Any]) -> Dict[str, Dict[str, str]]:
    """Build presentation mapping for ids referenced by catalog.

    The mapping is intentionally *lossy*:
    - It only includes ids that appear in craft/cooking sections.
    - It only stores a small set of display-oriented fields.
    """
    referenced: Set[str] = set()
    referenced.update(_iter_craft_ids(craft))
    referenced.update(_iter_cooking_ids(cooking))

    # Extract global name + prefab asset maps (these can be large).
    names = _extract_strings_names(engine)
    prefab_assets = _extract_prefab_assets(engine)

    out: Dict[str, Dict[str, str]] = {}

    for iid in sorted(referenced):
        entry: Dict[str, str] = {}

        nm = names.get(iid)
        if not nm:
            alt = _alt_id(iid)
            nm = names.get(alt) if alt else None
        if nm:
            entry["name"] = nm

        pa = prefab_assets.get(iid)
        if not pa:
            alt = _alt_id(iid)
            pa = prefab_assets.get(alt) if alt else None
        if pa:
            if pa.get("atlas"):
                entry["atlas"] = pa["atlas"]
            if pa.get("image"):
                entry["image"] = pa["image"]
            # (optional) keep provenance if present
            if pa.get("prefab_file"):
                entry["prefab_file"] = pa["prefab_file"]

        if entry:
            out[iid] = entry

    return out


@dataclass
class WagstaffCatalog:
    """A versioned catalog.

    Keep it JSON-first to make it easy to consume from:
    - CLI
    - Web API
    - GUI
    - Static wiki builders
    """

    schema_version: int
    meta: Dict[str, Any]
    craft: CraftRecipeDB
    cooking: Dict[str, Any]
    assets: Dict[str, Dict[str, str]]

    # ------------------------------
    # Build / Load / Save
    # ------------------------------

    @classmethod
    def build(cls, *, engine: Any) -> "WagstaffCatalog":
        """Build a catalog from a WagstaffEngine."""
        craft_db = engine.recipes
        if craft_db is None:
            raise ValueError("engine.recipes is None; initialize engine with load_db=True")

        meta: Dict[str, Any] = {
            "schema": SCHEMA_VERSION,
            "engine_mode": getattr(engine, "mode", ""),
            "scripts_file_count": len(getattr(engine, "file_list", []) or []),
        }

        # signature
        sig = None
        try:
            if getattr(engine, "mode", "") == "zip":
                zf = getattr(engine, "source", None)
                zpath = getattr(zf, "filename", None)
                if zpath:
                    sig = _sha256_12_file(Path(zpath))
                    meta["scripts_zip"] = str(zpath)
            elif getattr(engine, "mode", "") == "folder":
                meta["scripts_dir"] = str(getattr(engine, "source", ""))
        except Exception:
            pass
        if sig:
            meta["scripts_sha256_12"] = sig

        cooking = getattr(engine, "cooking_recipes", {}) or {}

        # Presentation assets mapping (optional / best-effort)
        try:
            assets = build_presentation_assets(engine, craft_db, cooking)
            meta["assets_count"] = len(assets)
        except Exception:
            assets = {}

        return cls(
            schema_version=SCHEMA_VERSION,
            meta=meta,
            craft=craft_db,
            cooking=cooking,
            assets=assets,
        )

    def to_dict(self) -> Dict[str, Any]:
        return {
            "schema_version": int(self.schema_version),
            "meta": self.meta,
            "craft": self.craft.to_dict(),
            "cooking": self.cooking,
            "assets": self.assets or {},
        }

    @classmethod
    def from_dict(cls, d: Dict[str, Any]) -> "WagstaffCatalog":
        schema = int(d.get("schema_version") or d.get("schema") or 0)
        if schema != SCHEMA_VERSION:
            raise ValueError(f"Unsupported schema_version: {schema} (expected {SCHEMA_VERSION})")
        meta = d.get("meta") or {}
        craft = CraftRecipeDB.from_dict(d.get("craft") or {})
        cooking = d.get("cooking") or {}
        assets = d.get("assets") or {}
        if not isinstance(assets, dict):
            assets = {}
        # ensure {id: {..}} shape
        norm_assets: Dict[str, Dict[str, str]] = {}
        for k, v in assets.items():
            if not isinstance(k, str) or not k:
                continue
            if not isinstance(v, dict):
                continue
            vv: Dict[str, str] = {}
            for kk in ("name", "atlas", "image", "prefab_file"):
                if kk in v and isinstance(v.get(kk), str) and v.get(kk):
                    vv[kk] = str(v.get(kk))
            if vv:
                norm_assets[k] = vv

        return cls(schema_version=schema, meta=meta, craft=craft, cooking=cooking, assets=norm_assets)

    def save_json(self, path: str | Path, *, indent: int = 2) -> Path:
        p = Path(path)
        p.parent.mkdir(parents=True, exist_ok=True)
        p.write_text(json.dumps(self.to_dict(), ensure_ascii=False, indent=indent), encoding="utf-8")
        return p

    @classmethod
    def load_json(cls, path: str | Path) -> "WagstaffCatalog":
        p = Path(path)
        d = json.loads(p.read_text(encoding="utf-8"))
        if not isinstance(d, dict):
            raise ValueError("Catalog JSON must be a dict")
        return cls.from_dict(d)
```

### File: src/craft_recipes.py
- mode: full
- size_bytes: 28228
- sha256_12: 5ff8c02ec0af

```py
# -*- coding: utf-8 -*-
"""src/craft_recipes.py

Crafting recipes (Recipe/Recipe2/AddRecipe2) + recipe filter organization.

Why this module exists
- `scripts/recipes*.lua` and `scripts/recipes_filter.lua` are data sources.
- UI layers (wiki/GUI/web) need a stable, query-friendly Python representation.

Design goals (M0)
- Reuse `src/analyzer.py` Lua parsing primitives (single source of truth).
- Keep outputs JSON-serializable for catalog/index (M2).

Public API (expected by existing CLI)
- CraftRecipeDB.get(name)
- CraftRecipeDB.list_by_tab(tab)
- CraftRecipeDB.list_by_filter(filter)
- CraftRecipeDB.list_by_builder_tag(tag)
- CraftRecipeDB.list_by_tech(tech)

New (M2)
- CraftRecipeDB.list_by_ingredient(item)
- CraftRecipeDB.craftable(inventory)
- CraftRecipeDB.missing_for(recipe, inventory)
- CraftRecipeDB.to_dict() / CraftRecipeDB.from_dict()
"""

from __future__ import annotations

from collections import defaultdict
from dataclasses import dataclass
import json
import re
from typing import Any, Dict, Iterable, List, Mapping, Optional, Sequence, Set, Tuple

from analyzer import (
    LuaCallExtractor,
    LuaRaw,
    LuaTableValue,
    find_matching,
    lua_to_python,
    parse_lua_expr,
    parse_lua_string,
    strip_lua_comments,
)

__all__ = [
    "CraftRecipeDB",
    "parse_filter_defs",
]


# =========================================================
# Regex helpers
# =========================================================

_TECH_TOKEN_RE = re.compile(r"\bTECH\.[A-Z0-9_]+\b")
_TAB_TOKEN_RE = re.compile(r"\bRECIPETABS\.[A-Z0-9_]+\b")
_FILTER_TOKEN_RE = re.compile(r"\bCRAFTING_FILTERS\.([A-Z0-9_]+)\b")
_FILTER_ASSIGN_RE = re.compile(r"\bCRAFTING_FILTERS\.([A-Z0-9_]+)\.recipes\s*=\s*\{", re.MULTILINE)

# string literals inside a table list; recipes_filter.lua uses plain quoted names
_QUOTED_STR_RE = re.compile(r"([\"'])([^\"']+)\1")

# If a "{ ... }" argument contains '=', it is most likely a config table not a filter list.
# This heuristic is intentionally conservative.


# =========================================================
# Data model helpers
# =========================================================

def _dedup_preserve(seq: Iterable[str]) -> List[str]:
    out: List[str] = []
    seen: Set[str] = set()
    for x in seq:
        if not x:
            continue
        if x in seen:
            continue
        seen.add(x)
        out.append(x)
    return out


def _looks_like_kv_table(expr_text: str) -> bool:
    s = (expr_text or "").strip()
    return s.startswith("{") and ("=" in s)


def _extract_first_token(rx: re.Pattern[str], text: str) -> Optional[str]:
    m = rx.search(text or "")
    return m.group(0) if m else None


_NUM_RE = re.compile(r"^[+-]?(?:\d+\.?\d*|\d*\.?\d+)(?:[eE][+-]?\d+)?$")


def _to_amount(expr_text: str) -> Tuple[Optional[float], str]:
    """Return (amount_num, amount_expr)."""
    raw = (expr_text or "").strip() or "1"

    # Fast path numeric
    if _NUM_RE.match(raw):
        try:
            return float(raw), raw
        except Exception:
            return None, raw

    v = parse_lua_expr(raw)
    if isinstance(v, (int, float)):
        return float(v), raw

    # LuaRaw with a numeric string
    if isinstance(v, LuaRaw) and _NUM_RE.match(v.text.strip()):
        try:
            return float(v.text.strip()), raw
        except Exception:
            pass

    return None, raw


def _parse_string_list(v: Any) -> List[str]:
    """Try to turn a Lua table value into a list[str]."""
    if isinstance(v, LuaTableValue):
        out: List[str] = []
        for x in v.array:
            if isinstance(x, str):
                out.append(x)
            elif isinstance(x, LuaRaw):
                # keep raw symbol if it looks like a string constant
                out.append(x.text)
            else:
                py = lua_to_python(x)
                if isinstance(py, str):
                    out.append(py)
        return _dedup_preserve(out)

    py = lua_to_python(v)
    if isinstance(py, list):
        return _dedup_preserve([str(x) for x in py if x is not None])

    return []


def _parse_config_fields(tbl: LuaTableValue) -> Dict[str, Any]:
    """Extract commonly useful fields from a recipe config table."""
    out: Dict[str, Any] = {}

    for k, v in (tbl.map or {}).items():
        if not isinstance(k, str):
            continue

        if k in {
            "builder_tag",
            "builder_skill",
            "station_tag",
            "product",
            "placer",
            "image",
            "atlas",
            "nounlock",
            "numtogive",
            "min_spacing",
            "testfn",  # sometimes exists
        }:
            out[k] = lua_to_python(v)
        elif k in {"builder_tags"}:
            out[k] = _parse_string_list(v)
        # Keep unknown keys out for now (index bloat).

    # normalize: builder_tags may be an object/dict if table is keyed; accept only list
    if "builder_tags" in out and not isinstance(out["builder_tags"], list):
        out.pop("builder_tags", None)

    return out


def _parse_filters_from_text(expr_text: str) -> List[str]:
    if not expr_text:
        return []

    filters: List[str] = []

    # CRAFTING_FILTERS.NAME tokens
    filters += [m.group(1) for m in _FILTER_TOKEN_RE.finditer(expr_text)]

    # quoted uppercase strings (rare but exists in some mods)
    for q in re.findall(r"[\"']([A-Z0-9_]+)[\"']", expr_text):
        if q and q.upper() == q:
            filters.append(q)

    return _dedup_preserve([f.upper() for f in filters if f])


# =========================================================
# Parsing: recipes.lua / recipes2.lua
# =========================================================


def _parse_ingredients_from_expr(expr_text: str) -> Tuple[List[Dict[str, Any]], List[str]]:
    """Extract Ingredient("item", amount) calls.

    Returns (ingredients, unresolved_items).

    Ingredient amount is stored as:
    - amount: original expression string
    - amount_num: parsed float if possible (else None)
    """
    if not expr_text:
        return [], []

    out: List[Dict[str, Any]] = []
    unresolved: List[str] = []

    ex = LuaCallExtractor(expr_text)
    for call in ex.iter_calls(["Ingredient"], include_member_calls=False):
        if not call.arg_list:
            continue

        item_expr = call.arg_list[0].strip()
        item = parse_lua_string(item_expr) or item_expr

        if len(call.arg_list) >= 2:
            amount_expr = call.arg_list[1]
        else:
            amount_expr = "1"

        amount_num, amount_raw = _to_amount(amount_expr)

        rec = {
            "item": item,
            "amount": amount_raw,
            "amount_num": amount_num,
        }
        out.append(rec)

        if amount_num is None:
            unresolved.append(str(item))

    return out, _dedup_preserve(unresolved)


def _init_recipe_record(name: str) -> Dict[str, Any]:
    return {
        "name": name,
        "product": name,  # default: in most DST recipes, name == prefab product
        "ingredients": [],
        "ingredients_unresolved": [],
        "tech": "UNKNOWN",
        "tab": "UNKNOWN",  # assigned later from filter membership
        "filters": [],
        "builder_tag": None,
        "builder_tags": [],
        "builder_skill": None,
        "station_tag": None,
        "sources": [],
        # optional metadata (for GUI)
        "image": None,
        "atlas": None,
        "placer": None,
        "nounlock": None,
        "numtogive": None,
    }


def _parse_recipe_call(call_name: str, args: Sequence[str]) -> Optional[Dict[str, Any]]:
    """Parse a Recipe/Recipe2/AddRecipe2 call into a recipe record."""
    if not args:
        return None

    name = parse_lua_string(args[0])
    if not name:
        return None

    rec = _init_recipe_record(name)
    rec["sources"].append(call_name)

    # ingredients: usually arg[1]
    if len(args) >= 2:
        ing, unresolved = _parse_ingredients_from_expr(args[1])
        if ing:
            rec["ingredients"] = ing
        if unresolved:
            rec["ingredients_unresolved"] = unresolved

    # tech: usually arg[2], but also scan whole call for TECH.X
    tech = None
    if len(args) >= 3:
        tech = _extract_first_token(_TECH_TOKEN_RE, args[2])
    if tech is None:
        tech = _extract_first_token(_TECH_TOKEN_RE, " ".join(args))
    if tech:
        rec["tech"] = tech

    # explicit RECIPETABS (legacy) if present
    tab = _extract_first_token(_TAB_TOKEN_RE, " ".join(args))
    if tab:
        rec["tab"] = tab

    # parse remaining args: config tables and/or explicit filter lists
    for a in args[2:]:
        a = (a or "").strip()
        if not a.startswith("{"):
            # Sometimes filters are passed as plain symbols; token-scan anyway.
            fs = _parse_filters_from_text(a)
            if fs:
                rec["filters"] = _dedup_preserve(list(rec.get("filters", [])) + fs)
            continue

        v = parse_lua_expr(a)
        if isinstance(v, LuaTableValue) and _looks_like_kv_table(a):
            fields = _parse_config_fields(v)
            for k, val in fields.items():
                if k == "builder_tags":
                    rec["builder_tags"] = _dedup_preserve(list(rec.get("builder_tags") or []) + list(val or []))
                    continue
                if val is None:
                    continue
                if rec.get(k) in (None, "UNKNOWN", [], {}):
                    rec[k] = val
                else:
                    # avoid overwriting unless empty
                    pass

            # product override
            if fields.get("product"):
                rec["product"] = fields.get("product")

        else:
            fs = _parse_filters_from_text(a)
            if fs:
                rec["filters"] = _dedup_preserve(list(rec.get("filters", [])) + fs)

    # Normalize builder_tags
    if rec.get("builder_tag"):
        rec["builder_tags"] = _dedup_preserve(list(rec.get("builder_tags") or []) + [str(rec["builder_tag"])])

    return rec


def parse_craft_recipes(recipes_lua: str, recipes2_lua: str) -> Dict[str, Dict[str, Any]]:
    """Parse craft recipes from recipes.lua + recipes2.lua.

    - recipes.lua: Recipe/Recipe2
    - recipes2.lua: AddRecipe2

    Returns dict: name -> recipe_record
    """
    out: Dict[str, Dict[str, Any]] = {}

    for src, fnames in ((recipes_lua or "", ["Recipe", "Recipe2"]), (recipes2_lua or "", ["AddRecipe2"])):
        if not src:
            continue
        ex = LuaCallExtractor(src)
        for call in ex.iter_calls(fnames, include_member_calls=False):
            rec = _parse_recipe_call(call.name, call.arg_list)
            if not rec:
                continue
            name = rec["name"]
            if name not in out:
                out[name] = rec
            else:
                # Merge: later source wins for missing fields; union for lists.
                cur = out[name]
                cur["sources"] = _dedup_preserve(list(cur.get("sources", [])) + list(rec.get("sources", [])))

                # ingredients: keep first non-empty
                if (not cur.get("ingredients")) and rec.get("ingredients"):
                    cur["ingredients"] = rec["ingredients"]

                # union unresolved
                cur["ingredients_unresolved"] = _dedup_preserve(
                    list(cur.get("ingredients_unresolved") or []) + list(rec.get("ingredients_unresolved") or [])
                )

                # prefer concrete tech
                if cur.get("tech") in (None, "", "UNKNOWN") and rec.get("tech") not in (None, "", "UNKNOWN"):
                    cur["tech"] = rec["tech"]

                # union filters
                cur["filters"] = _dedup_preserve(list(cur.get("filters") or []) + list(rec.get("filters") or []))

                # fill other scalar fields if empty
                for k in (
                    "builder_tag",
                    "builder_skill",
                    "station_tag",
                    "product",
                    "tab",
                    "image",
                    "atlas",
                    "placer",
                    "nounlock",
                    "numtogive",
                ):
                    if cur.get(k) in (None, "", "UNKNOWN") and rec.get(k) not in (None, "", "UNKNOWN"):
                        cur[k] = rec[k]

                # builder_tags union
                cur["builder_tags"] = _dedup_preserve(list(cur.get("builder_tags") or []) + list(rec.get("builder_tags") or []))

    return out


# =========================================================
# Parsing: recipes_filter.lua
# =========================================================


def parse_filter_defs(src: str) -> List[Dict[str, Any]]:
    """Parse the CRAFTING_FILTER_DEFS table as an ordered list of dicts."""
    if not src:
        return []

    clean = strip_lua_comments(src)
    idx = clean.find("CRAFTING_FILTER_DEFS")
    if idx == -1:
        return []

    brace = clean.find("{", idx)
    if brace == -1:
        return []

    end = find_matching(clean, brace, "{", "}")
    if end is None:
        return []

    block = clean[brace : end + 1]
    tbl = parse_lua_expr(block)
    if not isinstance(tbl, LuaTableValue):
        return []

    defs: List[Dict[str, Any]] = []
    for entry in tbl.array:
        if not isinstance(entry, LuaTableValue):
            continue
        d: Dict[str, Any] = {}
        for k, v in entry.map.items():
            if isinstance(k, str):
                d[k] = lua_to_python(v)
        if d:
            defs.append(d)

    return defs


def _parse_filter_order(src: str) -> List[str]:
    defs = parse_filter_defs(src)
    order: List[str] = []
    for d in defs:
        nm = d.get("name")
        if isinstance(nm, str) and nm:
            order.append(nm.upper())
    return order


def _parse_filter_recipe_lists(src: str) -> Dict[str, List[str]]:
    """Parse `CRAFTING_FILTERS.X.recipes = { ... }` lists."""
    out: Dict[str, List[str]] = {}
    if not src:
        return out

    clean = strip_lua_comments(src)

    for m in _FILTER_ASSIGN_RE.finditer(clean):
        flt = m.group(1).upper()
        brace = m.end() - 1
        end = find_matching(clean, brace, "{", "}")
        if end is None:
            continue
        inner = clean[brace + 1 : end]
        names = [sm.group(2) for sm in _QUOTED_STR_RE.finditer(inner)]
        # recipes list is typically plain strings (prefab names)
        out[flt] = _dedup_preserve(names)

    return out


def _parse_filter_bindings_by_calls(src: str) -> Dict[str, List[str]]:
    """Parse AddRecipeToFilter(s) calls.

    Returns: recipe_name -> [filters...]
    """
    out: Dict[str, List[str]] = defaultdict(list)
    if not src:
        return out

    ex = LuaCallExtractor(src)
    for call in ex.iter_calls(["AddRecipeToFilter", "AddRecipeToFilters"], include_member_calls=False):
        args = call.arg_list
        if not args:
            continue

        # recipe name is usually the first non-UPPERCASE string literal
        recipe_name: Optional[str] = None
        for a in args:
            s = parse_lua_string(a)
            if s and not s.isupper():
                recipe_name = s
                break
        if recipe_name is None:
            for a in args:
                s = parse_lua_string(a)
                if s:
                    recipe_name = s
                    break
        if not recipe_name:
            continue

        filters: List[str] = []
        for a in args:
            filters += _parse_filters_from_text(a)

        if filters:
            out[recipe_name] = _dedup_preserve(list(out.get(recipe_name, [])) + filters)

    return out


# =========================================================
# CraftRecipeDB (public)
# =========================================================


class CraftRecipeDB:
    """Queryable craft recipe database.

    Build sources:
    - recipes.lua / recipes2.lua (Recipe/Recipe2/AddRecipe2)
    - recipes_filter.lua (filters order + filter membership)

    Notes
    - `tab` is derived from filter order: first non-special filter in membership.
    - `filters` holds all known filter memberships.
    """

    _SPECIAL_FILTERS = {"FAVORITES", "CRAFTING_STATION", "SPECIAL_EVENT", "MODS", "CHARACTER", "EVERYTHING"}

    def __init__(self, *args, **kwargs):
        """Supported initializers:

        - CraftRecipeDB(recipes_lua=..., recipes2_lua=..., recipes_filter_lua=...)
        - CraftRecipeDB(recipes_lua, recipes2_lua, recipes_filter_lua)
        - CraftRecipeDB(recipes_lua, recipes_filter_lua)  # legacy fallback
        """
        recipes_lua = kwargs.get("recipes_lua", "")
        recipes2_lua = kwargs.get("recipes2_lua", "")
        recipes_filter_lua = kwargs.get("recipes_filter_lua", "")

        if args:
            if len(args) == 1:
                recipes_lua = args[0]
            elif len(args) == 2:
                recipes_lua = args[0]
                recipes_filter_lua = args[1]
            else:
                recipes_lua = args[0]
                recipes2_lua = args[1]
                recipes_filter_lua = args[2]

        self.recipes: Dict[str, Dict[str, Any]] = {}
        self.aliases: Dict[str, str] = {}

        self.filter_defs: List[Dict[str, Any]] = []
        self.filter_order: List[str] = []
        self.tab_order: List[str] = []

        self.by_tab: Dict[str, List[str]] = defaultdict(list)
        self.by_filter: Dict[str, List[str]] = defaultdict(list)
        self.by_tech: Dict[str, List[str]] = defaultdict(list)
        self.by_builder_tag: Dict[str, List[str]] = defaultdict(list)
        self.by_ingredient: Dict[str, List[str]] = defaultdict(list)

        self._build(recipes_lua or "", recipes2_lua or "", recipes_filter_lua or "")

    # -----------------
    # build
    # -----------------

    def _build(self, recipes_lua: str, recipes2_lua: str, recipes_filter_lua: str) -> None:
        # 1) base recipes
        self.recipes = parse_craft_recipes(recipes_lua, recipes2_lua)

        # 2) aliases
        for name in self.recipes.keys():
            self.aliases[name.lower()] = name
            self.aliases[name.replace("_", "").lower()] = name

        # 3) filter defs + membership
        self.filter_defs = parse_filter_defs(recipes_filter_lua)
        self.filter_order = _parse_filter_order(recipes_filter_lua)
        filter_lists = _parse_filter_recipe_lists(recipes_filter_lua)
        call_bindings = _parse_filter_bindings_by_calls(recipes_filter_lua)

        # membership: recipe -> filters
        membership: Dict[str, Set[str]] = {name: set(map(str.upper, (self.recipes[name].get("filters") or []))) for name in self.recipes.keys()}

        # from `CRAFTING_FILTERS.X.recipes = {...}`
        for flt, rlist in filter_lists.items():
            for r in rlist:
                if r in membership:
                    membership[r].add(flt)

        # from AddRecipeToFilter(s)
        for r, fs in call_bindings.items():
            if r in membership:
                for f in fs:
                    membership[r].add(f.upper())

        # 4) finalize per recipe: filters, tab
        for name, rec in self.recipes.items():
            fset = membership.get(name, set())
            # include whatever was already present
            rec["filters"] = sorted(_dedup_preserve([f.upper() for f in fset if f]))

            # choose tab: first non-special in defs order
            chosen: Optional[str] = None
            for f in self.filter_order:
                if f in fset and f not in self._SPECIAL_FILTERS:
                    chosen = f
                    break
            if chosen is None:
                # fallback: any in order
                for f in self.filter_order:
                    if f in fset:
                        chosen = f
                        break
            rec["tab"] = chosen or rec.get("tab") or "UNKNOWN"

            # normalize builder_tags again (after merges)
            if rec.get("builder_tag"):
                rec["builder_tags"] = _dedup_preserve(list(rec.get("builder_tags") or []) + [str(rec["builder_tag"])])
            else:
                rec["builder_tags"] = _dedup_preserve(list(rec.get("builder_tags") or []))

        # 5) build indices
        # by_filter / by_tab
        for name, rec in self.recipes.items():
            for f in rec.get("filters", []) or []:
                self.by_filter[str(f).upper()].append(name)

            t = str(rec.get("tab") or "UNKNOWN").upper()
            self.by_tab[t].append(name)

            # by_tech
            tech = str(rec.get("tech") or "UNKNOWN")
            if tech.upper().startswith("TECH."):
                tech = tech.split(".", 1)[1]
            self.by_tech[tech.upper()].append(name)

            # by_builder_tag(s)
            for bt in rec.get("builder_tags") or []:
                if bt:
                    self.by_builder_tag[str(bt).lower()].append(name)

            # by_ingredient
            for ing in rec.get("ingredients") or []:
                it = ing.get("item")
                if it:
                    self.by_ingredient[str(it).lower()].append(name)

        # sort & unique
        for mp in (self.by_filter, self.by_tab, self.by_tech, self.by_builder_tag, self.by_ingredient):
            for k in list(mp.keys()):
                mp[k] = sorted(set(mp[k]))

        # tab order: filter_order excluding specials
        self.tab_order = [f for f in self.filter_order if f and f not in self._SPECIAL_FILTERS]

    # -----------------
    # Public query API
    # -----------------

    def __len__(self) -> int:
        return len(self.recipes)

    def get(self, query_name: str) -> Tuple[Optional[str], Optional[Dict[str, Any]]]:
        if not query_name:
            return None, None
        q = query_name.strip().lower()
        canonical = self.aliases.get(q) or self.aliases.get(q.replace("_", ""))
        if not canonical:
            return None, None
        return canonical, self.recipes.get(canonical)

    def list_tabs(self) -> List[str]:
        return list(self.tab_order)

    def list_filters(self) -> List[str]:
        return list(self.filter_order)

    def list_by_tab(self, tab: str) -> List[str]:
        key = (tab or "").strip().upper()
        # allow TECH/RECIPETABS raw
        if key.startswith("RECIPETABS."):
            key = key.split(".", 1)[1]
        return list(self.by_tab.get(key, []))

    def list_by_filter(self, flt: str) -> List[str]:
        key = (flt or "").strip().upper()
        if key.startswith("CRAFTING_FILTERS."):
            key = key.split(".", 1)[1]
        return list(self.by_filter.get(key, []))

    def list_by_builder_tag(self, tag: str) -> List[str]:
        key = (tag or "").strip().lower()
        return list(self.by_builder_tag.get(key, []))

    def list_by_tech(self, tech: str) -> List[str]:
        t = (tech or "").strip()
        if t.upper().startswith("TECH."):
            t = t.split(".", 1)[1]
        return list(self.by_tech.get(t.upper(), []))

    def list_by_ingredient(self, item: str) -> List[str]:
        key = (item or "").strip().lower()
        return list(self.by_ingredient.get(key, []))

    # -----------------
    # Craft planner (M2)
    # -----------------

    def missing_for(self, recipe_name: str, inventory: Mapping[str, float]) -> List[Dict[str, Any]]:
        """Return missing ingredients for a recipe under a given inventory.

        Inventory is a mapping item->count (int/float).

        If an ingredient has non-numeric amount (amount_num is None), it is returned
        as missing with reason="unresolved_amount".
        """
        _, rec = self.get(recipe_name)
        if not rec:
            return []

        inv = {str(k).lower(): float(v) for k, v in (inventory or {}).items()}

        missing: List[Dict[str, Any]] = []
        for ing in rec.get("ingredients") or []:
            item = str(ing.get("item") or "").lower()
            if not item:
                continue
            need_num = ing.get("amount_num")
            need_expr = ing.get("amount")
            have = inv.get(item, 0.0)

            if need_num is None:
                missing.append({"item": item, "need": need_expr, "have": have, "reason": "unresolved_amount"})
                continue

            if have + 1e-9 < float(need_num):
                missing.append({"item": item, "need": need_num, "have": have, "reason": "insufficient"})

        return missing

    def craftable(
        self,
        inventory: Mapping[str, float],
        *,
        builder_tag: Optional[str] = None,
        strict: bool = True,
    ) -> List[str]:
        """List craftable recipes.

        - builder_tag: if set, only recipes that are not character-locked or match builder_tag.
        - strict: if True, recipes with unresolved ingredient amounts are excluded.
        """
        inv = {str(k).lower(): float(v) for k, v in (inventory or {}).items()}
        bt = builder_tag.strip().lower() if builder_tag else None

        out: List[str] = []
        for name, rec in self.recipes.items():
            # builder constraints
            if bt:
                tags = [str(x).lower() for x in (rec.get("builder_tags") or [])]
                if tags and bt not in tags:
                    continue

            miss = self.missing_for(name, inv)
            if not miss:
                out.append(name)
            else:
                if strict:
                    continue
                # if not strict, allow unresolved-only
                if all(m.get("reason") == "unresolved_amount" for m in miss):
                    out.append(name)

        return sorted(out)

    # -----------------
    # Serialization (M2)
    # -----------------

    def to_dict(self) -> Dict[str, Any]:
        """JSON-serializable snapshot (do not include derived indices)."""
        return {
            "schema": 1,
            "recipes": self.recipes,
            "aliases": self.aliases,
            "filter_defs": self.filter_defs,
            "filter_order": self.filter_order,
        }

    @classmethod
    def from_dict(cls, data: Mapping[str, Any]) -> "CraftRecipeDB":
        """Load from `to_dict()` output."""
        obj = cls(recipes_lua="", recipes2_lua="", recipes_filter_lua="")

        obj.recipes = {str(k): v for k, v in (data.get("recipes") or {}).items()}
        obj.aliases = {str(k): str(v) for k, v in (data.get("aliases") or {}).items()}
        obj.filter_defs = list(data.get("filter_defs") or [])
        obj.filter_order = [str(x).upper() for x in (data.get("filter_order") or [])]
        obj.tab_order = [f for f in obj.filter_order if f and f not in obj._SPECIAL_FILTERS]

        # rebuild indices
        obj.by_tab = defaultdict(list)
        obj.by_filter = defaultdict(list)
        obj.by_tech = defaultdict(list)
        obj.by_builder_tag = defaultdict(list)
        obj.by_ingredient = defaultdict(list)

        for name, rec in obj.recipes.items():
            for f in rec.get("filters", []) or []:
                obj.by_filter[str(f).upper()].append(name)
            t = str(rec.get("tab") or "UNKNOWN").upper()
            obj.by_tab[t].append(name)

            tech = str(rec.get("tech") or "UNKNOWN")
            if tech.upper().startswith("TECH."):
                tech = tech.split(".", 1)[1]
            obj.by_tech[tech.upper()].append(name)

            for bt in rec.get("builder_tags") or []:
                if bt:
                    obj.by_builder_tag[str(bt).lower()].append(name)

            for ing in rec.get("ingredients") or []:
                it = ing.get("item")
                if it:
                    obj.by_ingredient[str(it).lower()].append(name)

        for mp in (obj.by_filter, obj.by_tab, obj.by_tech, obj.by_builder_tag, obj.by_ingredient):
            for k in list(mp.keys()):
                mp[k] = sorted(set(mp[k]))

        return obj

    def dumps(self, *, indent: int = 2, ensure_ascii: bool = False) -> str:
        return json.dumps(self.to_dict(), ensure_ascii=ensure_ascii, indent=indent)
```

### File: src/doctor.py
- mode: interface
- size_bytes: 7012
- sha256_12: 69d9d480c023

```py
# Constants
PROJECT_ROOT = Path(__file__).resolve().parent.parent
CONFIG_PATH = PROJECT_ROOT / 'conf' / 'settings.ini'

def _expand(p: str) -> str:
    ...

def _cfg_get(cfg: configparser.ConfigParser, section: str, key: str) -> str:
    ...

def _status(level: str) -> str:
    ...

def _check_path_exists(path: Path, kind: str, fix: str=''):
    ...

def main() -> int:
    ...
```

### File: src/engine.py
- mode: full
- size_bytes: 13329
- sha256_12: b04e61d84e94

```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""WagstaffEngine (core)

This module is intentionally UI-agnostic.

Responsibilities
- Mount DST scripts source (zip or folder) with a consistent "scripts/..." namespace.
- Provide fast `read_file()` + `find_file()` primitives.
- Load small, stable databases:
  - TuningResolver (scripts/tuning.lua)
  - CraftRecipeDB (scripts/recipes.lua + scripts/recipes2.lua + scripts/recipes_filter.lua)
  - CookingRecipeAnalyzer (scripts/preparedfoods.lua + scripts/prefabs/preparedfoods.lua)

Design notes
- Engine must be usable by CLI, GUI, and Web layers.
- Avoid hard dependency on Rich (it is optional). Use `silent=True` to suppress logs.
"""

from __future__ import annotations

import logging
import os
import zipfile
from functools import lru_cache
from pathlib import Path
from typing import Dict, List, Optional, Tuple

# Optional project config (exists in repo under src/utils.py)
try:
    from utils import wagstaff_config  # type: ignore
except Exception:  # pragma: no cover
    wagstaff_config = None  # type: ignore

from analyzer import CookingRecipeAnalyzer, LuaAnalyzer, TuningResolver
from craft_recipes import CraftRecipeDB

logger = logging.getLogger(__name__)


def _expanduser(p: Optional[str]) -> Optional[str]:
    return os.path.expanduser(p) if p else None


class WagstaffEngine:
    """Main entry used by CLI / devtools / GUI / Web.

    Parameters
    - load_db: load tuning + recipe DBs (and cooking recipes).
    - silent: suppress all logs.
    - dst_root: optional DST root path (overrides config).
    - scripts_zip: optional scripts zip path (highest priority).
    - scripts_dir: optional scripts folder path (highest priority for folder mode).
    - prefer_local_bundles: search project-root bundle drops first.
    """

    def __init__(
        self,
        load_db: bool = True,
        silent: bool = False,
        *,
        dst_root: Optional[str] = None,
        scripts_zip: Optional[str] = None,
        scripts_dir: Optional[str] = None,
        prefer_local_bundles: bool = True,
        encoding: str = "utf-8",
    ):
        self.encoding = encoding
        self.silent = bool(silent)

        self.mode: str = ""  # 'zip' | 'folder'
        self.source: object = None  # ZipFile or folder path (str)
        self.file_list: List[str] = []

        # basename index for fast fuzzy find
        self._basename_index: Dict[str, List[str]] = {}

        self.tuning: Optional[TuningResolver] = None
        self.recipes: Optional[CraftRecipeDB] = None
        self.cooking_recipes: Dict[str, Dict] = {}

        self._init_source(
            dst_root=dst_root,
            scripts_zip=scripts_zip,
            scripts_dir=scripts_dir,
            prefer_local_bundles=prefer_local_bundles,
        )
        self._build_basename_index()

        if load_db:
            self._init_databases()

    # --------------------------------------------------------
    # Context manager
    # --------------------------------------------------------

    def __enter__(self) -> "WagstaffEngine":
        return self

    def __exit__(self, exc_type, exc, tb) -> None:
        self.close()

    # --------------------------------------------------------
    # Source mounting
    # --------------------------------------------------------

    def _project_root(self) -> Path:
        """Best-effort repo root.

        - Prefer wagstaff_config.project_root when available.
        - Fallback to src/.. (engine.py is expected under src/).
        """
        if wagstaff_config is not None and hasattr(wagstaff_config, "project_root"):
            try:
                return Path(str(wagstaff_config.project_root)).resolve()
            except Exception:
                pass
        # engine.py is usually src/engine.py
        return Path(__file__).resolve().parent.parent

    def _detect_candidates(self, dst_root: Optional[str], prefer_local_bundles: bool) -> Tuple[List[str], List[str]]:
        """Return (zip_candidates, dir_candidates)."""
        pr = self._project_root()

        dst_root = _expanduser(dst_root)
        if dst_root is None and wagstaff_config is not None:
            try:
                dst_root = _expanduser(wagstaff_config.get("PATHS", "DST_ROOT"))
            except Exception:
                dst_root = None

        zip_candidates: List[str] = []
        dir_candidates: List[str] = []

        # Prefer local bundle drops for faster iteration
        if prefer_local_bundles:
            zip_candidates += [
                str(pr / "scripts-no-language-pac.zip"),
                str(pr / "scripts_no_language.zip"),
                str(pr / "scripts.zip"),
                str(pr / "data" / "databundles" / "scripts.zip"),
            ]
            dir_candidates += [
                str(pr / "scripts"),
            ]

        if dst_root:
            zip_candidates += [
                os.path.join(dst_root, "data", "databundles", "scripts.zip"),
                os.path.join(dst_root, "data", "databundles", "scripts_no_language.zip"),
            ]
            dir_candidates += [
                os.path.join(dst_root, "data", "scripts"),
            ]

        return zip_candidates, dir_candidates

    def _log(self, msg: str) -> None:
        if not self.silent:
            logger.info(msg)

    def _init_source(
        self,
        *,
        dst_root: Optional[str],
        scripts_zip: Optional[str],
        scripts_dir: Optional[str],
        prefer_local_bundles: bool,
    ) -> None:
        # explicit overrides
        if scripts_zip:
            zp = _expanduser(scripts_zip)
            if zp and os.path.exists(zp):
                self.mode = "zip"
                self.source = zipfile.ZipFile(zp, "r")
                self.file_list = list(getattr(self.source, "namelist")())
                self._log(f"Mounted scripts zip: {zp}")
                return

        if scripts_dir:
            dp = _expanduser(scripts_dir)
            if dp and os.path.isdir(dp):
                self.mode = "folder"
                self.source = dp
                self.file_list = self._walk_folder(dp)
                self._log(f"Mounted scripts folder: {dp}")
                return

        zip_candidates, dir_candidates = self._detect_candidates(dst_root, prefer_local_bundles)

        for zp in zip_candidates:
            if zp and os.path.exists(zp):
                self.mode = "zip"
                self.source = zipfile.ZipFile(zp, "r")
                self.file_list = list(getattr(self.source, "namelist")())
                self._log(f"Mounted scripts zip: {zp}")
                return

        for dp in dir_candidates:
            if dp and os.path.isdir(dp):
                self.mode = "folder"
                self.source = dp
                self.file_list = self._walk_folder(dp)
                self._log(f"Mounted scripts folder: {dp}")
                return

        raise FileNotFoundError("Cannot find scripts source (zip or folder).")

    def _walk_folder(self, folder: str) -> List[str]:
        folder = os.path.abspath(folder)
        out: List[str] = []
        for root, _, files in os.walk(folder):
            for name in files:
                full = os.path.join(root, name)
                rel = os.path.relpath(full, folder).replace("\\", "/")
                out.append("scripts/" + rel)  # normalize namespace
        return out

    def _build_basename_index(self) -> None:
        mp: Dict[str, List[str]] = {}
        for p in self.file_list:
            if not p.endswith(".lua"):
                continue
            base = os.path.basename(p)
            key = base.replace(".lua", "").replace("_", "").lower()
            mp.setdefault(key, []).append(p)
        self._basename_index = mp

    # --------------------------------------------------------
    # IO
    # --------------------------------------------------------

    def _normalize_path_candidates(self, path: str) -> List[str]:
        p = (path or "").replace("\\", "/").lstrip("/")
        if not p:
            return []
        if p.startswith("scripts/"):
            return [p, p.replace("scripts/", "", 1)]
        return [p, "scripts/" + p]

    @lru_cache(maxsize=4096)
    def read_file(self, path: str) -> Optional[str]:
        """Read a UTF-8 text file from the mounted source.

        Accepts paths with or without the "scripts/" prefix.
        Returns None if not found.
        """
        candidates = self._normalize_path_candidates(path)
        if not candidates:
            return None

        try:
            if self.mode == "zip":
                zf: zipfile.ZipFile = self.source  # type: ignore[assignment]
                for p in candidates:
                    if p in self.file_list:
                        return zf.read(p).decode(self.encoding, errors="replace")
                return None

            # folder
            base: str = self.source  # type: ignore[assignment]
            for p in candidates:
                real = os.path.join(base, p.replace("scripts/", "", 1))
                if os.path.exists(real):
                    with open(real, "r", encoding=self.encoding, errors="replace") as f:
                        return f.read()
        except Exception:
            return None

        return None

    def find_file(self, name: str, fuzzy: bool = True) -> Optional[str]:
        """Find a file by short name.

        Examples
        - armorwood -> scripts/prefabs/armorwood.lua (or armor_wood.lua)
        - prefabs/armorwood.lua -> scripts/prefabs/armorwood.lua

        Returns a path in the normalized namespace (usually "scripts/...").
        """
        if not name:
            return None
        q = name.replace("\\", "/").strip()
        if not q:
            return None

        # direct hit if user passed a path
        for cand in self._normalize_path_candidates(q):
            if cand in self.file_list:
                return cand

        base = q.replace(".lua", "")
        candidates = [
            f"scripts/prefabs/{base}.lua",
            f"scripts/{base}.lua",
            f"scripts/{base}",
        ]
        for c in candidates:
            if c in self.file_list:
                return c

        if not fuzzy:
            return None

        key = os.path.basename(base).replace("_", "").lower()
        hits = self._basename_index.get(key)
        if hits:
            # prefer prefabs if ambiguous
            if len(hits) == 1:
                return hits[0]
            pref = [h for h in hits if h.startswith("scripts/prefabs/")]
            if len(pref) == 1:
                return pref[0]
            return hits[0]

        # final fallback: scan
        target = key
        for fname in self.file_list:
            if not fname.endswith(".lua"):
                continue
            b = os.path.basename(fname).replace(".lua", "").replace("_", "").lower()
            if b == target:
                return fname

        return None

    def close(self) -> None:
        if self.mode == "zip" and self.source is not None:
            try:
                self.source.close()  # type: ignore[attr-defined]
            except Exception:
                pass

    # --------------------------------------------------------
    # DB initialization
    # --------------------------------------------------------

    def _init_databases(self) -> None:
        self._log("Loading tuning / crafting / cooking databases...")

        t_content = self.read_file("scripts/tuning.lua") or self.read_file("tuning.lua") or ""
        self.tuning = TuningResolver(t_content)

        r1 = self.read_file("scripts/recipes.lua") or self.read_file("recipes.lua") or ""
        r2 = self.read_file("scripts/recipes2.lua") or self.read_file("recipes2.lua") or ""
        rf = self.read_file("scripts/recipes_filter.lua") or self.read_file("recipes_filter.lua") or ""
        self.recipes = CraftRecipeDB(recipes_lua=r1, recipes2_lua=r2, recipes_filter_lua=rf)

        # cooking recipes (optional)
        food_src = self.read_file("scripts/preparedfoods.lua") or ""
        if food_src:
            self.cooking_recipes.update(CookingRecipeAnalyzer(food_src).recipes)

        food_prefab_src = self.read_file("scripts/prefabs/preparedfoods.lua") or ""
        if food_prefab_src:
            # prefab file often contains the same table; merge (prefab wins)
            self.cooking_recipes.update(CookingRecipeAnalyzer(food_prefab_src).recipes)

    # --------------------------------------------------------
    # High-level helpers
    # --------------------------------------------------------

    def analyze_prefab(self, item_name: str) -> Optional[Dict]:
        """High-level prefab analysis (LuaAnalyzer + tuning enrichment)."""
        path = self.find_file(item_name, fuzzy=True)
        if not path:
            return None

        content = self.read_file(path)
        if not content:
            return None

        data = LuaAnalyzer(content, path=path).get_report()

        if self.tuning:
            for comp in data.get("components", []) or []:
                comp["properties"] = [self.tuning.enrich(p) for p in comp.get("properties", [])]
                comp["methods"] = [self.tuning.enrich(m) for m in comp.get("methods", [])]

        return data
```

### File: src/explorer.py
- mode: interface
- size_bytes: 9616
- sha256_12: 6f0febfb5667

```py
class DSTExplorer:
    ...
    def get_structure_tree(self):  # 展示源码目录结构
    def search_files(self):  # 文件名搜索
    def analyze_content(self, filename, content):  # 核心分析逻辑：根据 analyzer 返回的类型进行多态渲染
    def _render_loot(self, tree, data):  # 渲染掉落表数据
    def _render_widget(self, tree, data):  # 渲染 UI Widget 数据
    def _render_strings(self, tree, data):  # 渲染文本配置数据
    def _render_prefab(self, tree, data):  # 渲染实体 Prefab 数据 (包含 Tuning 增强)
    def preview_file(self):  # 文件预览入口
    def show_tuning(self):  # 展示 Tuning 样本

def main():
    ...
```

### File: src/klei_atlas_tex.py
- mode: interface
- size_bytes: 17056
- sha256_12: 9e1cb85f9889

```py
"""klei_atlas_tex.py"""

class AtlasElement:
    ...

class Atlas:
    """Parsed atlas XML."""
    def get(self, name: str) -> Optional[AtlasElement]:

def _xml_find_first(root: ET.Element, tag_local_name: str) -> Optional[ET.Element]:
    ...

def _xml_find_all(root: ET.Element, tag_local_name: str) -> List[ET.Element]:
    ...

def parse_atlas_xml(xml_text: str) -> Atlas:
    """Parse a Klei atlas XML into an Atlas object."""

def atlas_uv_to_box(elem: AtlasElement, tex_w: int, tex_h: int) -> Tuple[int, int, int, int]:
    """Convert atlas UVs into a PIL crop box (left, top, right, bottom)."""

class KTexError(RuntimeError):
    ...

class KTexMipmap:
    ...

def _parse_ktex_variant(data: bytes, *, variant: str) -> Optional[Tuple[List[KTexMipmap], int]]:
    """Try parsing KTEX mipmap table."""

def parse_ktex(data: bytes) -> List[KTexMipmap]:
    """Parse a KTEX file and return mipmap descriptors."""

def _infer_tex_payload_format(width: int, height: int, data_size: int, pitch: int) -> str:
    """Infer payload format from (w,h,data_size,pitch)."""

def _rgb565_to_rgb888(c: int) -> Tuple[int, int, int]:
    ...

def _decompress_dxt1(payload: bytes, width: int, height: int) -> bytes:
    """Decompress DXT1 blocks into RGBA8888 bytes."""

def _decompress_dxt5(payload: bytes, width: int, height: int) -> bytes:
    """Decompress DXT5 blocks into RGBA8888 bytes."""

def decode_ktex_to_image(tex_bytes: bytes) -> Image.Image:
    """Decode KTEX to a PIL RGBA image using mipmap level 0."""

def unpremultiply_alpha_rgba(img: Image.Image) -> Image.Image:
    """Return a new image with straight (unpremultiplied) alpha."""

def extract_atlas_element(atlas: Atlas, tex_image: Image.Image, element_name: str, *, unpremultiply: bool=True) -> Optional[Image.Image]:
    """Crop a named element from an atlas texture image."""

def resolve_tex_path_from_atlas(xml_path: Path, atlas: Atlas) -> Optional[Path]:
    """Resolve the atlas <Texture filename="..."> into a filesystem path."""

def write_element_png(*, atlas_xml_path: Path, tex_path: Path, element_name: str, out_png_path: Path, unpremultiply: bool=True, overwrite: bool=False) -> bool:
    """Extract one element and write a PNG."""

def pick_first_existing(names: Iterable[str], available: Dict[str, AtlasElement]) -> Optional[str]:
    ...

def write_png(img, out_path):
    """Write a PIL Image to PNG, ensuring parent directories exist."""
```

### File: src/registry.py
- mode: interface
- size_bytes: 2414
- sha256_12: 49f94a18019d

```py
"""Wagstaff-Lab 工具注册中心 (v2.3)"""

# Constants
TOOLS = [{'file': 'guide.py', 'alias': None, 'desc': 'Wagstaff-Lab 控制台主面板', 'usage': ...

def get_tools():
    ...
```

### File: src/utils.py
- mode: full
- size_bytes: 1040
- sha256_12: ffc01cb3d8f3

```py
import configparser
import os
from pathlib import Path

class ConfigLoader:
    def __init__(self):
        # 自动定位项目根目录 (假设 utils.py 在 src/ 下)
        self.project_root = Path(__file__).resolve().parent.parent
        self.config_path = self.project_root / "conf" / "settings.ini"
        
        self.config = configparser.ConfigParser()
        if not self.config_path.exists():
            raise FileNotFoundError(f"❌ 配置文件丢失: {self.config_path}")
        
        self.config.read(self.config_path)

    def get(self, section, key):
        """获取配置值并自动展开用户路径 (~)"""
        val = self.config.get(section, key, fallback=None)
        if val and "~" in val:
            return os.path.expanduser(val)
        return val

# 单例模式：直接导出的实例
wagstaff_config = ConfigLoader()

# === 测试代码 ===
if __name__ == "__main__":
    print(f"Project Root: {wagstaff_config.project_root}")
    print(f"DST Path: {wagstaff_config.get('PATHS', 'DST_ROOT')}")
```

### File: src/webcraft/__init__.py
- mode: full
- size_bytes: 252
- sha256_12: f9cfb37ca166

```py
# -*- coding: utf-8 -*-
"""WebCraft (GUI/Web Crafting) service package.

- Backend: FastAPI (ASGI)
- Data: wagstaff_catalog_v1.json (M2 output)
- UI: lightweight single-page HTML (served by backend)
"""

__all__ = ["__version__"]
__version__ = "0.2.0"
```

### File: src/webcraft/api.py
- mode: full
- size_bytes: 8945
- sha256_12: 79ceaa2dbc56

```py
# -*- coding: utf-8 -*-
from __future__ import annotations

from typing import Any, Dict, List, Optional

from fastapi import APIRouter, Request, Depends, HTTPException, Query
from fastapi.responses import FileResponse
from pydantic import BaseModel, Field

from .catalog_store import CatalogStore, CraftRecipe, CookingRecipe
from .planner import craftable_recipes, missing_for, normalize_inventory
from .cooking_planner import find_cookable, simulate_cookpot, normalize_counts


def get_store(request: Request) -> CatalogStore:
    """Resolve the catalog store from app state (with optional auto-reload)."""

    store: CatalogStore = request.app.state.store  # type: ignore[attr-defined]
    auto = bool(getattr(request.app.state, "auto_reload_catalog", False))
    if auto:
        try:
            store.load(force=False)
        except Exception:
            # do not break requests on reload errors
            pass
    return store


router = APIRouter(prefix="/api/v1")


class PlanRequest(BaseModel):
    inventory: Dict[str, float] = Field(default_factory=dict)
    builder_tag: Optional[str] = None
    strict: bool = False
    limit: int = 200


class MissingRequest(BaseModel):
    name: str
    inventory: Dict[str, float] = Field(default_factory=dict)


class CookingFindRequest(BaseModel):
    inventory: Dict[str, float] = Field(default_factory=dict)
    limit: int = 200


class CookingSimulateRequest(BaseModel):
    slots: Dict[str, float] = Field(default_factory=dict)
    return_top: int = 25


@router.get("/meta")
def meta(request: Request, store: CatalogStore = Depends(get_store)):
    m = store.meta()
    m.update({"schema_version": store.schema_version()})

    # icon config (public)
    svc = getattr(request.app.state, "icon_service", None)
    if svc is not None:
        try:
            m.update({"icon": svc.cfg.to_public_dict()})
        except Exception:
            pass

    return m


@router.get("/assets")
def assets(request: Request, store: CatalogStore = Depends(get_store)):
    mp = store.assets()

    svc = getattr(request.app.state, "icon_service", None)
    icon_cfg = None
    if svc is not None:
        try:
            icon_cfg = svc.cfg.to_public_dict()
        except Exception:
            icon_cfg = None

    return {"assets": mp, "count": len(mp), "icon": icon_cfg or {"mode": "off", "static_base": "/static/icons", "api_base": "/api/v1/icon"}}


@router.get("/icon/{item_id}.png")
def icon_png(item_id: str, request: Request, store: CatalogStore = Depends(get_store)):
    """Return an item icon as PNG.

    This endpoint supports dynamic generation (atlas+xml + tex) when enabled.
    In all modes, it caches to the static icons directory as <id>.png.
    """

    svc = getattr(request.app.state, "icon_service", None)
    if svc is None:
        raise HTTPException(status_code=503, detail="Icon service not configured")

    asset = store.get_asset(item_id)
    p = svc.ensure_icon(item_id, asset)
    if not p:
        raise HTTPException(status_code=404, detail=f"Icon not found: {item_id}")

    return FileResponse(path=str(p), media_type="image/png")


# ----------------- craft browse -----------------


@router.get("/craft/filters")
def craft_filters(store: CatalogStore = Depends(get_store)):
    order, defs = store.list_filters()
    return {"order": order, "defs": defs}


@router.get("/craft/tabs")
def craft_tabs(store: CatalogStore = Depends(get_store)):
    return {"tabs": store.list_tabs()}


@router.get("/craft/tags")
def craft_tags(store: CatalogStore = Depends(get_store)):
    return {"tags": store.list_tags()}


@router.get("/craft/filters/{filter_name}/recipes")
def craft_filter_recipes(filter_name: str, store: CatalogStore = Depends(get_store)):
    names = store.list_by_filter(filter_name)
    return {"filter": filter_name, "recipes": names}


@router.get("/craft/tabs/{tab}/recipes")
def craft_tab_recipes(tab: str, store: CatalogStore = Depends(get_store)):
    names = store.list_by_tab(tab)
    return {"tab": tab, "recipes": names}


@router.get("/craft/tags/{tag}/recipes")
def craft_tag_recipes(tag: str, store: CatalogStore = Depends(get_store)):
    names = store.list_by_tag(tag)
    return {"tag": tag, "recipes": names}


@router.get("/craft/ingredients/{item}/recipes")
def craft_ingredient_recipes(item: str, store: CatalogStore = Depends(get_store)):
    names = store.list_by_ingredient(item)
    return {"ingredient": item, "recipes": names}


# ----------------- craft recipe -----------------


@router.get("/craft/recipes/search")
def craft_search(
    q: str = Query(..., min_length=1),
    limit: int = Query(50, ge=1, le=500),
    store: CatalogStore = Depends(get_store),
):
    return {"q": q, "results": store.search(q, limit=limit)}


@router.get("/craft/recipes/{name}")
def craft_recipe(name: str, store: CatalogStore = Depends(get_store)):
    rec = store.get_recipe(name)
    if not rec:
        raise HTTPException(status_code=404, detail=f"Recipe not found: {name}")
    return {"recipe": rec.raw}


# ----------------- craft planning -----------------


@router.post("/craft/plan")
def craft_plan(req: PlanRequest, store: CatalogStore = Depends(get_store)):
    inv = normalize_inventory(req.inventory)
    limit = int(req.limit or 200)
    limit = max(1, min(limit, 2000))

    recipes: List[CraftRecipe] = store.iter_recipes()
    recipes.sort(key=lambda x: x.name)

    ok, blocked = craftable_recipes(recipes, inv, builder_tag=req.builder_tag, strict=bool(req.strict))
    ok_names = [r.name for r in ok[:limit]]
    return {"craftable": ok_names, "blocked": blocked[:limit], "count": len(ok_names)}


@router.post("/craft/missing")
def craft_missing(req: MissingRequest, store: CatalogStore = Depends(get_store)):
    rec = store.get_recipe(req.name)
    if not rec:
        raise HTTPException(status_code=404, detail=f"Recipe not found: {req.name}")
    inv = normalize_inventory(req.inventory)
    miss = missing_for(rec, inv)
    return {"name": rec.name, "missing": [m.__dict__ for m in miss]}


# ----------------- cooking browse -----------------


@router.get("/cooking/recipes")
def cooking_all(store: CatalogStore = Depends(get_store)):
    recipes: List[CookingRecipe] = store.iter_cooking_recipes()
    names = sorted([r.name for r in recipes])
    return {"recipes": names, "count": len(names)}


@router.get("/cooking/foodtypes")
def cooking_foodtypes(store: CatalogStore = Depends(get_store)):
    return {"foodtypes": store.list_cooking_foodtypes()}


@router.get("/cooking/tags")
def cooking_tags(store: CatalogStore = Depends(get_store)):
    return {"tags": store.list_cooking_tags()}


@router.get("/cooking/foodtypes/{foodtype}/recipes")
def cooking_foodtype_recipes(foodtype: str, store: CatalogStore = Depends(get_store)):
    return {"foodtype": foodtype, "recipes": store.list_cooking_by_foodtype(foodtype)}


@router.get("/cooking/tags/{tag}/recipes")
def cooking_tag_recipes(tag: str, store: CatalogStore = Depends(get_store)):
    return {"tag": tag, "recipes": store.list_cooking_by_tag(tag)}


@router.get("/cooking/ingredients/{item}/recipes")
def cooking_ingredient_recipes(item: str, store: CatalogStore = Depends(get_store)):
    return {"ingredient": item, "recipes": store.list_cooking_by_ingredient(item)}


# ----------------- cooking recipe -----------------


@router.get("/cooking/recipes/search")
def cooking_search(
    q: str = Query(..., min_length=1),
    limit: int = Query(50, ge=1, le=500),
    store: CatalogStore = Depends(get_store),
):
    return {"q": q, "results": store.search_cooking(q, limit=limit)}


@router.get("/cooking/recipes/{name}")
def cooking_recipe(name: str, store: CatalogStore = Depends(get_store)):
    rec = store.get_cooking_recipe(name)
    if not rec:
        raise HTTPException(status_code=404, detail=f"Cooking recipe not found: {name}")
    return {"recipe": rec.raw}


# ----------------- cooking helpers -----------------


@router.post("/cooking/find")
def cooking_find(req: CookingFindRequest, store: CatalogStore = Depends(get_store)):
    inv = normalize_counts(req.inventory)
    limit = max(1, min(int(req.limit or 200), 2000))

    recipes = store.iter_cooking_recipes()
    cookable = find_cookable(recipes, inv, limit=limit)
    names = [r.name for r in cookable]

    return {
        "cookable": names,
        "count": len(names),
        "note": "catalog v1: only recipes with card_ingredients are searchable/simulatable",
    }


@router.post("/cooking/simulate")
def cooking_simulate(req: CookingSimulateRequest, store: CatalogStore = Depends(get_store)):
    recipes = store.iter_cooking_recipes()
    out = simulate_cookpot(recipes, req.slots, return_top=int(req.return_top or 25))

    # Attach result recipe details if available.
    if out.get("ok") and out.get("result"):
        rec = store.get_cooking_recipe(str(out.get("result")))
        if rec:
            out["recipe"] = rec.raw

    return out
```

### File: src/webcraft/app.py
- mode: full
- size_bytes: 3182
- sha256_12: 7fbd2457c16e

```py
# -*- coding: utf-8 -*-
from __future__ import annotations

from pathlib import Path
from typing import Optional, Sequence

from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.gzip import GZipMiddleware
from fastapi.responses import HTMLResponse
from fastapi.staticfiles import StaticFiles

from .api import router as api_router
from .catalog_store import CatalogStore
from .icon_service import IconConfig, IconService
from .settings import WebCraftSettings
from .ui import render_index_html, render_cooking_html


def create_app(
    catalog_path: Path,
    *,
    root_path: str = "",
    cors_allow_origins: Optional[Sequence[str]] = None,
    gzip_minimum_size: int = 800,
    auto_reload_catalog: bool = False,
    # icons
    icons_mode: str = "auto",
    game_data_dir: Optional[Path] = None,
    icons_unpremultiply: bool = True,
    static_root_dir: Optional[Path] = None,
) -> FastAPI:
    """FastAPI app factory."""

    rp = WebCraftSettings.normalize_root_path(root_path)

    app = FastAPI(
        title="Wagstaff WebCraft API",
        version="1.0",
        root_path=rp,
        docs_url="/docs",
        redoc_url=None,
    )

    # static (icons live here)
    project_root = Path(__file__).resolve().parents[2]
    static_root = Path(static_root_dir) if static_root_dir else (project_root / "data" / "static")
    try:
        static_root.mkdir(parents=True, exist_ok=True)
    except Exception:
        pass
    app.mount("/static", StaticFiles(directory=str(static_root), check_dir=False), name="static")

    # state
    app.state.store = CatalogStore(Path(catalog_path))
    app.state.auto_reload_catalog = bool(auto_reload_catalog)

    icons_dir = static_root / "icons"
    try:
        icons_dir.mkdir(parents=True, exist_ok=True)
    except Exception:
        pass

    cfg = IconConfig(
        mode=str(icons_mode or "auto"),
        static_dir=icons_dir,
        game_data_dir=(Path(game_data_dir).expanduser().resolve() if game_data_dir else None),
        unpremultiply=bool(icons_unpremultiply),
    )
    app.state.icon_service = IconService(cfg)

    # middleware
    if gzip_minimum_size and gzip_minimum_size > 0:
        app.add_middleware(GZipMiddleware, minimum_size=int(gzip_minimum_size))

    if cors_allow_origins:
        app.add_middleware(
            CORSMiddleware,
            allow_origins=list(cors_allow_origins),
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )

    # routes
    app.include_router(api_router)

    @app.get("/healthz")
    def healthz():
        return {"ok": True}

    @app.get("/", response_class=HTMLResponse)
    def index(request: Request):
        # root_path is already applied by FastAPI; still need it for frontend URL prefixing
        root = request.scope.get("root_path") or ""
        return HTMLResponse(render_index_html(app_root=str(root)))

    @app.get("/cooking", response_class=HTMLResponse)
    def cooking(request: Request):
        root = request.scope.get("root_path") or ""
        return HTMLResponse(render_cooking_html(app_root=str(root)))

    return app
```

### File: src/webcraft/catalog_store.py
- mode: full
- size_bytes: 18993
- sha256_12: 3ac3aa7e06ab

```py
# -*- coding: utf-8 -*-
from __future__ import annotations

import json
import threading
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, Iterable, List, Optional, Sequence, Tuple


def _dedup_preserve_order(items: Iterable[str]) -> List[str]:
    out: List[str] = []
    seen = set()
    for x in items:
        if not x:
            continue
        if x in seen:
            continue
        out.append(x)
        seen.add(x)
    return out


@dataclass
class CraftRecipe:
    name: str
    product: Optional[str]
    tab: str
    tech: str
    filters: List[str]
    builder_tags: List[str]
    builder_skill: Optional[str]
    station_tag: Optional[str]
    ingredients: List[Dict[str, Any]]
    ingredients_unresolved: List[str]
    raw: Dict[str, Any]


@dataclass
class CookingRecipe:
    """Cookpot cooking recipe (preparedfoods).

    Notes
    - Currently backed by catalog['cooking'] entries.
    - `card_ingredients` may be missing for many recipes (legacy limitation).
    """

    name: str
    priority: float
    weight: float
    foodtype: Optional[str]
    hunger: Any
    health: Any
    sanity: Any
    perishtime: Any
    cooktime: Any
    tags: List[str]
    card_ingredients: List[Tuple[str, float]]
    raw: Dict[str, Any]


class CatalogError(RuntimeError):
    pass


class CatalogStore:
    """Load + index wagstaff catalog for fast queries (thread-safe).

    Data source:
      - data/index/wagstaff_catalog_v1.json

    This layer is intentionally independent from wiki/cli layers. It should be safe
    to reuse from:
      - CLI (wiki)
      - Web (webcraft)
      - future GUI (desktop)
    """

    def __init__(self, catalog_path: Path):
        self._path = Path(catalog_path)
        self._lock = threading.RLock()
        self._mtime: float = -1.0

        self._doc: Dict[str, Any] = {}
        self._meta: Dict[str, Any] = {}

        # presentation mapping (id -> {name, atlas, image, ...})
        self._assets: Dict[str, Any] = {}

        # craft
        self._recipes: Dict[str, CraftRecipe] = {}
        self._aliases: Dict[str, str] = {}
        self._filter_defs: List[Dict[str, Any]] = []
        self._filter_order: List[str] = []

        # indexes (craft)
        self._by_filter: Dict[str, List[str]] = {}
        self._by_tab: Dict[str, List[str]] = {}
        self._by_tag: Dict[str, List[str]] = {}
        self._by_ingredient: Dict[str, List[str]] = {}

        # cooking
        self._cooking: Dict[str, CookingRecipe] = {}
        self._cook_by_tag: Dict[str, List[str]] = {}
        self._cook_by_foodtype: Dict[str, List[str]] = {}
        self._cook_by_ingredient: Dict[str, List[str]] = {}

        self.load(force=True)

    @property
    def path(self) -> Path:
        return self._path

    def meta(self) -> Dict[str, Any]:
        with self._lock:
            return dict(self._meta)

    def schema_version(self) -> int:
        with self._lock:
            return int(self._doc.get("schema_version") or 0)

    # ----------------- presentation assets -----------------

    def assets(self) -> Dict[str, Any]:
        """Return presentation assets mapping (shallow copy)."""
        with self._lock:
            return dict(self._assets or {})

    def get_asset(self, item_id: str) -> Optional[Dict[str, Any]]:
        if not item_id:
            return None
        with self._lock:
            v = (self._assets or {}).get(str(item_id))
            return dict(v) if isinstance(v, dict) else None

    # ----------------- load / reload -----------------

    def load(self, force: bool = False) -> bool:
        """Load catalog if changed.

        Returns True if reload occurred.
        """
        with self._lock:
            try:
                mtime = self._path.stat().st_mtime
            except FileNotFoundError as e:
                raise CatalogError(f"Catalog file not found: {self._path}") from e

            if (not force) and self._doc and self._mtime == mtime:
                return False

            doc = json.loads(self._path.read_text(encoding="utf-8"))
            self._validate(doc)

            self._doc = doc
            self._meta = doc.get("meta") or {}
            self._mtime = mtime

            self._build_indexes(doc)
            return True

    def _validate(self, doc: Dict[str, Any]) -> None:
        if not isinstance(doc, dict):
            raise CatalogError("Catalog root must be a JSON object")
        if "craft" not in doc:
            raise CatalogError("Catalog missing key: craft")
        if "meta" not in doc:
            raise CatalogError("Catalog missing key: meta")

        if "assets" in doc and not isinstance(doc.get("assets"), dict):
            raise CatalogError("Catalog assets must be an object")

        craft = doc.get("craft") or {}
        if "recipes" not in craft or not isinstance(craft.get("recipes"), dict):
            raise CatalogError("Catalog craft.recipes must be an object")

        # cooking is optional in v1, but if present it must be an object.
        if "cooking" in doc and not isinstance(doc.get("cooking"), dict):
            raise CatalogError("Catalog cooking must be an object")

    def _build_indexes(self, doc: Dict[str, Any]) -> None:
        self._assets = doc.get("assets") or {}

        # ---- craft ----
        craft = doc.get("craft") or {}
        recipes_obj: Dict[str, Any] = craft.get("recipes") or {}
        aliases: Dict[str, str] = craft.get("aliases") or {}
        filter_defs: List[Dict[str, Any]] = craft.get("filter_defs") or []
        filter_order: List[str] = craft.get("filter_order") or []

        recipes: Dict[str, CraftRecipe] = {}
        for name, raw in recipes_obj.items():
            if not isinstance(raw, dict):
                continue

            btags = raw.get("builder_tags") or []
            if isinstance(btags, str):
                btags = [btags]
            btags = [str(x) for x in btags if x]

            rec = CraftRecipe(
                name=str(raw.get("name") or name),
                product=(raw.get("product") or None),
                tab=str(raw.get("tab") or "UNKNOWN"),
                tech=str(raw.get("tech") or "UNKNOWN"),
                filters=[str(x) for x in (raw.get("filters") or []) if x],
                builder_tags=btags,
                builder_skill=(raw.get("builder_skill") or None),
                station_tag=(raw.get("station_tag") or None),
                ingredients=list(raw.get("ingredients") or []),
                ingredients_unresolved=list(raw.get("ingredients_unresolved") or []),
                raw=raw,
            )
            recipes[rec.name] = rec

        # indexes
        by_filter: Dict[str, List[str]] = {}
        by_tab: Dict[str, List[str]] = {}
        by_tag: Dict[str, List[str]] = {}
        by_ing: Dict[str, List[str]] = {}

        for rec in recipes.values():
            for f in rec.filters:
                by_filter.setdefault(f, []).append(rec.name)

            if rec.tab:
                by_tab.setdefault(rec.tab, []).append(rec.name)

            for t in rec.builder_tags:
                by_tag.setdefault(t, []).append(rec.name)

            for ing in rec.ingredients:
                item = str(ing.get("item") or "").strip()
                if not item:
                    continue
                by_ing.setdefault(item, []).append(rec.name)

        for bucket in (by_filter, by_tab, by_tag, by_ing):
            for k in list(bucket.keys()):
                bucket[k] = sorted(_dedup_preserve_order(bucket[k]))

        self._recipes = recipes
        self._aliases = {str(k): str(v) for k, v in aliases.items() if k and v}
        self._filter_defs = list(filter_defs)
        self._filter_order = list(filter_order)

        self._by_filter = by_filter
        self._by_tab = by_tab
        self._by_tag = by_tag
        self._by_ingredient = by_ing

        # ---- cooking ----
        self._build_cooking_indexes(doc.get("cooking") or {})

    def _build_cooking_indexes(self, cooking_obj: Dict[str, Any]) -> None:
        recipes: Dict[str, CookingRecipe] = {}
        by_tag: Dict[str, List[str]] = {}
        by_ft: Dict[str, List[str]] = {}
        by_ing: Dict[str, List[str]] = {}

        if not isinstance(cooking_obj, dict):
            cooking_obj = {}

        for name, raw in cooking_obj.items():
            if not isinstance(raw, dict):
                continue

            tags = raw.get("tags") or []
            if isinstance(tags, str):
                tags = [tags]
            tags = [str(x) for x in tags if x]

            ci_raw = raw.get("card_ingredients") or []
            card_ings: List[Tuple[str, float]] = []
            if isinstance(ci_raw, list):
                for row in ci_raw:
                    if not isinstance(row, (list, tuple)) or len(row) < 2:
                        continue
                    item = str(row[0]).strip()
                    if not item:
                        continue
                    try:
                        cnt = float(row[1])
                    except Exception:
                        continue
                    if cnt <= 0:
                        continue
                    card_ings.append((item, cnt))

            try:
                priority = float(raw.get("priority", 0))
            except Exception:
                priority = 0.0
            try:
                weight = float(raw.get("weight", 1))
            except Exception:
                weight = 1.0

            ft = raw.get("foodtype")
            foodtype = str(ft).strip() if ft else None

            rec = CookingRecipe(
                name=str(name),
                priority=priority,
                weight=weight,
                foodtype=foodtype,
                hunger=raw.get("hunger"),
                health=raw.get("health"),
                sanity=raw.get("sanity"),
                perishtime=raw.get("perishtime"),
                cooktime=raw.get("cooktime"),
                tags=tags,
                card_ingredients=card_ings,
                raw=raw,
            )
            recipes[rec.name] = rec

            if rec.foodtype:
                by_ft.setdefault(rec.foodtype, []).append(rec.name)

            for t in rec.tags:
                by_tag.setdefault(t, []).append(rec.name)

            for item, _ in rec.card_ingredients:
                by_ing.setdefault(item, []).append(rec.name)

        for bucket in (by_tag, by_ft, by_ing):
            for k in list(bucket.keys()):
                bucket[k] = sorted(_dedup_preserve_order(bucket[k]))

        self._cooking = recipes
        self._cook_by_tag = by_tag
        self._cook_by_foodtype = by_ft
        self._cook_by_ingredient = by_ing

    # ----------------- craft queries -----------------

    def resolve_recipe_name(self, q: str) -> Optional[str]:
        """Resolve query -> canonical recipe name via aliases & exact match (case-insensitive)."""
        if not q:
            return None
        q0 = str(q).strip()
        if not q0:
            return None

        with self._lock:
            if q0 in self._recipes:
                return q0

            if q0 in self._aliases:
                return self._aliases[q0]

            ql = q0.lower()
            for nm in self._recipes.keys():
                if nm.lower() == ql:
                    return nm
            for a, nm in self._aliases.items():
                if a.lower() == ql:
                    return nm

        return None

    def get_recipe(self, q: str) -> Optional[CraftRecipe]:
        name = self.resolve_recipe_name(q)
        if not name:
            return None
        with self._lock:
            return self._recipes.get(name)

    def iter_recipes(self) -> List[CraftRecipe]:
        """Return a snapshot list of all recipes."""
        with self._lock:
            return list(self._recipes.values())

    def list_filters(self) -> Tuple[List[str], List[Dict[str, Any]]]:
        with self._lock:
            return list(self._filter_order), list(self._filter_defs)

    def list_tabs(self) -> List[Dict[str, Any]]:
        """Return ordered tabs with counts.

        Order heuristic:
          - follow filter_order for any matching tab name
          - then append remaining tabs alphabetically
        """
        with self._lock:
            tab_names = set(self._by_tab.keys())
            ordered: List[str] = []
            for f in self._filter_order:
                if f in tab_names and f not in ordered:
                    ordered.append(f)
            ordered += sorted([t for t in tab_names if t not in ordered])
            return [{"name": t, "count": len(self._by_tab.get(t, []))} for t in ordered]

    def list_tags(self) -> List[Dict[str, Any]]:
        with self._lock:
            tags = [{"name": t, "count": len(v)} for t, v in self._by_tag.items()]
        tags.sort(key=lambda x: (-x["count"], x["name"]))
        return tags

    def list_by_filter(self, filter_name: str) -> List[str]:
        with self._lock:
            return list(self._by_filter.get(filter_name, []))

    def list_by_tab(self, tab: str) -> List[str]:
        with self._lock:
            return list(self._by_tab.get(tab, []))

    def list_by_tag(self, tag: str) -> List[str]:
        with self._lock:
            return list(self._by_tag.get(tag, []))

    def list_by_ingredient(self, item: str) -> List[str]:
        with self._lock:
            return list(self._by_ingredient.get(item, []))

    def search(self, q: str, limit: int = 50) -> List[Dict[str, Any]]:
        """Search craft recipes.

        Supported prefixes:
          - ing:<item>
          - tag:<builder_tag>
          - filter:<FILTER>
          - tab:<TAB>

        Otherwise:
          - substring match on recipe name or product
        """
        q = (q or "").strip()
        if not q:
            return []

        limit = max(1, min(int(limit or 50), 500))
        ql = q.lower()

        with self._lock:
            for prefix in ("ing:", "tag:", "filter:", "tab:"):
                if ql.startswith(prefix):
                    val = q[len(prefix) :].strip()
                    if not val:
                        return []
                    if prefix == "ing:":
                        names = self._by_ingredient.get(val, [])
                    elif prefix == "tag:":
                        names = self._by_tag.get(val, [])
                    elif prefix == "filter:":
                        names = self._by_filter.get(val, [])
                    else:
                        names = self._by_tab.get(val, [])
                    return [self._recipe_brief(nm) for nm in names[:limit]]

            nm = self.resolve_recipe_name(q)
            if nm:
                return [self._recipe_brief(nm)]

            hits: List[str] = []
            for nm2, rec in self._recipes.items():
                if ql in nm2.lower() or (rec.product and ql in str(rec.product).lower()):
                    hits.append(nm2)
                    if len(hits) >= limit:
                        break

            return [self._recipe_brief(nm2) for nm2 in hits]

    def _recipe_brief(self, name: str) -> Dict[str, Any]:
        rec = self._recipes.get(name)
        if not rec:
            return {"name": name}
        return {
            "name": rec.name,
            "product": rec.product,
            "tab": rec.tab,
            "tech": rec.tech,
            "filters": rec.filters,
            "builder_tags": rec.builder_tags,
            "builder_skill": rec.builder_skill,
            "station_tag": rec.station_tag,
        }

    # ----------------- cooking queries -----------------

    def resolve_cooking_name(self, q: str) -> Optional[str]:
        if not q:
            return None
        q0 = str(q).strip()
        if not q0:
            return None

        with self._lock:
            if q0 in self._cooking:
                return q0

            ql = q0.lower()
            for nm in self._cooking.keys():
                if nm.lower() == ql:
                    return nm

        return None

    def get_cooking_recipe(self, q: str) -> Optional[CookingRecipe]:
        nm = self.resolve_cooking_name(q)
        if not nm:
            return None
        with self._lock:
            return self._cooking.get(nm)

    def iter_cooking_recipes(self) -> List[CookingRecipe]:
        with self._lock:
            return list(self._cooking.values())

    def list_cooking_foodtypes(self) -> List[Dict[str, Any]]:
        with self._lock:
            items = [{"name": ft, "count": len(v)} for ft, v in self._cook_by_foodtype.items()]
        items.sort(key=lambda x: (-x["count"], x["name"]))
        return items

    def list_cooking_tags(self) -> List[Dict[str, Any]]:
        with self._lock:
            items = [{"name": t, "count": len(v)} for t, v in self._cook_by_tag.items()]
        items.sort(key=lambda x: (-x["count"], x["name"]))
        return items

    def list_cooking_by_foodtype(self, foodtype: str) -> List[str]:
        with self._lock:
            return list(self._cook_by_foodtype.get(foodtype, []))

    def list_cooking_by_tag(self, tag: str) -> List[str]:
        with self._lock:
            return list(self._cook_by_tag.get(tag, []))

    def list_cooking_by_ingredient(self, item: str) -> List[str]:
        with self._lock:
            return list(self._cook_by_ingredient.get(item, []))

    def search_cooking(self, q: str, limit: int = 50) -> List[Dict[str, Any]]:
        """Search cooking recipes.

        Supported prefixes:
          - ing:<item>      (uses card_ingredients index; may be incomplete)
          - tag:<tag>      (food tags)
          - type:<FOODTYPE.*> or foodtype:<FOODTYPE.*>

        Otherwise: substring match on recipe name.
        """
        q = (q or "").strip()
        if not q:
            return []

        limit = max(1, min(int(limit or 50), 500))
        ql = q.lower()

        with self._lock:
            for prefix in ("ing:", "tag:", "type:", "foodtype:"):
                if ql.startswith(prefix):
                    val = q[len(prefix) :].strip()
                    if not val:
                        return []
                    if prefix == "ing:":
                        names = self._cook_by_ingredient.get(val, [])
                    elif prefix == "tag:":
                        names = self._cook_by_tag.get(val, [])
                    else:
                        names = self._cook_by_foodtype.get(val, [])
                    return [{"name": nm} for nm in names[:limit]]

            nm = self.resolve_cooking_name(q)
            if nm:
                return [{"name": nm}]

            hits: List[str] = []
            for nm2 in self._cooking.keys():
                if ql in nm2.lower():
                    hits.append(nm2)
                    if len(hits) >= limit:
                        break

            return [{"name": nm2} for nm2 in hits]
```

### File: src/webcraft/cooking_planner.py
- mode: full
- size_bytes: 4276
- sha256_12: bd00afb78bbe

```py
# -*- coding: utf-8 -*-
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Tuple

from .catalog_store import CookingRecipe


def normalize_counts(inv: Dict[str, Any]) -> Dict[str, float]:
    """Normalize item->count mapping.

    - Keys are stripped strings.
    - Values must be numeric and > 0.

    This helper is shared by:
      - cookable query (inventory)
      - simulator (cookpot slots)
    """

    out: Dict[str, float] = {}
    for k, v in (inv or {}).items():
        key = str(k).strip()
        if not key:
            continue
        try:
            num = float(v)
        except Exception:
            continue
        if num <= 0:
            continue
        out[key] = num
    return out


def _requirements_satisfied(req: List[Tuple[str, float]], available: Dict[str, float]) -> bool:
    """Check if `available` contains all `req` items with required counts."""
    for item, need in (req or []):
        if not item:
            continue
        have = float(available.get(item, 0.0))
        if have + 1e-9 < float(need):
            return False
    return True


def find_cookable(
    recipes: List[CookingRecipe],
    inventory: Dict[str, Any],
    *,
    limit: int = 200,
) -> List[CookingRecipe]:
    """Find cookable recipes based on catalog `card_ingredients`.

    Current limitation
    - Only recipes with `card_ingredients` can be evaluated.
    """

    inv = normalize_counts(inventory)
    limit = max(1, min(int(limit or 200), 2000))

    out: List[CookingRecipe] = []
    for r in recipes:
        if not r.card_ingredients:
            continue
        if _requirements_satisfied(r.card_ingredients, inv):
            out.append(r)

    # Stable order: higher priority first, then name.
    out.sort(key=lambda x: (-float(x.priority), x.name))
    return out[:limit]


@dataclass(frozen=True)
class SimCandidate:
    name: str
    priority: float
    weight: float


def simulate_cookpot(
    recipes: List[CookingRecipe],
    slots: Dict[str, Any],
    *,
    return_top: int = 25,
) -> Dict[str, Any]:
    """Simulate cookpot output using catalog `card_ingredients`.

    Input
    - slots: mapping of item -> count placed into the pot.

    Behavior
    - Requires total slot count == 4 (cookpot rule).
    - Only evaluates recipes that have `card_ingredients`.
    - If multiple match, choose the highest priority; tie-break by weight then name.
    - If none match, fall back to 'wetgoop' if present in recipe list.

    Returns a dict suitable for JSON response.
    """

    counts = normalize_counts(slots)
    total = sum(int(round(v)) for v in counts.values())
    if total != 4:
        return {
            "ok": False,
            "error": "cookpot_requires_4_items",
            "total": total,
            "slots": {k: int(round(v)) for k, v in counts.items()},
        }

    # int-normalize (cookpot is discrete)
    slots_i: Dict[str, int] = {}
    for k, v in counts.items():
        n = int(round(v))
        if n <= 0:
            continue
        slots_i[k] = slots_i.get(k, 0) + n

    candidates: List[CookingRecipe] = []
    for r in recipes:
        if not r.card_ingredients:
            continue
        if _requirements_satisfied(r.card_ingredients, {k: float(v) for k, v in slots_i.items()}):
            candidates.append(r)

    if candidates:
        candidates.sort(key=lambda x: (-float(x.priority), -float(x.weight), x.name))
        best = candidates[0]
        top = [SimCandidate(name=r.name, priority=float(r.priority), weight=float(r.weight)) for r in candidates[:return_top]]
        return {
            "ok": True,
            "result": best.name,
            "reason": "matched_card_ingredients",
            "candidates": [c.__dict__ for c in top],
            "slots": slots_i,
        }

    # fallback
    wet = next((r for r in recipes if r.name == "wetgoop"), None)
    if wet is not None:
        return {
            "ok": True,
            "result": "wetgoop",
            "reason": "fallback_wetgoop",
            "candidates": [],
            "slots": slots_i,
        }

    return {
        "ok": False,
        "error": "no_match_and_no_wetgoop",
        "candidates": [],
        "slots": slots_i,
    }
```

### File: src/webcraft/icon_service.py
- mode: full
- size_bytes: 8219
- sha256_12: b4af2b1b0d25

```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import json
import os
import sys
import zipfile
from pathlib import Path
from typing import Dict, Iterable, Optional, Set, Tuple

# IMPORTANT: depends on your existing decoder module
# from src/klei_atlas_tex.py in previous patch
# - parse_atlas_xml(xml_text) -> atlas dict
# - decode_ktex_to_image(tex_bytes) -> ImageRGBA {width,height,pixels}
# - extract_atlas_element(atlas, image, element_name, unpremultiply=True) -> ImageRGBA
# - write_png(path, width, height, rgba_bytes)
try:
    from klei_atlas_tex import (
        parse_atlas_xml,
        decode_ktex_to_image,
        extract_atlas_element,
        write_png,
    )
except Exception as e:
    print("ERROR: cannot import klei_atlas_tex. Ensure src/ is on PYTHONPATH and patch applied.")
    raise


def _load_json(p: Path) -> dict:
    with p.open("r", encoding="utf-8") as f:
        return json.load(f)


def _ensure_dir(p: Path) -> None:
    p.mkdir(parents=True, exist_ok=True)


def _dedup(seq: Iterable[str]) -> list:
    seen = set()
    out = []
    for x in seq:
        if x in seen:
            continue
        seen.add(x)
        out.append(x)
    return out


class GameDataReader:
    """
    Read files from:
    1) <game-data>/databundles/images.zip (preferred)
    2) <game-data>/<relative_path> (fallback)
    """
    def __init__(self, game_data: Path, images_zip: Optional[Path] = None):
        self.game_data = game_data
        self.images_zip = images_zip if images_zip else (game_data / "databundles" / "images.zip")
        self._zip: Optional[zipfile.ZipFile] = None

        if self.images_zip.exists():
            try:
                self._zip = zipfile.ZipFile(self.images_zip, "r")
            except Exception:
                self._zip = None

    def close(self) -> None:
        if self._zip:
            try:
                self._zip.close()
            except Exception:
                pass

    def read_bytes(self, rel_path: str) -> Optional[bytes]:
        rel_path = rel_path.lstrip("/").replace("\\", "/")
        # try zip first
        if self._zip:
            try:
                with self._zip.open(rel_path, "r") as f:
                    return f.read()
            except KeyError:
                pass
            except Exception:
                pass

        # fallback to filesystem
        fs_path = self.game_data / rel_path
        if fs_path.exists():
            try:
                return fs_path.read_bytes()
            except Exception:
                return None
        return None


def _collect_ids_from_catalog(doc: dict) -> Set[str]:
    """
    Collect ids from craft+cooking:
    - craft.recipes: name/product/ingredients[].item
    - cooking: recipe name and card_ingredients[][0]
    """
    ids: Set[str] = set()

    craft = doc.get("craft") or {}
    recipes = craft.get("recipes") or {}
    for name, r in recipes.items():
        if isinstance(name, str):
            ids.add(name.lower())
        if isinstance(r, dict):
            prod = r.get("product")
            if isinstance(prod, str):
                ids.add(prod.lower())
            for ing in (r.get("ingredients") or []):
                if isinstance(ing, dict):
                    it = ing.get("item")
                    if isinstance(it, str):
                        ids.add(it.lower())

    cooking = doc.get("cooking") or {}
    if isinstance(cooking, dict):
        for food, r in cooking.items():
            if isinstance(food, str):
                ids.add(food.lower())
            if isinstance(r, dict):
                for pair in (r.get("card_ingredients") or []):
                    if isinstance(pair, list) and pair and isinstance(pair[0], str):
                        ids.add(pair[0].lower())

    # small normalize: sometimes ids differ by underscore
    # keep both forms for lookup
    extra = set()
    for x in list(ids):
        if "_" in x:
            extra.add(x.replace("_", ""))
    ids |= extra

    return ids


def _atlas_candidates() -> Iterable[str]:
    # Common DST inventories atlases. inventoryimages.xml is confirmed in images.zip.
    bases = [
        "images/inventoryimages",
        "images/inventoryimages2",
        "images/inventoryimages3",
        "images/inventoryimages4",
    ]
    for b in bases:
        yield b


def _try_extract_one(
    reader: GameDataReader,
    atlas_base: str,
    item_id: str,
    out_png: Path,
    *,
    unpremultiply: bool = True,
) -> bool:
    """
    Try extract <item_id> from a given atlas_base (without extension).
    Element name in atlas is usually "<id>.tex" (sometimes just "<id>").
    """
    xml_path = f"{atlas_base}.xml"
    tex_path = f"{atlas_base}.tex"

    xml_bytes = reader.read_bytes(xml_path)
    if not xml_bytes:
        return False

    tex_bytes = reader.read_bytes(tex_path)
    if not tex_bytes:
        return False

    try:
        atlas = parse_atlas_xml(xml_bytes.decode("utf-8", errors="replace"))
        img = decode_ktex_to_image(tex_bytes)
    except Exception:
        return False

    # try common element naming
    candidates = _dedup([
        f"{item_id}.tex",
        item_id,
        f"{item_id.replace('_','')}.tex",
        item_id.replace("_", ""),
    ])

    for elem_name in candidates:
        try:
            sub = extract_atlas_element(atlas, img, elem_name, unpremultiply=unpremultiply)
            if sub and sub.pixels and sub.width > 0 and sub.height > 0:
                _ensure_dir(out_png.parent)
                write_png(str(out_png), sub.width, sub.height, sub.pixels)
                return True
        except KeyError:
            continue
        except Exception:
            continue

    return False


def build_icons(catalog_path: Path, game_data: Path, out_dir: Path, images_zip: Optional[Path]) -> int:
    doc = _load_json(catalog_path)
    ids = sorted(_collect_ids_from_catalog(doc))

    reader = GameDataReader(game_data, images_zip=images_zip)

    ok = 0
    missing = 0

    # iterate ids and try multiple atlases
    for item_id in ids:
        out_png = out_dir / f"{item_id}.png"

        done = False
        for atlas_base in _atlas_candidates():
            if _try_extract_one(reader, atlas_base, item_id, out_png, unpremultiply=True):
                done = True
                break

        if done:
            ok += 1
        else:
            missing += 1

    reader.close()

    _ensure_dir(out_dir)
    index_out = catalog_path.parent / "wagstaff_icon_index_v1.json"
    index_doc = {
        "schema_version": 1,
        "ok": ok,
        "missing": missing,
        "out_dir": str(out_dir.resolve()),
        "mode": "klei_atlas_tex",
        "source": {
            "game_data": str(game_data.resolve()),
            "images_zip": str((images_zip if images_zip else (game_data / "databundles" / "images.zip")).resolve()),
        },
    }
    with index_out.open("w", encoding="utf-8") as f:
        json.dump(index_doc, f, ensure_ascii=False, indent=2)

    print(f"✅ icons ok: {ok}")
    print(f"⚠️ missing/unbuilt: {missing}")
    print(f"Out: {out_dir.resolve()}")
    print(f"Index: {index_out.resolve()}")
    return 0


def main(argv: Optional[list] = None) -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--catalog", required=True, help="Path to wagstaff_catalog_v1.json")
    ap.add_argument("--game-data", required=True, help="DST data directory (contains databundles/)")
    ap.add_argument("--out", required=True, help="Output directory for PNG icons")
    ap.add_argument("--images-zip", default=None, help="Override databundles/images.zip path (optional)")
    args = ap.parse_args(argv)

    catalog_path = Path(args.catalog)
    game_data = Path(args.game_data)
    out_dir = Path(args.out)
    images_zip = Path(args.images_zip) if args.images_zip else None

    if not catalog_path.exists():
        print(f"ERROR: catalog not found: {catalog_path}")
        return 2

    if not game_data.exists():
        print(f"ERROR: game-data not found: {game_data}")
        return 2

    return build_icons(catalog_path, game_data, out_dir, images_zip)


if __name__ == "__main__":
    raise SystemExit(main())
```

### File: src/webcraft/planner.py
- mode: full
- size_bytes: 3808
- sha256_12: a9ac339eaf54

```py
# -*- coding: utf-8 -*-
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Tuple

from .catalog_store import CraftRecipe


def normalize_inventory(inv: Dict[str, Any]) -> Dict[str, float]:
    out: Dict[str, float] = {}
    for k, v in (inv or {}).items():
        key = str(k).strip()
        if not key:
            continue
        try:
            num = float(v)
        except Exception:
            continue
        if num <= 0:
            continue
        out[key] = num
    return out


def _recipe_requires_builder_tag(recipe: CraftRecipe) -> Optional[str]:
    # builder_tags preferred
    if recipe.builder_tags:
        # a recipe can accept multiple tags; treat as "any-of"
        return ",".join(recipe.builder_tags)
    return None


def is_builder_allowed(recipe: CraftRecipe, builder_tag: Optional[str], strict: bool = False) -> Tuple[bool, str]:
    """Check if builder can craft this recipe.

    strict:
      - if True: treat builder_skill as locked (unknown to us), require builder_tag for builder_tags
      - if False: only enforce builder_tags; ignore builder_skill
    """
    bt_required = recipe.builder_tags or []
    if bt_required:
        if not builder_tag:
            return False, "missing_builder_tag"
        if builder_tag not in bt_required:
            return False, "builder_tag_mismatch"

    if strict and recipe.builder_skill:
        # we don't model skill tree yet; mark as blocked
        return False, "builder_skill_locked"

    return True, ""


@dataclass
class MissingItem:
    item: str
    need: float
    have: float
    reason: str = ""


def missing_for(recipe: CraftRecipe, inventory: Dict[str, float]) -> List[MissingItem]:
    """Compute missing materials for a recipe based on numeric amounts.

    If amount_num is missing/unresolvable => treated as missing with reason 'unresolved_amount'.
    """
    inv = inventory or {}
    missing: List[MissingItem] = []

    # unresolved list from catalog (e.g. CHARACTER_INGREDIENT.HEALTH)
    for unresolved in (recipe.ingredients_unresolved or []):
        missing.append(MissingItem(item=str(unresolved), need=1.0, have=0.0, reason="unresolved_ingredient"))

    for ing in (recipe.ingredients or []):
        item = str(ing.get("item") or "").strip()
        if not item:
            continue
        amt_num = ing.get("amount_num", None)
        if amt_num is None:
            # fallback: try parse amount string
            try:
                amt_num = float(ing.get("amount"))
            except Exception:
                amt_num = None
        if amt_num is None:
            missing.append(MissingItem(item=item, need=1.0, have=float(inv.get(item, 0.0)), reason="unresolved_amount"))
            continue

        have = float(inv.get(item, 0.0))
        need = float(amt_num)
        if have + 1e-9 < need:
            missing.append(MissingItem(item=item, need=need, have=have, reason="insufficient"))

    return missing


def craftable_recipes(
    recipes: List[CraftRecipe],
    inventory: Dict[str, float],
    builder_tag: Optional[str] = None,
    strict: bool = False,
) -> Tuple[List[CraftRecipe], List[Dict[str, Any]]]:
    """Return craftable recipes + blocked details."""
    inv = inventory or {}
    ok: List[CraftRecipe] = []
    blocked: List[Dict[str, Any]] = []

    for r in recipes:
        allowed, reason = is_builder_allowed(r, builder_tag, strict=strict)
        if not allowed:
            blocked.append({"name": r.name, "reason": reason})
            continue

        miss = missing_for(r, inv)
        if miss:
            blocked.append({"name": r.name, "reason": "missing_material", "missing": [m.__dict__ for m in miss]})
            continue

        ok.append(r)

    return ok, blocked
```

### File: src/webcraft/settings.py
- mode: full
- size_bytes: 790
- sha256_12: b2f5722e0c36

```py
# -*- coding: utf-8 -*-
from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import List, Optional


@dataclass(frozen=True)
class WebCraftSettings:
    """Runtime settings for WebCraft server.

    Notes
    - catalog_path should point to data/index/wagstaff_catalog_v1.json
    - root_path is for reverse-proxy mount (e.g. '/webcraft')
    """

    catalog_path: Path
    root_path: str = ""
    cors_allow_origins: Optional[List[str]] = None
    gzip_minimum_size: int = 800

    @staticmethod
    def normalize_root_path(root_path: str) -> str:
        rp = (root_path or "").strip()
        if not rp:
            return ""
        if not rp.startswith("/"):
            rp = "/" + rp
        rp = rp.rstrip("/")
        return rp
```

### File: src/webcraft/ui.py
- mode: full
- size_bytes: 42263
- sha256_12: 60813cc8836b

```py
# -*- coding: utf-8 -*-
from __future__ import annotations

from html import escape

# NOTE:
# - Keep HTML/JS as a normal triple-quoted string.
# - Do NOT use Python f-strings here: the template contains many `{}` (CSS/JS/template literals).

_INDEX_TEMPLATE = r"""<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="app-root" content="__WAGSTAFF_APP_ROOT__" />
  <title>Wagstaff WebCraft</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #0f1722;
      --panel2: #111b29;
      --text: #e6edf3;
      --muted: #9fb0c0;
      --border: #233042;
      --accent: #79c0ff;
      --accent2: #a5d6ff;
      --bad: #ff7b72;
      --ok: #7ee787;
    }
    html, body {
      margin: 0; padding: 0;
      background: var(--bg);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }

    .navlink {
      font-size: 12px;
      color: var(--muted);
      padding: 4px 10px;
      border: 1px solid var(--border);
      border-radius: 999px;
      background: rgba(17,27,41,0.6);
    }
    .navlink:hover {
      text-decoration: none;
      border-color: #3b4b63;
      color: var(--text);
    }

    .topbar {
      position: sticky;
      top: 0;
      z-index: 10;
      display: flex;
      gap: 12px;
      align-items: center;
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      background: rgba(11, 15, 20, 0.92);
      backdrop-filter: blur(8px);
    }
    .topbar h1 {
      font-size: 14px;
      margin: 0;
      font-weight: 650;
      letter-spacing: .3px;
      color: var(--accent2);
    }
    .search {
      flex: 1;
      display: flex;
      gap: 8px;
      align-items: center;
    }
    input[type="text"], textarea {
      width: 100%;
      background: var(--panel);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 10px;
      outline: none;
    }
    textarea {
      min-height: 60px;
      resize: vertical;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    button {
      background: var(--panel2);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 8px;
      padding: 8px 10px;
      cursor: pointer;
    }
    button:hover { border-color: #3b4b63; }
    button.primary {
      background: rgba(121, 192, 255, 0.12);
      border-color: rgba(121, 192, 255, 0.25);
    }
    button.primary:hover {
      border-color: rgba(121, 192, 255, 0.45);
    }
    .layout {
      display: grid;
      grid-template-columns: 260px 1fr 420px;
      gap: 10px;
      padding: 10px;
    }
    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      overflow: hidden;
      min-height: calc(100vh - 62px);
    }
    .panel h2 {
      margin: 0;
      padding: 10px 12px;
      font-size: 13px;
      border-bottom: 1px solid var(--border);
      color: var(--muted);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .list {
      max-height: calc(100vh - 62px - 44px);
      overflow: auto;
    }
    .item {
      padding: 8px 12px;
      border-bottom: 1px solid rgba(35, 48, 66, 0.65);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      gap: 10px;
    }
    .item:hover { background: rgba(255,255,255,0.03); }
    .item.active { background: rgba(121,192,255,0.08); }
    .item .name { font-weight: 560; }
    .item .meta { color: var(--muted); font-size: 12px; }
    .detail {
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .kv {
      display: grid;
      grid-template-columns: 120px 1fr;
      gap: 6px 10px;
      font-size: 13px;
    }
    .kv .k { color: var(--muted); }
    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .chip {
      font-size: 12px;
      color: var(--muted);
      padding: 3px 8px;
      border: 1px solid rgba(35,48,66,0.9);
      border-radius: 999px;
      background: rgba(17,27,41,0.8);
    }
    .grid2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    .err {
      color: var(--bad);
      font-size: 12px;
      white-space: pre-wrap;
    }
    .ok {
      color: var(--ok);
      font-size: 12px;
    }
    .muted { color: var(--muted); }
    .small { font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .itemRef {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .itemIcon {
      width: 18px;
      height: 18px;
      border-radius: 4px;
      border: 1px solid rgba(35,48,66,0.9);
      background: rgba(17,27,41,0.8);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      flex: 0 0 auto;
    }
    .itemIconImg {
      width: 100%;
      height: 100%;
      object-fit: contain;
      image-rendering: pixelated;
      display: block;
    }
    .itemIconFallback {
      width: 100%;
      height: 100%;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      color: var(--muted);
    }
    .itemLabel {
      color: var(--text);
    }
  </style>
</head>
<body>
  <div class="topbar">
    <h1>Wagstaff WebCraft</h1>
    <a id="navCooking" class="navlink" href="#">Cooking</a>
    <div class="search">
      <input id="q" type="text" placeholder="Search: axe | ing:twigs | tag:bookbuilder | filter:TOOLS | tab:LIGHT" />
      <button id="btnSearch" class="primary">Search</button>
    </div>
    <div class="small muted" id="meta"></div>
  </div>

  <div class="layout">
    <div class="panel">
      <h2>
        <span id="groupTitle">Filters</span>
        <button id="btnToggle">Toggle</button>
      </h2>
      <div class="list" id="groupList"></div>
    </div>

    <div class="panel">
      <h2>
        <span id="listTitle">Recipes</span>
        <span class="small muted" id="listCount"></span>
      </h2>
      <div class="list" id="recipeList"></div>
    </div>

    <div class="panel">
      <h2>Details</h2>
      <div class="detail">
        <div id="detail"></div>

        <div>
          <div class="small muted">Inventory (for missing/planning)</div>
          <textarea id="inv" placeholder="twigs=2, flint=1
rocks=10"></textarea>
          <div class="grid2" style="margin-top:8px;">
            <div>
              <div class="small muted">builder_tag (optional)</div>
              <input id="builderTag" type="text" placeholder="bookbuilder / handyperson / ..." />
            </div>
            <div style="display:flex; gap:8px; align-items:flex-end;">
              <button id="btnPlan" class="primary" style="flex:1;">Plan</button>
              <button id="btnMissing" style="flex:1;">Missing</button>
            </div>
          </div>
          <div id="planOut" class="small" style="margin-top:8px;"></div>
        </div>

        <div class="err" id="err"></div>
      </div>
    </div>
  </div>

  <script>
    const APP_ROOT = (document.querySelector('meta[name="app-root"]')?.content || '').replace(/\/+$/,'');
    const api = (path) => APP_ROOT + path;

    const navCooking = document.getElementById('navCooking');
    if (navCooking) navCooking.href = APP_ROOT + '/cooking';

    const el = (id) => document.getElementById(id);
    const state = {
      mode: 'filters', // filters | tabs | tags
      groups: [],
      activeGroup: null,
      recipes: [],
      activeRecipe: null,
      activeRecipeData: null,
      assets: {},
      icon: null, // {mode, static_base, api_base}
    };

    function setError(msg) {
      el('err').textContent = msg || '';
    }

    function parseInventory(text) {
      const out = {};
      const raw = (text || '').trim();
      if (!raw) return out;

      const parts = raw
        .split(/[,\n]/g)
        .map(s => s.trim())
        .filter(Boolean);

      for (const p of parts) {
        const m = p.match(/^([^=\s]+)\s*(?:=|\s)\s*([0-9]+(?:\.[0-9]+)?)$/);
        if (!m) continue;
        const k = m[1].trim();
        const v = parseFloat(m[2]);
        if (!k || !Number.isFinite(v) || v <= 0) continue;
        out[k] = v;
      }
      return out;
    }

    async function fetchJson(url, opts) {
      const r = await fetch(url, opts || {});
      if (!r.ok) {
        const t = await r.text();
        throw new Error(`HTTP ${r.status} ${r.statusText}\n${t}`);
      }
      return await r.json();
    }

    function escHtml(s) {
      return String(s ?? '').replace(/[&<>"']/g, (c) => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
      }[c]));
    }

    async function loadAssets() {
      try {
        const res = await fetchJson(api('/api/v1/assets'));
        state.assets = res.assets || {};
        state.icon = res.icon || null;
      } catch (e) {
        state.assets = {};
        state.icon = null;
      }
    }

    function _iconUrls(iid) {
      const cfg = state.icon || {};
      const mode = String(cfg.mode || 'off');
      const enc = encodeURIComponent(iid);
      const staticBase = String(cfg.static_base || '/static/icons');
      const apiBase = String(cfg.api_base || '/api/v1/icon');
      const staticUrl = api(`${staticBase}/${enc}.png`);
      const apiUrl = api(`${apiBase}/${enc}.png`);

      if (mode === 'dynamic') return { src: apiUrl, fallback: '' };
      if (mode === 'static') return { src: staticUrl, fallback: '' };
      if (mode === 'auto') return { src: staticUrl, fallback: apiUrl };
      return { src: '', fallback: '' };
    }

    function iconError(img) {
      try {
        const fb = img?.dataset?.fallback || '';
        const tried = img?.dataset?.fallbackTried || '';
        if (fb && !tried) {
          img.dataset.fallbackTried = '1';
          img.src = fb;
          return;
        }
        img.style.display = 'none';
        const nxt = img.nextElementSibling;
        if (nxt) nxt.style.display = 'flex';
      } catch (e) {
        // ignore
      }
    }

    function renderItem(id) {
      const iid = String(id || '').trim();
      if (!iid) return '';
      const m = (state.assets && state.assets[iid]) ? state.assets[iid] : null;
      const name = (m && m.name) ? m.name : iid;

      const tipParts = [iid];
      if (m && m.image) tipParts.push(m.image);
      if (m && m.atlas) tipParts.push(m.atlas);
      const tip = escHtml(tipParts.join(' | '));

      const { src, fallback } = _iconUrls(iid);
      const iconChar = (m && (m.image || m.atlas)) ? '🖼️' : '📦';

      if (!src) {
        return `<span class="itemRef" title="${tip}">` +
          `<span class="itemIcon"><span class="itemIconFallback" style="display:flex;">${iconChar}</span></span>` +
          `<span class="itemLabel">${escHtml(name)}</span></span>`;
      }

      const fbAttr = fallback ? ` data-fallback="${escHtml(fallback)}"` : '';
      return `<span class="itemRef" title="${tip}">` +
        `<span class="itemIcon">` +
          `<img class="itemIconImg" src="${escHtml(src)}"${fbAttr} onerror="iconError(this)" alt="" />` +
          `<span class="itemIconFallback">${iconChar}</span>` +
        `</span>` +
        `<span class="itemLabel">${escHtml(name)}</span>` +
      `</span>`;
    }

    function renderGroupList() {
      const box = el('groupList');
      box.innerHTML = '';
      for (const g of state.groups) {
        const div = document.createElement('div');
        div.className = 'item' + (state.activeGroup === g.name ? ' active' : '');
        div.innerHTML = `<span class="name">${g.name}</span><span class="meta">${g.count ?? ''}</span>`;
        div.onclick = () => selectGroup(g.name);
        box.appendChild(div);
      }
    }

    function renderRecipeList() {
      const box = el('recipeList');
      box.innerHTML = '';
      el('listCount').textContent = state.recipes.length ? `${state.recipes.length}` : '';
      for (const nm of state.recipes) {
        const div = document.createElement('div');
        div.className = 'item' + (state.activeRecipe === nm ? ' active' : '');
        div.innerHTML = `<span class="name">${renderItem(nm)}</span><span class="meta"></span>`;
        div.onclick = () => selectRecipe(nm);
        box.appendChild(div);
      }
    }

    function renderRecipeDetail(rec) {
      if (!rec) {
        el('detail').innerHTML = '<div class="muted">Select a recipe.</div>';
        return;
      }
      const filters = (rec.filters || []).map(x => `<span class="chip">${x}</span>`).join('');
      const tags = (rec.builder_tags || []).map(x => `<span class="chip">${x}</span>`).join('');
      const ings = (rec.ingredients || []).map(i => {
        const item = i.item;
        const amt = i.amount ?? '';
        const num = i.amount_num;
        const extra = (num === null || num === undefined) ? ' <span class="muted">(?)</span>' : '';
        return `<div>• ${renderItem(item)} <span class="mono">x${escHtml(amt)}</span>${extra}</div>`;
      }).join('');

      el('detail').innerHTML = `
        <div style="display:flex; justify-content:space-between; align-items:baseline; gap:10px;">
          <div style="font-size:16px; font-weight:650;">${renderItem(rec.name)}</div>
          <div class="small muted">${String(rec.tab || '').replace('RECIPETABS.','')}</div>
        </div>
        <div class="kv">
          <div class="k">Product</div><div>${rec.product ? renderItem(rec.product) : ''}</div>
          <div class="k">Tech</div><div class="mono">${String(rec.tech || '').replace('TECH.','')}</div>
          <div class="k">Station</div><div class="mono">${rec.station_tag || ''}</div>
          <div class="k">Builder skill</div><div class="mono">${rec.builder_skill || ''}</div>
        </div>
        <div>
          <div class="small muted">Filters</div>
          <div class="chips">${filters || '<span class="muted">-</span>'}</div>
        </div>
        <div>
          <div class="small muted">Builder tags</div>
          <div class="chips">${tags || '<span class="muted">-</span>'}</div>
        </div>
        <div>
          <div class="small muted">Ingredients</div>
          ${ings || '<div class="muted">-</div>'}
          ${(rec.ingredients_unresolved && rec.ingredients_unresolved.length)
            ? `<div class="muted small">Unresolved: ${rec.ingredients_unresolved.join(', ')}</div>`
            : ''}
        </div>
      `;
    }

    async function loadMeta() {
      const m = await fetchJson(api('/api/v1/meta'));
      const sha = m.scripts_sha256_12 ? `sha:${m.scripts_sha256_12}` : '';
      el('meta').textContent = `${sha} | mode:${m.engine_mode || ''} | files:${m.scripts_file_count || ''}`;
    }

    async function loadGroups() {
      setError('');
      if (state.mode === 'filters') {
        el('groupTitle').textContent = 'Filters';
        const res = await fetchJson(api('/api/v1/craft/filters'));
        const order = res.order || [];
        state.groups = order.map(n => ({ name: n, count: '' }));
      } else if (state.mode === 'tabs') {
        el('groupTitle').textContent = 'Tabs';
        const res = await fetchJson(api('/api/v1/craft/tabs'));
        state.groups = (res.tabs || []).map(t => ({ name: t.name, count: t.count }));
      } else {
        el('groupTitle').textContent = 'Tags';
        const res = await fetchJson(api('/api/v1/craft/tags'));
        state.groups = (res.tags || []).map(t => ({ name: t.name, count: t.count }));
      }

      state.activeGroup = null;
      state.recipes = [];
      state.activeRecipe = null;
      state.activeRecipeData = null;
      renderGroupList();
      renderRecipeList();
      renderRecipeDetail(null);
    }

    async function selectGroup(name) {
      setError('');
      state.activeGroup = name;
      renderGroupList();

      let url = '';
      if (state.mode === 'filters') url = api(`/api/v1/craft/filters/${encodeURIComponent(name)}/recipes`);
      else if (state.mode === 'tabs') url = api(`/api/v1/craft/tabs/${encodeURIComponent(name)}/recipes`);
      else url = api(`/api/v1/craft/tags/${encodeURIComponent(name)}/recipes`);

      const res = await fetchJson(url);
      state.recipes = (res.recipes || []);
      state.activeRecipe = null;
      state.activeRecipeData = null;

      el('listTitle').textContent = 'Recipes';
      renderRecipeList();
      renderRecipeDetail(null);
    }

    async function selectRecipe(name) {
      setError('');
      state.activeRecipe = name;
      renderRecipeList();
      const res = await fetchJson(api(`/api/v1/craft/recipes/${encodeURIComponent(name)}`));
      state.activeRecipeData = res.recipe || null;
      renderRecipeDetail(state.activeRecipeData);
    }

    async function doSearch() {
      setError('');
      const q = el('q').value.trim();
      if (!q) return;
      const res = await fetchJson(api(`/api/v1/craft/recipes/search?q=${encodeURIComponent(q)}&limit=200`));
      const results = (res.results || []).map(r => r.name).filter(Boolean);
      state.recipes = results;
      state.activeGroup = null;
      state.activeRecipe = null;
      state.activeRecipeData = null;
      renderGroupList();
      renderRecipeList();
      renderRecipeDetail(null);
      el('listTitle').textContent = `Search: ${q}`;
    }

    async function doPlan() {
      setError('');
      const inv = parseInventory(el('inv').value);
      const builderTag = el('builderTag').value.trim() || null;
      const payload = { inventory: inv, builder_tag: builderTag, strict: false, limit: 200 };
      const res = await fetchJson(api('/api/v1/craft/plan'), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      const craftable = res.craftable || [];
      el('planOut').innerHTML = craftable.length
        ? `<div class="ok">Craftable (${craftable.length})</div><div>${craftable.slice(0,120).map(n => renderItem(n)).join(', ')}</div>`
        : '<div class="muted">No craftable recipes with current inventory.</div>';
    }

    async function doMissing() {
      setError('');
      const nm = state.activeRecipe;
      if (!nm) {
        setError('Select a recipe first.');
        return;
      }
      const inv = parseInventory(el('inv').value);
      const res = await fetchJson(api('/api/v1/craft/missing'), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name: nm, inventory: inv }),
      });
      const miss = res.missing || [];
      if (!miss.length) {
        el('planOut').innerHTML = '<div class="ok">No missing materials.</div>';
        return;
      }
      const lines = miss.map(m => `• ${renderItem(m.item)} need:${escHtml(m.need)} have:${escHtml(m.have)} (${escHtml(m.reason)})`).join('<br/>');
      el('planOut').innerHTML = `<div class="muted">Missing (${miss.length})</div><div class="mono">${lines}</div>`;
    }

    function toggleMode() {
      if (state.mode === 'filters') state.mode = 'tabs';
      else if (state.mode === 'tabs') state.mode = 'tags';
      else state.mode = 'filters';
      loadGroups().catch(e => setError(String(e)));
    }

    // wire
    el('btnToggle').onclick = toggleMode;
    el('btnSearch').onclick = () => doSearch().catch(e => setError(String(e)));
    el('q').addEventListener('keydown', (e) => { if (e.key === 'Enter') doSearch().catch(err => setError(String(err))); });
    el('btnPlan').onclick = () => doPlan().catch(e => setError(String(e)));
    el('btnMissing').onclick = () => doMissing().catch(e => setError(String(e)));

    // init
    (async () => {
      try {
        await loadMeta();
        await loadAssets();
        await loadGroups();
      } catch (e) {
        setError(String(e));
      }
    })();
  </script>
</body>
</html>
"""


def render_index_html(app_root: str = "") -> str:
    """Render the UI page.

    app_root:
      - ""       normal direct serving
      - "/xxx"   reverse proxy mount path
    """
    return _INDEX_TEMPLATE.replace("__WAGSTAFF_APP_ROOT__", escape(app_root or ""))


_COOKING_TEMPLATE = r"""<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="app-root" content="__WAGSTAFF_APP_ROOT__" />
  <title>Wagstaff WebCraft - Cooking</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #0f1722;
      --panel2: #111b29;
      --text: #e6edf3;
      --muted: #9fb0c0;
      --border: #233042;
      --accent: #79c0ff;
      --accent2: #a5d6ff;
      --bad: #ff7b72;
      --ok: #7ee787;
    }
    html, body {
      margin: 0; padding: 0;
      background: var(--bg);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }

    .topbar {
      position: sticky;
      top: 0;
      z-index: 10;
      display: flex;
      gap: 12px;
      align-items: center;
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      background: rgba(11, 15, 20, 0.92);
      backdrop-filter: blur(8px);
    }
    .topbar h1 {
      font-size: 14px;
      margin: 0;
      font-weight: 650;
      letter-spacing: .3px;
      color: var(--accent2);
    }

    .nav {
      font-size: 12px;
      color: var(--muted);
      padding: 4px 10px;
      border: 1px solid var(--border);
      border-radius: 999px;
      background: rgba(17,27,41,0.6);
    }
    .nav:hover {
      text-decoration: none;
      border-color: #3b4b63;
      color: var(--text);
    }
    .nav.active {
      color: var(--text);
      border-color: rgba(121, 192, 255, 0.45);
      background: rgba(121, 192, 255, 0.10);
    }

    .search {
      flex: 1;
      display: flex;
      gap: 8px;
      align-items: center;
    }
    input[type="text"], textarea {
      width: 100%;
      background: var(--panel);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 10px;
      outline: none;
    }
    textarea {
      min-height: 60px;
      resize: vertical;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    button {
      background: var(--panel2);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 8px;
      padding: 8px 10px;
      cursor: pointer;
    }
    button:hover { border-color: #3b4b63; }
    button.primary {
      background: rgba(121, 192, 255, 0.12);
      border-color: rgba(121, 192, 255, 0.25);
    }
    button.primary:hover {
      border-color: rgba(121, 192, 255, 0.45);
    }

    .layout {
      display: grid;
      grid-template-columns: 260px 1fr 420px;
      gap: 10px;
      padding: 10px;
    }
    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      overflow: hidden;
      min-height: calc(100vh - 62px);
    }
    .panel h2 {
      margin: 0;
      padding: 10px 12px;
      font-size: 13px;
      border-bottom: 1px solid var(--border);
      color: var(--muted);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .list {
      max-height: calc(100vh - 62px - 44px);
      overflow: auto;
    }
    .item {
      padding: 8px 12px;
      border-bottom: 1px solid rgba(35, 48, 66, 0.65);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      gap: 10px;
    }
    .item:hover { background: rgba(255,255,255,0.03); }
    .item.active { background: rgba(121,192,255,0.08); }
    .item .name { font-weight: 560; }
    .item .meta { color: var(--muted); font-size: 12px; }

    .detail {
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .kv {
      display: grid;
      grid-template-columns: 120px 1fr;
      gap: 6px 10px;
      font-size: 13px;
    }
    .kv .k { color: var(--muted); }

    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .chip {
      font-size: 12px;
      color: var(--muted);
      padding: 3px 8px;
      border: 1px solid rgba(35,48,66,0.9);
      border-radius: 999px;
      background: rgba(17,27,41,0.8);
    }

    .grid2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .err {
      color: var(--bad);
      font-size: 12px;
      white-space: pre-wrap;
    }
    .ok {
      color: var(--ok);
      font-size: 12px;
    }

    .muted { color: var(--muted); }
    .small { font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .itemRef {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .itemIcon {
      width: 18px;
      height: 18px;
      border-radius: 4px;
      border: 1px solid rgba(35,48,66,0.9);
      background: rgba(17,27,41,0.8);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      flex: 0 0 auto;
      overflow: hidden;
    }
    .itemIconImg {
      width: 100%;
      height: 100%;
      display: block;
      object-fit: contain;
      image-rendering: pixelated;
    }
    .itemIconFallback {
      width: 100%;
      height: 100%;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      color: var(--muted);
    }
    .itemLabel {
      color: var(--text);
    }
  </style>
</head>
<body>
  <div class="topbar">
    <div style="display:flex; gap:10px; align-items:center;">
      <h1>Wagstaff WebCraft</h1>
      <a id="navCraft" class="nav" href="#">Craft</a>
      <a class="nav active" href="#">Cooking</a>
    </div>
    <div class="search">
      <input id="q" type="text" placeholder="Search: meatballs | ing:berries | tag:honeyed | type:FOODTYPE.MEAT" />
      <button id="btnSearch" class="primary">Search</button>
    </div>
    <div class="small muted" id="meta"></div>
  </div>

  <div class="layout">
    <div class="panel">
      <h2>
        <span id="groupTitle">FoodTypes</span>
        <button id="btnToggle">Toggle</button>
      </h2>
      <div class="list" id="groupList"></div>
    </div>

    <div class="panel">
      <h2>
        <span id="listTitle">Recipes</span>
        <span class="small muted" id="listCount"></span>
      </h2>
      <div class="list" id="recipeList"></div>
    </div>

    <div class="panel">
      <h2>Details / Tools</h2>
      <div class="detail">
        <div id="detail"></div>

        <div>
          <div class="small muted">Available ingredients (for search)</div>
          <textarea id="inv" placeholder="berries=2\ncarrot=3\nmeat=1"></textarea>
          <div style="display:flex; gap:8px; margin-top:8px;">
            <button id="btnFind" class="primary" style="flex:1;">Find cookable</button>
            <button id="btnShowAll" style="flex:1;">Show all</button>
          </div>
        </div>

        <div>
          <div class="small muted">Cookpot slots (requires total = 4)</div>
          <textarea id="slots" placeholder="carrot=2\nberries=1\nbutterflywings=1"></textarea>
          <button id="btnSim" class="primary" style="width:100%; margin-top:8px;">Simulate</button>
        </div>

        <div id="out" class="small"></div>
        <div class="err" id="err"></div>
      </div>
    </div>
  </div>

  <script>
    const APP_ROOT = (document.querySelector('meta[name="app-root"]')?.content || '').replace(/\/+$/,'');
    const api = (path) => APP_ROOT + path;

    const el = (id) => document.getElementById(id);

    function setError(msg) {
      el('err').textContent = msg || '';
    }

    function parseInventory(text) {
      const out = {};
      const raw = (text || '').trim();
      if (!raw) return out;

      const parts = raw
        .split(/[,\n]/g)
        .map(s => s.trim())
        .filter(Boolean);

      for (const p of parts) {
        const m = p.match(/^([^=\s]+)\s*(?:=|\s)\s*([0-9]+(?:\.[0-9]+)?)$/);
        if (!m) continue;
        const k = m[1].trim();
        const v = parseFloat(m[2]);
        if (!k || !Number.isFinite(v) || v <= 0) continue;
        out[k] = v;
      }
      return out;
    }

    function parseSlots(text) {
      const raw = (text || '').trim();
      if (!raw) return {};

      // prefer explicit counts
      const asInv = parseInventory(raw);
      if (Object.keys(asInv).length) return asInv;

      // fallback: "a, b, c" means each counts as 1
      const out = {};
      const parts = raw
        .split(/[,\n]/g)
        .map(s => s.trim())
        .filter(Boolean);

      for (const p of parts) {
        out[p] = (out[p] || 0) + 1;
      }
      return out;
    }

    async function fetchJson(url, opts) {
      const r = await fetch(url, opts || {});
      if (!r.ok) {
        const t = await r.text();
        throw new Error(`HTTP ${r.status} ${r.statusText}\n${t}`);
      }
      return await r.json();
    }

    function escHtml(s) {
      return String(s ?? '').replace(/[&<>"']/g, (c) => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
      }[c]));
    }

    async function loadAssets() {
      try {
        const res = await fetchJson(api('/api/v1/assets'));
        state.assets = res.assets || {};
        state.icon = res.icon || null;
      } catch (e) {
        state.assets = {};
        state.icon = null;
      }
    }

    function _iconUrls(iid) {
      const cfg = state.icon || {};
      const mode = String(cfg.mode || 'off');
      const enc = encodeURIComponent(iid);
      const staticBase = String(cfg.static_base || '/static/icons');
      const apiBase = String(cfg.api_base || '/api/v1/icon');
      const staticUrl = api(`${staticBase}/${enc}.png`);
      const apiUrl = api(`${apiBase}/${enc}.png`);

      if (mode === 'dynamic') return { src: apiUrl, fallback: '' };
      if (mode === 'static') return { src: staticUrl, fallback: '' };
      if (mode === 'auto') return { src: staticUrl, fallback: apiUrl };
      return { src: '', fallback: '' };
    }

    function iconError(img) {
      try {
        const fb = img?.dataset?.fallback || '';
        const tried = img?.dataset?.fallbackTried || '';
        if (fb && !tried) {
          img.dataset.fallbackTried = '1';
          img.src = fb;
          return;
        }
        img.style.display = 'none';
        const nxt = img.nextElementSibling;
        if (nxt) nxt.style.display = 'flex';
      } catch (e) {
        // ignore
      }
    }

    function renderItem(id) {
      const iid = String(id || '').trim();
      if (!iid) return '';
      const m = (state.assets && state.assets[iid]) ? state.assets[iid] : null;
      const name = (m && m.name) ? m.name : iid;

      const tipParts = [iid];
      if (m && m.image) tipParts.push(m.image);
      if (m && m.atlas) tipParts.push(m.atlas);
      const tip = escHtml(tipParts.join(' | '));

      const { src, fallback } = _iconUrls(iid);
      const iconChar = (m && (m.image || m.atlas)) ? '🖼️' : '📦';

      if (!src) {
        return `<span class="itemRef" title="${tip}">` +
          `<span class="itemIcon"><span class="itemIconFallback" style="display:flex;">${iconChar}</span></span>` +
          `<span class="itemLabel">${escHtml(name)}</span></span>`;
      }

      const fbAttr = fallback ? ` data-fallback="${escHtml(fallback)}"` : '';
      return `<span class="itemRef" title="${tip}">` +
        `<span class="itemIcon">` +
          `<img class="itemIconImg" src="${escHtml(src)}"${fbAttr} onerror="iconError(this)" alt="" />` +
          `<span class="itemIconFallback">${iconChar}</span>` +
        `</span>` +
        `<span class="itemLabel">${escHtml(name)}</span>` +
      `</span>`;
    }

    const state = {
      mode: 'foodtypes', // foodtypes | tags | all
      groups: [],
      activeGroup: null,
      recipes: [],
      activeRecipe: null,
      activeRecipeData: null,
      assets: {},
      icon: null, // {mode, static_base, api_base}
    };

    function renderGroupList() {
      const box = el('groupList');
      box.innerHTML = '';
      for (const g of state.groups) {
        const div = document.createElement('div');
        div.className = 'item' + (state.activeGroup === g.name ? ' active' : '');
        div.innerHTML = `<span class="name">${g.name}</span><span class="meta">${g.count ?? ''}</span>`;
        div.onclick = () => selectGroup(g.name);
        box.appendChild(div);
      }
    }

    function renderRecipeList() {
      const box = el('recipeList');
      box.innerHTML = '';
      el('listCount').textContent = state.recipes.length ? `${state.recipes.length}` : '';
      for (const nm of state.recipes) {
        const div = document.createElement('div');
        div.className = 'item' + (state.activeRecipe === nm ? ' active' : '');
        div.innerHTML = `<span class="name">${renderItem(nm)}</span><span class="meta"></span>`;
        div.onclick = () => selectRecipe(nm);
        box.appendChild(div);
      }
    }

    function renderRecipeDetail(rec) {
      if (!rec) {
        el('detail').innerHTML = '<div class="muted">Select a recipe.</div>';
        return;
      }

      const tags = (rec.tags || []).map(x => `<span class="chip">${x}</span>`).join('');
      const card = (rec.card_ingredients || []).map(row => {
        const item = row[0];
        const cnt = row[1];
        return `<div>• ${renderItem(item)} <span class="mono">x${escHtml(cnt)}</span></div>`;
      }).join('');

      el('detail').innerHTML = `
        <div style="display:flex; justify-content:space-between; align-items:baseline; gap:10px;">
          <div style="font-size:16px; font-weight:650;">${renderItem(rec.name || '')}</div>
          <div class="small muted">${String(rec.foodtype || '').replace('FOODTYPE.','')}</div>
        </div>
        <div class="kv">
          <div class="k">Priority</div><div class="mono">${rec.priority ?? ''}</div>
          <div class="k">Hunger</div><div class="mono">${rec.hunger ?? ''}</div>
          <div class="k">Health</div><div class="mono">${rec.health ?? ''}</div>
          <div class="k">Sanity</div><div class="mono">${rec.sanity ?? ''}</div>
          <div class="k">Perish</div><div class="mono">${rec.perishtime ?? ''}</div>
          <div class="k">Cooktime</div><div class="mono">${rec.cooktime ?? ''}</div>
        </div>
        <div>
          <div class="small muted">Tags</div>
          <div class="chips">${tags || '<span class="muted">-</span>'}</div>
        </div>
        <div>
          <div class="small muted">Card ingredients</div>
          ${card || '<div class="muted">(missing in catalog)</div>'}
        </div>
      `;
    }

    async function loadMeta() {
      const m = await fetchJson(api('/api/v1/meta'));
      const sha = m.scripts_sha256_12 ? `sha:${m.scripts_sha256_12}` : '';
      el('meta').textContent = `${sha} | mode:${m.engine_mode || ''} | files:${m.scripts_file_count || ''}`;
    }

    async function loadGroups() {
      setError('');

      if (state.mode === 'foodtypes') {
        el('groupTitle').textContent = 'FoodTypes';
        const res = await fetchJson(api('/api/v1/cooking/foodtypes'));
        state.groups = (res.foodtypes || []).map(t => ({ name: t.name, count: t.count }));
      } else if (state.mode === 'tags') {
        el('groupTitle').textContent = 'Tags';
        const res = await fetchJson(api('/api/v1/cooking/tags'));
        state.groups = (res.tags || []).map(t => ({ name: t.name, count: t.count }));
      } else {
        el('groupTitle').textContent = 'All';
        const res = await fetchJson(api('/api/v1/cooking/recipes'));
        state.groups = [{ name: 'ALL', count: res.count || '' }];
      }

      state.activeGroup = null;
      state.recipes = [];
      state.activeRecipe = null;
      state.activeRecipeData = null;
      renderGroupList();
      renderRecipeList();
      renderRecipeDetail(null);
    }

    async function selectGroup(name) {
      setError('');
      state.activeGroup = name;
      renderGroupList();

      let url = '';
      if (state.mode === 'foodtypes') url = api(`/api/v1/cooking/foodtypes/${encodeURIComponent(name)}/recipes`);
      else if (state.mode === 'tags') url = api(`/api/v1/cooking/tags/${encodeURIComponent(name)}/recipes`);
      else url = api('/api/v1/cooking/recipes');

      const res = await fetchJson(url);
      state.recipes = (res.recipes || []);
      state.activeRecipe = null;
      state.activeRecipeData = null;

      el('listTitle').textContent = (state.mode === 'all') ? 'All recipes' : `Recipes`;
      renderRecipeList();
      renderRecipeDetail(null);
    }

    async function selectRecipe(name) {
      setError('');
      state.activeRecipe = name;
      renderRecipeList();
      const res = await fetchJson(api(`/api/v1/cooking/recipes/${encodeURIComponent(name)}`));
      state.activeRecipeData = res.recipe || null;
      // ensure name always present
      if (state.activeRecipeData && !state.activeRecipeData.name) state.activeRecipeData.name = name;
      renderRecipeDetail(state.activeRecipeData);
    }

    async function doSearch() {
      setError('');
      const q = el('q').value.trim();
      if (!q) return;
      const res = await fetchJson(api(`/api/v1/cooking/recipes/search?q=${encodeURIComponent(q)}&limit=200`));
      const results = (res.results || []).map(r => r.name).filter(Boolean);
      state.recipes = results;
      state.activeGroup = null;
      state.activeRecipe = null;
      state.activeRecipeData = null;
      renderGroupList();
      renderRecipeList();
      renderRecipeDetail(null);
      el('listTitle').textContent = `Search: ${q}`;
    }

    async function showAll() {
      setError('');
      const res = await fetchJson(api('/api/v1/cooking/recipes'));
      state.recipes = (res.recipes || []);
      state.activeGroup = null;
      state.activeRecipe = null;
      state.activeRecipeData = null;
      renderGroupList();
      renderRecipeList();
      renderRecipeDetail(null);
      el('listTitle').textContent = 'All recipes';
    }

    async function doFind() {
      setError('');
      const inv = parseInventory(el('inv').value);
      const res = await fetchJson(api('/api/v1/cooking/find'), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ inventory: inv, limit: 200 }),
      });

      const cookable = res.cookable || [];
      state.recipes = cookable;
      state.activeGroup = null;
      state.activeRecipe = null;
      state.activeRecipeData = null;
      renderGroupList();
      renderRecipeList();
      renderRecipeDetail(null);

      el('listTitle').textContent = `Cookable (${cookable.length})`;
      el('out').innerHTML = res.note ? `<div class="muted">${res.note}</div>` : '';
    }

    async function doSimulate() {
      setError('');
      const slots = parseSlots(el('slots').value);
      const res = await fetchJson(api('/api/v1/cooking/simulate'), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ slots: slots, return_top: 20 }),
      });

      if (!res.ok) {
        el('out').innerHTML = `<div class="err">${res.error || 'simulation_failed'} (total=${res.total ?? ''})</div>`;
        return;
      }

      const result = res.result || '(none)';
      const reason = res.reason || '';
      const cand = res.candidates || [];
      const lines = cand.length
        ? cand.map(c => `• ${renderItem(c.name)} (p=${escHtml(c.priority)}, w=${escHtml(c.weight)})`).join('<br/>')
        : '<span class="muted">No candidates (fallback).</span>';

      el('out').innerHTML = `
        <div class="ok">Result: ${renderItem(result)} <span class="muted">${reason ? '('+reason+')' : ''}</span></div>
        <div class="small muted" style="margin-top:6px;">Top matches</div>
        <div class="mono">${lines}</div>
      `;

      // auto-select result if exists
      if (res.recipe) {
        state.activeRecipe = result;
        state.activeRecipeData = res.recipe;
        if (state.activeRecipeData && !state.activeRecipeData.name) state.activeRecipeData.name = result;
        renderRecipeList();
        renderRecipeDetail(state.activeRecipeData);
      }
    }

    function toggleMode() {
      if (state.mode === 'foodtypes') state.mode = 'tags';
      else if (state.mode === 'tags') state.mode = 'all';
      else state.mode = 'foodtypes';
      loadGroups().catch(e => setError(String(e)));
    }

    // wire
    const navCraft = document.getElementById('navCraft');
    if (navCraft) navCraft.href = APP_ROOT + '/';

    el('btnToggle').onclick = toggleMode;
    el('btnSearch').onclick = () => doSearch().catch(e => setError(String(e)));
    el('q').addEventListener('keydown', (e) => { if (e.key === 'Enter') doSearch().catch(err => setError(String(err))); });
    el('btnFind').onclick = () => doFind().catch(e => setError(String(e)));
    el('btnSim').onclick = () => doSimulate().catch(e => setError(String(e)));
    el('btnShowAll').onclick = () => showAll().catch(e => setError(String(e)));

    // init
    (async () => {
      try {
        await loadMeta();
        await loadAssets();
        await loadGroups();
        await showAll();
      } catch (e) {
        setError(String(e));
      }
    })();
  </script>
</body>
</html>
"""


def render_cooking_html(app_root: str = "") -> str:
    """Render the Cooking UI page."""
    from html import escape as _esc

    return _COOKING_TEMPLATE.replace("__WAGSTAFF_APP_ROOT__", _esc(app_root or ""))
```

### File: src/wiki.py
- mode: interface
- size_bytes: 22283
- sha256_12: 98e8c40fe7ba

```py
"""src/wiki.py"""

def _parse_inventory_spec(spec: str) -> Dict[str, float]:
    """Parse inventory spec into {item: count}."""

class WagstaffWiki:
    ...
    def run(self, args):
    def _print_help(self):
    def _search_recipe(self, query):
    def _render_recipe_list(self, title: str, names):
    def _list_recipe_by_tab(self, tab):
    def _list_recipe_by_filter(self, flt):
    def _list_recipe_by_builder_tag(self, tag):
    def _list_recipe_by_tech(self, tech):
    def _list_recipe_tabs(self):
    def _list_recipe_filters(self):
    def _list_recipe_by_ingredient(self, item: str):
    def _list_recipe_craftable(self, inv: Dict[str, float]):
    def _recipe_missing(self, recipe: str, inv: Dict[str, float]):
    def _show_food(self, query: str):
    def _list_food_cookable(self, inv: Dict[str, float]):
    def _analyze_prefab(self, query):
    def _find_loot_table(self, query):
    def _render_loot_table(self, filepath, table_name, content):
    def _global_search_interactive(self, query):

def main(argv=None):
    ...
```

## 6. Snapshot Stats
```yaml
total_candidates: 2324
included_records: 51
embedded_files: 37
max_total_bytes: 1200000
bytes_remaining: 961255
```
